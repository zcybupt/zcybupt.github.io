<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AVL树</title>
    <url>/2020/07/31/AVL/</url>
    <content><![CDATA[<p><a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">AVL树的可视化</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>AVL</tag>
      </tags>
  </entry>
  <entry>
    <title>固定长度的数组实现队列</title>
    <url>/2020/02/10/ArrayQueue/</url>
    <content><![CDATA[<p>通过记录数组中实际元素数量 <code>size</code> 来判断队列状态, 仅考虑 <code>start</code> 和 <code>end</code> 与 <code>size</code> 的关系, 无需考虑 <code>start</code> 与 <code>end</code> 的关系.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> initSize)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[initSize];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> newEle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;The queue is full&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        arr[end] = newEle;</span><br><span class="line">        end = nextIndex(end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;The queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">        start = nextIndex(start);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index == arr.length - <span class="number">1</span> ? <span class="number">0</span> : index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Code_02_ArrayQueue</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Code_02_ArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">        arrayQueue.enQueue(<span class="number">4</span>);</span><br><span class="line">        arrayQueue.enQueue(<span class="number">5</span>);</span><br><span class="line">        arrayQueue.enQueue(<span class="number">6</span>);</span><br><span class="line">        System.out.println(arrayQueue.deQueue());</span><br><span class="line">        System.out.println(arrayQueue.deQueue());</span><br><span class="line">        System.out.println(arrayQueue.deQueue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题-LeetCode-622"><a href="#例题-LeetCode-622" class="headerlink" title="例题: LeetCode #622"></a>例题: <a href="https://leetcode-cn.com/problems/design-circular-queue">LeetCode #622</a></h2><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p>
<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p>
<p>你的实现应该支持如下操作：</p>
<ul>
<li>  MyCircularQueue(k): 构造器，设置队列长度为 k 。</li>
<li>  Front: 从队首获取元素。如果队列为空，返回 -1 。</li>
<li>  Rear: 获取队尾元素。如果队列为空，返回 -1 。</li>
<li>  enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。</li>
<li>  deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。</li>
<li>  isEmpty(): 检查循环队列是否为空。</li>
<li>  isFull(): 检查循环队列是否已满。</li>
</ul>
<p><strong>以上的实现使 <code>end</code> 指向了队尾元素的下一个位置, 在数组存满时 <code>Rear()</code> 将返回队首元素, 需修改使 <code>end</code> 指向队尾元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize your data structure here. Set the size of the queue to be k.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCircularQueue</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        end = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Insert an element into the circular queue. Return true if the operation is</span></span><br><span class="line"><span class="comment">     * successful.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        end = nextIndex(end);</span><br><span class="line">        arr[end] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Delete an element from the circular queue. Return true if the operation is</span></span><br><span class="line"><span class="comment">     * successful.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;deQueue: &quot;</span> + arr[start]);</span><br><span class="line">        size--;</span><br><span class="line">        start = nextIndex(start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the next index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index == arr.length - <span class="number">1</span> ? <span class="number">0</span> : index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the front item from the queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the last item from the queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Rear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[end];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks whether the circular queue is empty or not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks whether the circular queue is full or not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == arr.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCircularQueue</span> <span class="variable">circularQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCircularQueue</span>(<span class="number">3</span>); <span class="comment">// 设置长度为 3</span></span><br><span class="line">        circularQueue.enQueue(<span class="number">1</span>); <span class="comment">// 返回 true</span></span><br><span class="line">        circularQueue.enQueue(<span class="number">2</span>); <span class="comment">// 返回 true</span></span><br><span class="line">        circularQueue.enQueue(<span class="number">3</span>); <span class="comment">// 返回 true</span></span><br><span class="line">        circularQueue.enQueue(<span class="number">4</span>); <span class="comment">// 返回 false，队列已满</span></span><br><span class="line">        circularQueue.Rear(); <span class="comment">// 返回 3</span></span><br><span class="line">        circularQueue.isFull(); <span class="comment">// 返回 true</span></span><br><span class="line">        circularQueue.deQueue(); <span class="comment">// 返回 true</span></span><br><span class="line">        circularQueue.enQueue(<span class="number">4</span>); <span class="comment">// 返回 true</span></span><br><span class="line">        circularQueue.Rear(); <span class="comment">// 返回 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>队列</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>BFPRT</title>
    <url>/2020/07/23/BFPRT/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-215"><a href="#题目-LeetCode-215" class="headerlink" title="题目(LeetCode #215)"></a>题目(<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">LeetCode #215</a>)</h2><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>  输入: [3,2,1,5,6,4] 和 k = 2<br>  输出: 5</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4</p>
</blockquote>
<p><strong>说明:</strong></p>
<p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参考资料：</p>
<p><a href="https://segmentfault.com/a/1190000008322873">https://segmentfault.com/a/1190000008322873</a></p>
<p><a href="https://www.jianshu.com/p/a43b0e1712d1">https://www.jianshu.com/p/a43b0e1712d1</a></p>
<p><a href="https://www.cnblogs.com/ldy-miss/p/12031077.html">https://www.cnblogs.com/ldy-miss/p/12031077.html</a></p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BFPRT</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] copyArr = copyArray(arr);</span><br><span class="line">        <span class="keyword">return</span> select(copyArr, <span class="number">0</span>, copyArr.length - <span class="number">1</span>, K - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyArray(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != res.length; i++) &#123;</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[begin];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> medianOfMedians(arr, begin, end);</span><br><span class="line">        <span class="type">int</span>[] pivotRange = partition(arr, begin, end, pivot);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= pivotRange[<span class="number">0</span>] &amp;&amp; i &lt;= pivotRange[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; pivotRange[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> select(arr, begin, pivotRange[<span class="number">0</span>] - <span class="number">1</span>, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> select(arr, pivotRange[<span class="number">1</span>] + <span class="number">1</span>, end, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">medianOfMedians</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> end - begin + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> num % <span class="number">5</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] mArr = <span class="keyword">new</span> <span class="title class_">int</span>[num / <span class="number">5</span> + offset];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mArr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">beginI</span> <span class="operator">=</span> begin + i * <span class="number">5</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">endI</span> <span class="operator">=</span> beginI + <span class="number">4</span>;</span><br><span class="line">            mArr[i] = getMedian(arr, beginI, Math.min(end, endI));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return getMedian(mArr, 0, mArr.length - 1);</span></span><br><span class="line">        <span class="keyword">return</span> select(mArr, <span class="number">0</span>, mArr.length - <span class="number">1</span>, mArr.length / <span class="number">2</span>); <span class="comment">// 实测比直接调用 getMedian 更快</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] partition(<span class="type">int</span>[] arr, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span> pivotValue) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> begin - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> begin;</span><br><span class="line">        <span class="type">int</span> <span class="variable">big</span> <span class="operator">=</span> end + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != big) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[cur] &gt; pivotValue) &#123;</span><br><span class="line">                swap(arr, ++small, cur++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &lt; pivotValue) &#123;</span><br><span class="line">                swap(arr, cur, --big);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] range = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        range[<span class="number">0</span>] = small + <span class="number">1</span>;</span><br><span class="line">        range[<span class="number">1</span>] = big - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> range;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMedian</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        insertionSort(arr, begin, end);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> end + begin;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (sum / <span class="number">2</span>) + (sum % <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[mid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin + <span class="number">1</span>; i != end + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j != begin; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                    swap(arr, j - <span class="number">1</span>, j);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[index1];</span><br><span class="line">        arr[index1] = arr[index2];</span><br><span class="line">        arr[index2] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>BFPRT</tag>
      </tags>
  </entry>
  <entry>
    <title>广度优先遍历</title>
    <url>/2020/06/20/BFS/</url>
    <content><![CDATA[<p>树和图的广度优先遍历可借助一个队列和一个集合实现. 先将当前节点分别放入队列和集合中, 再依次出队, 出队元素将其下一个节点进队, 迭代即可实现广度优先遍历.</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200620202932.png"></p>
<p>以上图为例, 图的节点定义及整体结构见<a href="https://zcybupt.github.io/post/Graph/">上一篇博客</a></p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BFS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(GraphNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;GraphNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;GraphNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        queue.add(node);</span><br><span class="line">        set.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">GraphNode</span> <span class="variable">curNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.print(curNode.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (GraphNode next : curNode.nexts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    queue.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 无权重, 假定都为 1</span></span><br><span class="line">        Integer[][] nodes = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> GraphBuilder.createGraph(nodes);</span><br><span class="line">        bfs(graph.nodes.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 7 5 6</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    ele_queue = Queue()</span><br><span class="line">    ele_set = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    ele_queue.put(node)</span><br><span class="line">    ele_set.add(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ele_queue.qsize() != <span class="number">0</span>:</span><br><span class="line">        current_node = ele_queue.get()</span><br><span class="line">        <span class="built_in">print</span>(current_node.value, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> next_node <span class="keyword">in</span> current_node.nexts:</span><br><span class="line">            <span class="keyword">if</span> next_node <span class="keyword">not</span> <span class="keyword">in</span> ele_set:</span><br><span class="line">                ele_set.add(next_node)</span><br><span class="line">                ele_queue.put(next_node)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>日程安排问题</title>
    <url>/2020/07/15/BestArrange/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一些项目要占用一个会议室宣讲, 会议室不能同时容纳两个项目的宣讲. 给定每个项目的开始和结束时间 (输入为数组, 其中是一个个具体的项目), 合理安排宣讲日程, 使得会议室进行的宣讲场次最多, 返回这个最多的场次</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题不可按开始时间排序, 若某个宣讲开始时间早但持续时间长, 可能不如多个晚开始的宣讲场次多; 也不可按持续时间长短, 某个短时间的宣讲可能与其它宣讲的起始时间重叠.</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200715202427.png"></p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Program</span> &#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Program</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BestArrange</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bestArrange</span><span class="params">(Program[] programs, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        Arrays.sort(programs, (a, b) -&gt; a.end - b.end);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Program program : programs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start &lt;= program.start) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                start = program.end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Program</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, end</span>):</span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_best_arrange</span>(<span class="params">programs, start</span>):</span><br><span class="line">    programs.sort(key=<span class="keyword">lambda</span> x: x.end)</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> program <span class="keyword">in</span> programs:</span><br><span class="line">        <span class="keyword">if</span> start &lt;= program.start:</span><br><span class="line">            result += <span class="number">1</span></span><br><span class="line">            start = program.end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Program <span class="keyword">struct</span> &#123;</span><br><span class="line">	start, end <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBestArrange</span><span class="params">(programs []Program, start <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(programs); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(programs)<span class="number">-1</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> programs[j].end &gt; programs[j+<span class="number">1</span>].end &#123;</span><br><span class="line">				programs[j], programs[j+<span class="number">1</span>] = programs[j+<span class="number">1</span>], programs[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	result := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, program := <span class="keyword">range</span> programs &#123;</span><br><span class="line">		<span class="keyword">if</span> start &lt;= program.start &#123;</span><br><span class="line">			result++</span><br><span class="line">			start = program.end</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>贪心问题</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉查找树</title>
    <url>/2020/07/28/BinarySearchTree/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">二叉查找树</a><strong>，也称为</strong>二叉搜索树</strong>、<strong>有序二叉树</strong>（ordered binary tree）或<strong>排序二叉树</strong>（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p>
<ol>
<li> 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li> 若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；</li>
<li> 任意节点的左、右子树也分别为二叉查找树；</li>
</ol>
<p>其优势在于查找、插入的时间复杂度较低，理想情况下为 <code>O(logn)</code> 。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node parent;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value, Node parent, Node left, Node right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> ele)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="literal">null</span> &amp;&amp; tmp.value != ele) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ele &lt; tmp.value) &#123;</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = tmp.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>先找到待插入节点的父节点，再插入新节点并返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">insert</span><span class="params">(<span class="type">int</span> ele)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(ele, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到即将插入元素的父节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="literal">null</span>) &#123;</span><br><span class="line">        parent = tmp;</span><br><span class="line">        <span class="keyword">if</span> (ele &lt; tmp.value) &#123;</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = tmp.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(ele, parent, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (parent.value &gt; ele) &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><h4 id="替换-移植节点"><a href="#替换-移植节点" class="headerlink" title="替换 / 移植节点"></a>替换 / 移植节点</h4><p>使用 <code>newNode</code> 替换 <code>nodeToReplace</code> ，并返回被替换的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">transplant</span><span class="params">(Node nodeToReplace, Node newNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeToReplace.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeToReplace == nodeToReplace.parent.left) &#123;</span><br><span class="line">        nodeToReplace.parent.left = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nodeToReplace.parent.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        newNode.parent = nodeToReplace.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="找到后继节点"><a href="#找到后继节点" class="headerlink" title="找到后继节点"></a>找到后继节点</h4><p>找到节点的中序后继，即该节点右子树上的最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getMinimum</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>将待删除节点的中序后继移动到待删除节点位置，并调整树的结构</p>
<ul>
<li><p>若待删除节点的父节点无左子树或右子树，直接将该节点的右子树或左子树上移即可；</p>
<p>  <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200730102431.png"></p>
</li>
<li><p>若待删除节点的左右子树均不为空，以下图所示树为例，其中 9 为待删除节点，此时其中序后继 10 与 9 不直接相连</p>
<p>  <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200730153412.png"></p>
<ul>
<li>  先找到待删除节点的中序后继，在此为 10，即为待删除节点的替换节点，此时该后继不与待删除节点直接相连，先将其子树 11 移至 10 位置。①使 <code>successorNode.right</code> 指向待删除节点 9 的 <code>right</code> ，②使 <code>successorNode.right.parent</code> 指向 10，得到：</li>
</ul>
<p>  <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200730154437.png"></p>
<ul>
<li>  再将 <code>successorNode</code> 移到 <code>deleteNode</code> 的位置，并修改其左子树的指向。</li>
</ul>
<p>  <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200730154935.png"></p>
</li>
<li><p>若中序后继与待删除节点直接相连，如下图所示：</p>
<p>  <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200730160504.png"></p>
<ul>
<li>  9 与 12 直接相连，则直接将 12 上移至 9 的位置，并修改 12 的左子树指向即可。</li>
</ul>
<p>  <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200730160537.png"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">delete</span><span class="params">(Node deleteNode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (deleteNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">nodeToReturn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (deleteNode.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            nodeToReturn = transplant(deleteNode, deleteNode.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deleteNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            nodeToReturn = transplant(deleteNode, deleteNode.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">successorNode</span> <span class="operator">=</span> getMinimum(deleteNode.right);</span><br><span class="line">            <span class="keyword">if</span> (successorNode.parent != deleteNode) &#123;</span><br><span class="line">                transplant(successorNode, successorNode.right);</span><br><span class="line">                successorNode.right = deleteNode.right;</span><br><span class="line">                successorNode.right.parent = successorNode;</span><br><span class="line">            &#125;</span><br><span class="line">            transplant(deleteNode, successorNode);</span><br><span class="line">            successorNode.left = deleteNode.left;</span><br><span class="line">            successorNode.left.parent = successorNode;</span><br><span class="line">            nodeToReturn = successorNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodeToReturn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>插入或删除节点过程中如果不及时调整，将使查找效率降低，如将数组 <code>[2, 3, 4, 5, 6]</code> 插入树的过程中，不加调整将得到如下结构，此时查找和插入效率退化至 <code>O(n)</code> 。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200729204357.png"></p>
<p>为解决查找效率退化的问题，又提出了 AVL 树和红黑树等，可将最坏效率降至 <code>O(logn)</code>。</p>
<p><a href="https://github.com/zcybupt/rawfiles/blob/master/codes/Java/Code_50_BinarySearchTree.java">完整代码</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>非递归遍历二叉树</title>
    <url>/2020/06/10/BinaryTreeTraversal/</url>
    <content><![CDATA[<h3 id="题目-LeetCode-94-144-145"><a href="#题目-LeetCode-94-144-145" class="headerlink" title="题目 (LeetCode #94, #144, #145)"></a>题目 (LeetCode <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">#94</a>, <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">#144</a>, <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">#145</a>)</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>利用栈实现二叉树的非递归遍历, 先将头结点放入栈中, 若栈不为空则一直循环, 弹出栈中元素, 若弹出的元素含有子节点则将子元素按先<strong>右</strong>后<strong>左</strong>的顺序压入栈中, 直到所有节点全部弹出.</p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreorderTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            stack.push(root);</span><br><span class="line"></span><br><span class="line">            TreeNode tmp;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                tmp = stack.pop();</span><br><span class="line">                result.add(tmp.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    stack.push(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    stack.push(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PreorderTraversal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorder_traversal</span>(<span class="params">self, root</span>):</span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(root)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                tmp = stack.pop()</span><br><span class="line">                result.append(tmp.val)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> tmp.right: stack.append(tmp.right)</span><br><span class="line">                <span class="keyword">if</span> tmp.left: stack.append(tmp.left)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历可仿照先序遍历, 改变左右子树入栈顺序, 即先入栈左子树, 后入栈右子树, 以实现中右左依次出栈. 出栈时, 先将出栈元素放入另一个辅助栈中, 再全部依次出栈, 这样即实现了对每棵子树的逆序, 即最终为左右中的后序遍历顺序.</p>
<h5 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostorderTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            Stack&lt;TreeNode&gt; help = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            stack.add(root);</span><br><span class="line"></span><br><span class="line">            TreeNode tmp;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                tmp = stack.pop();</span><br><span class="line">                help.push(tmp);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    stack.push(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    stack.push(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!help.isEmpty()) &#123;</span><br><span class="line">                result.add(help.pop().val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PostorderTraversal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorder_traversal</span>(<span class="params">self, root</span>):</span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            stack = []</span><br><span class="line">            help_stack = []</span><br><span class="line">            stack.append(root)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                tmp = stack.pop()</span><br><span class="line">                help_stack.append(tmp.val)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> tmp.left: stack.append(tmp.left)</span><br><span class="line">                <span class="keyword">if</span> tmp.right: stack.append(tmp.right)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> help_stack:</span><br><span class="line">                result.append(help_stack.pop())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200611151449.png"></p>
<p>先将左边界全部压入栈中, 再逐级向上弹出, 弹出过程中若该节点的左子树不为 null 则压入该左子树的边界.</p>
<h5 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InorderTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                    stack.push(root);</span><br><span class="line">                    root = root.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    root = stack.pop();</span><br><span class="line">                    result.add(root.val);</span><br><span class="line">                    root = root.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python-2"><a href="#Python-2" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InorderTraversal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorder_traversal</span>(<span class="params">self, root</span>):</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            stack = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">                <span class="keyword">if</span> root:</span><br><span class="line">                    stack.append(root)</span><br><span class="line">                    root = root.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    root = stack.pop()</span><br><span class="line">                    result.append(root.val)</span><br><span class="line">                    root = root.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>二叉树</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>康托展开与逆康托展开</title>
    <url>/2020/09/10/CantorExpansion/</url>
    <content><![CDATA[<h2 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。</p>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200910172307.png" style="zoom:60%;" />

<p>其中 a<sub>i</sub> 为整数，且 0 ≤ a<sub>i</sub> ≤ i, 1 ≤ i ≤ n .</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>以 <code>[4, 2, 3, 1]</code> 为例，以 4 为第一位的排列之前的排列的第一位可能为 1、2、3，共 3 种情况，而第 2、3、4 位上的顺序又有 3! 种可能。此时 a<sub>n</sub> = 3，n - 1 = 3, 故第一位为 4 的排列之前共有 18 种排列。以此类推，可计算在第一位为 4，第二位为 2 的情况之前的排列数量，此时比 2 小的只有一个数 1，故 a<sub>n</sub> = 1, n - 2 = 2，故第二项为 2。后续过程类似，由于计算的是当前排列的次序，故还需将结果加 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CantorExpansion</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] facts = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFactorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> facts[n];</span><br><span class="line">        <span class="keyword">return</span> n * getFactorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cantor</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrLen</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arrLen; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            result += cnt * getFactorial(arrLen - i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> nums[] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">CantorExpansion</span>().cantor(nums));	<span class="comment">// 22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开"></a>逆康托展开</h2><p>因为排列的次序与排列是一一对应的，故可由排列数直接推得排列。</p>
<p>例如，对数组 <code>[1, 2, 3, 4]</code> 的全排列序列来说，求第 23 个排列：</p>
<ul>
<li>  首先减去 1 求得该序列前共有 22 种排列</li>
<li>  再用 22 除 (4 - 1)!，商 3 余 4，故这个排列比第一位小的共有 3 个数，故第一位为 4</li>
<li>  用 4 除 (3 - 1)!，商 2 余 0，故剩余的数中比第二位小的数共有 2 个，所以第二位为 3</li>
<li>  用 0 除 (2 - 1)!，商 0 余 0，故剩余的数中比第三位小的数有 0 个，所以第三位为 1</li>
<li>  用 0 除 (1 - 1)!，商 0 余 0，故比第四位小的数有 0 个，所以第四位为仅剩的 2</li>
</ul>
<p>所以第 23 个排列为 4312。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CantorExpansion</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] facts = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFactorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> facts[n];</span><br><span class="line">        <span class="keyword">return</span> n * getFactorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">inverseCantor</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrLen</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">char</span>[] result = <span class="keyword">new</span> <span class="title class_">char</span>[arrLen];</span><br><span class="line">        <span class="type">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[arrLen];</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmpFact</span> <span class="operator">=</span> getFactorial(arrLen - <span class="number">1</span> - i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> n / tmpFact;</span><br><span class="line">            n %= tmpFact;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arrLen; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isVisited[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt-- == <span class="number">0</span>) &#123;</span><br><span class="line">                    isVisited[j] = <span class="literal">true</span>;</span><br><span class="line">                    result[i] = (<span class="type">char</span>) (nums[j] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> nums[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">CantorExpansion</span>().inverseCantor(nums, <span class="number">23</span>)); <span class="comment">// 4312</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题-LeetCode-60"><a href="#例题-LeetCode-60" class="headerlink" title="例题(LeetCode #60)"></a>例题(<a href="https://leetcode-cn.com/problems/permutation-sequence/">LeetCode #60</a>)</h2><h3 id="第-k-个排列"><a href="#第-k-个排列" class="headerlink" title="第 k 个排列"></a>第 k 个排列</h3><p>给出集合 <code>[1,2,3,…,n]</code>，其所有元素共有 n! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p>
<ol>
<li> “123”</li>
<li> “132”</li>
<li> “213”</li>
<li> “231”</li>
<li> “312”</li>
<li> “321”</li>
</ol>
<p>给定 n 和 k，返回第 k 个排列。</p>
<p><strong>说明：</strong></p>
<ul>
<li>  给定 n 的范围是 [1, 9]。</li>
<li>  给定 k 的范围是[1,  n!]。</li>
</ul>
<p><strong>示例 1:</strong></p>
<blockquote>
<p><strong>输入:</strong>  n = 3, k = 3<br><strong>输出:</strong>  “213”</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p><strong>输入:</strong> n = 4, k = 9<br><strong>输出:</strong> “2314”</p>
</blockquote>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>采用逆康托展开直接计算</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] facts = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFactorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> facts[n];</span><br><span class="line">        <span class="keyword">return</span> n * getFactorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmpFact</span> <span class="operator">=</span> getFactorial(n - <span class="number">1</span> - i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> k / tmpFact;</span><br><span class="line">            k %= tmpFact;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isVisited[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt-- == <span class="number">0</span>) &#123;</span><br><span class="line">                    isVisited[j] = <span class="literal">true</span>;</span><br><span class="line">                    result.append(j + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.facts = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_fact</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">10</span>: <span class="keyword">return</span> self.facts[n]</span><br><span class="line">        <span class="keyword">return</span> n * self.get_fact(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPermutation</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        result = []</span><br><span class="line">        is_visited = [<span class="literal">False</span>] * n</span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            tmp_fact = self.get_fact(n - <span class="number">1</span> - i)</span><br><span class="line">            cnt = k // tmp_fact</span><br><span class="line">            k %= tmp_fact</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> is_visited[j]: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                    is_visited[j] = <span class="literal">True</span></span><br><span class="line">                    result.append(<span class="built_in">str</span>(j + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cnt -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(result)</span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> facts = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFact</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> facts[n]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * getFact(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPermutation</span><span class="params">(n <span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">string</span></span><br><span class="line">    isVisited := <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">    k--</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        tmpFact := getFact(n - <span class="number">1</span> - i)</span><br><span class="line">        cnt := k / tmpFact</span><br><span class="line">        k %= tmpFact</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> isVisited[j] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">0</span> &#123;</span><br><span class="line">                isVisited[j] = <span class="literal">true</span></span><br><span class="line">                result = <span class="built_in">append</span>(result, strconv.Itoa(j+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            cnt--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strings.Join(result, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>康托展开</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和</title>
    <url>/2020/08/24/CombinationSum/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-39"><a href="#题目-LeetCode-39" class="headerlink" title="题目(LeetCode #39)"></a>题目(<a href="https://leetcode-cn.com/problems/combination-sum/">LeetCode #39</a>)</h2><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的数字可以无限制重复被选取。</p>
<p><strong>说明：</strong></p>
<ul>
<li>  所有数字（包括 target）都是正整数。</li>
<li>  解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong> candidates = [2, 3, 6, 7], target = 7,</p>
<p><strong>所求解集为：</strong><br>[<br>&emsp;&emsp;[7],<br>&emsp;&emsp;[2,2,3]<br>]</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong> candidates = [2,3,5], target = 8,</p>
<p><strong>所求解集为：</strong><br>[<br>&emsp;&emsp;[2, 2, 2, 2],<br>&emsp;&emsp;[2, 3, 3],<br>&emsp;&emsp;[3, 5]<br>]</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>  1 &lt;= candidates.length &lt;= 30</li>
<li>  1 &lt;= candidates[i] &lt;= 200</li>
<li>  candidate 中的每个元素都是独一无二的。</li>
<li>  1 &lt;= target &lt;= 500</li>
</ul>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">参考题解</a></p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p><strong>回溯法</strong>（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>本题为回溯法经典例题，以 <code>candidates = [2, 3, 6, 7]</code> ，<code> target = 7</code> 为例，可用 <code>target</code> 减去 <code>candidates</code> 中的元素，得到新的 <code>target</code> ，再减去 <code>candidates</code> 中的元素，多次相减，若在某次迭代中 <code>target</code> 变为 0，则减数的集合即为一个解；若 <code>target</code> 小于 0 则回退至上一步继续寻找下一个解。如下图所示，其中绿色叶节点所在的路径即为一解。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200825174143.png"></p>
<p>以上算法实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrLen</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        <span class="keyword">if</span> (arrLen == <span class="number">0</span>) <span class="keyword">return</span> results;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, arrLen, target, path);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> begin, <span class="type">int</span> arrLen, <span class="type">int</span> target, Deque&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            results.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates, i, arrLen, target - candidates[i], path);</span><br><span class="line">            <span class="comment">// 回溯，移除路径的最后一段，相当于回到了上一层。</span></span><br><span class="line">            <span class="comment">// 如路径[2, 2, 2, 2]，上一行 dfs 递归遇到 target &lt; 0，返回。</span></span><br><span class="line">            <span class="comment">// 移除路径最后一段 2，即返回了上一层的 1，继续计算 candidates[i] = 3 的情况。</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> ]</span><br><span class="line">[ <span class="number">2</span> <span class="number">3</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">7</span> ]</span><br></pre></td></tr></table></figure>

<p>可以看到出现了重复解，这是由于每次计算下一层的 <code>target</code> 时均考虑了 <code>candidates</code> 的所有情况。若要避免这种重复，可在每个分支上排除之前已计算过的 <code>candidates</code> 值，如在 <code>7 - 2 = 5</code> 分支上已考虑了所有 <code>candidates[i] = 2</code> 的情况，在 <code>7 - 3/6/7</code> 三个分支上无需重复考虑。去重后树结构如下：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200825174354.png"></p>
<p>实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrLen</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        <span class="keyword">if</span> (arrLen == <span class="number">0</span>) <span class="keyword">return</span> results;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, arrLen, target, path);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> begin, <span class="type">int</span> arrLen, <span class="type">int</span> target, Deque&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            results.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对 candidates 的循环改为从 begin 位置开始</span></span><br><span class="line">        <span class="comment">// 如遍历到 i = 1 时，后续遍历时也会跳过 i = 0 位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; arrLen; i++) &#123;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates, i, arrLen, target - candidates[i], path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时输出即为无重复的解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> ]</span><br><span class="line">[ <span class="number">7</span> ]</span><br></pre></td></tr></table></figure>

<h4 id="剪枝提速"><a href="#剪枝提速" class="headerlink" title="剪枝提速"></a>剪枝提速</h4><p>在计算过程中，若 <code>target</code> 减去某个 <code>candidates[i]</code> 后小于 0，则大于该 <code>candidates[i]</code> 的值与 <code>target</code> 的差也必然小于 0。故可先对 <code>candidates</code> 数组进行升序排序，在遍历 <code>candidates</code> 数组的过程中，若 <code>target &lt; candidates[i]</code> 则 <code>i + 1</code> 及其之后的位置也无需考虑。</p>
<p><strong>注意：</strong> 采用这种剪枝方法必须先将 <code>candidates</code> 数组排序，否则若大于 <code>target</code> 的数排在前时，会提前触发 break，导致后边小于 <code>target</code> 的元素被跳过。</p>
<p>剪枝后的树如下，可以看到已减少了很多分支：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200825195757.png"></p>
<p>实现如下</p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, len, target, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> begin, <span class="type">int</span> len, <span class="type">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; candidates[i]) <span class="keyword">break</span>;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates, i, len, target - candidates[i], path, result);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.path = []</span><br><span class="line">        self.results = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="built_in">list</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        arr_len = <span class="built_in">len</span>(candidates)</span><br><span class="line">        <span class="keyword">if</span> arr_len == <span class="number">0</span>: <span class="keyword">return</span> self.results</span><br><span class="line"></span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.dfs(candidates, <span class="number">0</span>, arr_len, target)</span><br><span class="line">        <span class="keyword">return</span> self.results</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, candidates: <span class="built_in">list</span>, begin: <span class="built_in">int</span>, arr_len: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            self.results.append(self.path[:]) <span class="comment"># 此处注意需要深拷贝</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(begin, arr_len):</span><br><span class="line">            <span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>): <span class="keyword">break</span></span><br><span class="line">            self.path.append(candidates[i])</span><br><span class="line">            self.dfs(candidates, i, arr_len, target - candidates[i])</span><br><span class="line">            self.path.pop()</span><br></pre></td></tr></table></figure>

<h5 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	arrLen := <span class="built_in">len</span>(candidates)</span><br><span class="line">	<span class="keyword">var</span> results [][]<span class="type">int</span></span><br><span class="line">	<span class="keyword">if</span> arrLen == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> results</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line">	sort.Ints(candidates)</span><br><span class="line">	dfs(candidates, <span class="number">0</span>, arrLen, target, &amp;results, path)</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(candidates []<span class="type">int</span>, begin, arrLen, target <span class="type">int</span>, results *[][]<span class="type">int</span>, path []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">		*results = <span class="built_in">append</span>(*results, path[:]) <span class="comment">// 深拷贝</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := begin; i &lt; arrLen; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> target - candidates[i] &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">		dfs(candidates, i, arrLen, target - candidates[i], results, path)</span><br><span class="line">		path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进阶-LeetCode-40"><a href="#进阶-LeetCode-40" class="headerlink" title="进阶(LeetCode #40)"></a>进阶(<a href="https://leetcode-cn.com/problems/combination-sum-ii/">LeetCode #40</a>)</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/">参考题解</a></p>
<p>给定一个数组 <code>candidates</code> 和一个目标数<code> target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<p><strong>说明：</strong></p>
<ul>
<li>  所有数字（包括目标数）都是正整数。</li>
<li>  解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong> candidates = [10, 1, 2, 7, 6, 1, 5], target = 8,</p>
<p><strong>所求解集为：</strong><br>[<br>&emsp;&emsp;[1, 7],<br>&emsp;&emsp;[1, 2, 5],<br>&emsp;&emsp;[2, 6],<br>&emsp;&emsp;[1, 1, 6]<br>]</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong>  candidates = [2, 5, 2, 1, 2], target = 5,</p>
<p><strong>所求解集为：</strong><br>[<br>&emsp;&emsp;[1, 2, 2],<br>&emsp;&emsp;[5]<br>]</p>
</blockquote>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>以 <code>candidates = [2, 5, 2, 1, 2]</code> ，<code>target = 5</code> 为例，若采用 #39 题中的算法，得到以下树结构（以 <code>2&#39;,2&#39;&#39;,2&#39;&#39;&#39;</code> 区分三个位置的 2）：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200826191716.png"></p>
<p>输出如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> ]</span><br><span class="line">[ <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">5</span> ]</span><br></pre></td></tr></table></figure>

<p>需修改算法使之满足以下两个条件：</p>
<ul>
<li>  每个数字在每个组合中只能使用一次</li>
<li>  解集不能包含重复的组合</li>
</ul>
<h4 id="限制组合中数字的出现次数"><a href="#限制组合中数字的出现次数" class="headerlink" title="限制组合中数字的出现次数"></a>限制组合中数字的出现次数</h4><p>在分支上遍历 <code>candidates</code> 时跳过已使用过的位置即可，此时树的结构如下：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200826192051.png"></p>
<p>实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须先排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, len, target, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> begin, <span class="type">int</span> len, <span class="type">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; candidates[i]) <span class="keyword">break</span>;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            <span class="comment">// 下一层 begin 从 i + 1 开始，跳过当前的 i</span></span><br><span class="line">            dfs(candidates, i + <span class="number">1</span>, len, target - candidates[i], path, result);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时输出为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">5</span> ]</span><br></pre></td></tr></table></figure>

<h4 id="去除重复组合"><a href="#去除重复组合" class="headerlink" title="去除重复组合"></a>去除重复组合</h4><p>从图中可知组合 <code>[1, 2&#39;, 2&#39;&#39;]</code> 、<code>[1, 2&#39;, 2&#39;&#39;&#39;]</code> 和 <code>[1, 2&#39;&#39;, 2&#39;&#39;&#39;]</code> 三者重复，要去除这种重复应跳过同一层级出现的相等元素。剪枝后的树结构如下：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200826193035.png"></p>
<p>最终输出为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> ]</span><br><span class="line">[ <span class="number">5</span> ]</span><br></pre></td></tr></table></figure>

<p>实现如下：</p>
<h5 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, len, target, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> begin, <span class="type">int</span> len, <span class="type">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; candidates[i]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 跳过同一层的相等元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; begin &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates, i + <span class="number">1</span>, len, target - candidates[i], path, result);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.path = []</span><br><span class="line">        self.results = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates: <span class="built_in">list</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        arr_len = <span class="built_in">len</span>(candidates)</span><br><span class="line">        <span class="keyword">if</span> arr_len == <span class="number">0</span>: <span class="keyword">return</span> self.results</span><br><span class="line"></span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.dfs(candidates, <span class="number">0</span>, arr_len, target)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.results</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, candidates: <span class="built_in">list</span>, begin: <span class="built_in">int</span>, arr_len: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            self.results.append(self.path[:]) <span class="comment"># 注意此处 path 需要深拷贝</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(begin, arr_len):</span><br><span class="line">            <span class="keyword">if</span> target - candidates[i] &lt; <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; begin <span class="keyword">and</span> candidates[i] == candidates[i - <span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">            self.path.append(candidates[i])</span><br><span class="line">            self.dfs(candidates, i + <span class="number">1</span>, arr_len, target - candidates[i])</span><br><span class="line">            self.path.pop()</span><br></pre></td></tr></table></figure>

<h5 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum2</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	arrLen := <span class="built_in">len</span>(candidates)</span><br><span class="line">	<span class="keyword">var</span> results [][]<span class="type">int</span></span><br><span class="line">	<span class="keyword">if</span> arrLen == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> results</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line">	sort.Ints(candidates)</span><br><span class="line">	dfs(candidates, <span class="number">0</span>, arrLen, target, &amp;results, path)</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(candidates []<span class="type">int</span>, begin, arrLen, target <span class="type">int</span>, results *[][]<span class="type">int</span>, path []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">		*results = <span class="built_in">append</span>(*results, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, path...))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := begin; i &lt; arrLen; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> target &lt; candidates[i] &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i &gt; begin &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">		dfs(candidates, i+<span class="number">1</span>, arrLen, target-candidates[i], results, path)</span><br><span class="line">		path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复制带随机指针的链表</title>
    <url>/2020/03/07/CopyRandomList/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-138"><a href="#题目-LeetCode-138" class="headerlink" title="题目 LeetCode # 138"></a>题目 <a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">LeetCode # 138</a></h2><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>
<p>要求返回这个链表的 深拷贝。 </p>
<p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<ul>
<li>  <code>val</code> ：一个表示 <code>Node.val</code> 的整数。</li>
<li>  <code>random_index</code>：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</li>
</ul>
<p>示例 1：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200307094114.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：head = [[<span class="number">7</span>,null],[<span class="number">13</span>,<span class="number">0</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：[[<span class="number">7</span>,null],[<span class="number">13</span>,<span class="number">0</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200307094124.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：head = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200307094133.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：head = [[<span class="number">3</span>,null],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">3</span>,null]]</span><br><span class="line">输出：[[<span class="number">3</span>,null],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">3</span>,null]]</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>  -10000 &lt;= Node.val &lt;= 10000</li>
<li>  Node.random 为空（null）或指向链表中的节点。</li>
<li>  节点数目不超过 1000 。</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一-使用-HashMap"><a href="#方法一-使用-HashMap" class="headerlink" title="方法一: 使用 HashMap"></a>方法一: 使用 <code>HashMap</code></h3><p>通过使用 <code>HashMap</code> 来建立原结点与复制后结点之间的对应关系, 再遍历原链表建立新结点 <code>random</code> 指针的指向关系</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">    Node random;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.random = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tmp1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (tmp1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.put(tmp1, <span class="keyword">new</span> <span class="title class_">Node</span>(tmp1.val));</span><br><span class="line">            tmp1 = tmp1.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">tmp2</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (tmp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.get(tmp2).next = map.get(tmp2.next);</span><br><span class="line">            map.get(tmp2).random = map.get(tmp2.random);</span><br><span class="line">            tmp2 = tmp2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, <span class="built_in">next</span>=<span class="literal">None</span>, random=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = <span class="built_in">int</span>(x)</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        self.random = random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CopyList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">copy_random_list</span>(<span class="params">self, head</span>):</span><br><span class="line">        list_map = &#123;&#125;</span><br><span class="line">        tmp1 = head</span><br><span class="line">        <span class="keyword">while</span> tmp1:</span><br><span class="line">            list_map[tmp1] = Node(tmp1.val)</span><br><span class="line">            tmp1 = tmp1.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        tmp2 = head</span><br><span class="line">        <span class="keyword">while</span> tmp2:</span><br><span class="line">            list_map.get(tmp2).<span class="built_in">next</span> = list_map.get(tmp2.<span class="built_in">next</span>)</span><br><span class="line">            list_map.get(tmp2).random = list_map.get(tmp2.random)</span><br><span class="line">            tmp2 = tmp2.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list_map.get(head)</span><br></pre></td></tr></table></figure>

<h3 id="方法二-复制结点"><a href="#方法二-复制结点" class="headerlink" title="方法二: 复制结点"></a>方法二: 复制结点</h3><p>复制原链表结点 ( 如 <code>1-&gt;2-&gt;3</code> 复制为 <code>1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3</code> ), 再复制 <code>random</code> 指针的指向, 最后将新链表分离.</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_13_CopyList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 复制结点</span></span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="literal">null</span>) &#123;</span><br><span class="line">            newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(tmp.val);</span><br><span class="line">            newNode.next = tmp.next;</span><br><span class="line">            tmp.next = newNode;</span><br><span class="line">            tmp = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp = head;</span><br><span class="line">        <span class="comment">// 复制 random 指针</span></span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="literal">null</span>) &#123;</span><br><span class="line">            newNode = tmp.next;</span><br><span class="line">            newNode.random = tmp.random != <span class="literal">null</span> ? tmp.random.next : <span class="literal">null</span>;</span><br><span class="line">            tmp = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp = head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">result</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">// 分离新链表, 复原原链表</span></span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = tmp.next.next;</span><br><span class="line">            newNode = tmp.next;</span><br><span class="line">            tmp.next = next;</span><br><span class="line">            newNode.next = next != <span class="literal">null</span> ? next.next : <span class="literal">null</span>;</span><br><span class="line">            tmp = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, <span class="built_in">next</span>=<span class="literal">None</span>, random=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = <span class="built_in">int</span>(x)</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        self.random = random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CopyList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">copy_random_list</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        tmp = head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            new_node = Node(tmp.val)</span><br><span class="line">            new_node.<span class="built_in">next</span> = tmp.<span class="built_in">next</span></span><br><span class="line">            tmp.<span class="built_in">next</span> = new_node</span><br><span class="line">            tmp = new_node.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        tmp = head</span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            new_node = tmp.<span class="built_in">next</span></span><br><span class="line">            new_node.random = tmp.random.<span class="built_in">next</span> <span class="keyword">if</span> tmp.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            tmp = new_node.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        tmp = head</span><br><span class="line">        result = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> tmp:</span><br><span class="line">            <span class="built_in">next</span> = tmp.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            new_node = tmp.<span class="built_in">next</span></span><br><span class="line">            tmp.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">            new_node.<span class="built_in">next</span> = <span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">if</span> <span class="built_in">next</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            tmp = <span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列的矩阵求法</title>
    <url>/2020/07/04/CowNumber/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>母牛每年生一头母牛, 新出生的母牛成长三年后也能每年生一头母牛, 假设牛不会死. 求 <code>N</code> 年后母牛的数量</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>归纳得 <code>F(N) = F(N-1) + F(N-3)</code></p>
<p>该式实际上可解释为每年牛的总数等于前一年牛的总数 <code>F(N-1)</code> 加上三年前牛的总数 <code>F(N-3)</code> , 其中 <code>F(N-3)</code> 即为每年新增的牛的数量. </p>
<p>若规定牛的寿命为 10 年, 减去 <code>F(N-10)</code> 即可</p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CowNumber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCowNum</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">2</span>) <span class="keyword">return</span> N + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getCowNum(N - <span class="number">1</span>) + getCowNum(N - <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getCowNum(<span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_cow_number</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_cow_number(n - <span class="number">1</span>) + get_cow_number(n - <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h5 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCowNum</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> getCowNum(n<span class="number">-1</span>) + getCowNum(n<span class="number">-3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="斐波那契数列的矩阵求法"><a href="#斐波那契数列的矩阵求法" class="headerlink" title="斐波那契数列的矩阵求法"></a>斐波那契数列的矩阵求法</h4><p>以上算法的时间复杂度为 <code>O(N²)</code> 本题可参考<a href="https://www.geeksforgeeks.org/matrix-exponentiation/">斐波那契数列的矩阵求法</a>, 该算法时间复杂度仅为 <code>O(logN)</code></p>
<p>推导如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(n) = a*F(n-1) + b*F(n-2) + c*F(n-3)</span><br><span class="line">F(n-1) = F(n-1)</span><br><span class="line">F(n-2) = F(n-2)</span><br></pre></td></tr></table></figure>

<p>本题中 a = 1, b = 0, c = 1</p>
<p>故可得</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200705153235.png"></p>
<h5 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib_matrix</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">    result = np.mat([</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    ], dtype=<span class="string">&#x27;float64&#x27;</span>) ** (n - <span class="number">2</span>) * np.mat([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]).T</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(result[<span class="number">0</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>原地哈希</title>
    <url>/2020/08/27/CuckooHash/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>将数组视为哈希表，哈希函数为数组元素与数组索引之间的映射。</p>
<h2 id="例题-1-剑指-offer-03"><a href="#例题-1-剑指-offer-03" class="headerlink" title="例题 1(剑指 offer #03)"></a>例题 1(<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">剑指 offer #03</a>)</h2><p>找出数组中重复的数字。</p>
<p>在一个长度为 <code>n</code> 的数组 <code>nums</code> 里的所有数字都在<code> 0～n-1</code> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1：</p>
<blockquote>
<p><strong>输入：</strong><br>&emsp;[2, 3, 1, 0, 2, 5, 3]<br><strong>输出：</strong> 2 或 3 </p>
</blockquote>
<p>限制：</p>
<p><code>2 &lt;= n &lt;= 100000</code></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将数组中各元素放至与与元素值相等的索引处（即将数组视为哈希表，哈希函数为 <code>f(nums[i]) = nums[i]</code>），在交换过程中若发现目标位置已有满足条件的值则说明遇到了重复：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200828110958.png"></p>
<p>当遍历至 4 位置处的 2 时发现目标位置已有 2，说明 2 发生了重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = nums[i];</span><br><span class="line">            nums[i] = nums[tmp];</span><br><span class="line">            nums[tmp] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题-2-LeetCode-41"><a href="#例题-2-LeetCode-41" class="headerlink" title="例题 2 (LeetCode #41)"></a>例题 2 (<a href="https://leetcode-cn.com/problems/first-missing-positive/">LeetCode #41</a>)</h2><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: [1, 2, 0]<br>输出: 3</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入: [3, 4, -1, 1]<br>输出: 2</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p>输入: [7, 8, 9, 11, 12]<br>输出: 1</p>
</blockquote>
<p><strong>提示：</strong></p>
<p>你的算法的时间复杂度应为 <code>O(n)</code> ，并且只能使用常数级别的额外空间。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>本题难在限制了时间复杂度为 <code>O(n)</code> 且<strong>常数级别</strong>的额外空间，利用排序算法时间复杂度最低为 <code>O(logn)</code> ，不符合条件。</p>
<p>由题意可知，输出的范围为 <code>[1, n + 1]</code> ，将数组视为哈希函数为 <code>f(nums[i]) = nums[i] - 1</code> 的哈希表将数组重新排布。再遍历数组并判断各元素是否满足 <code>nums[i] == i + 1</code> 的对应关系，若不满足则数组中未出现的最小整数为 <code>i + 1</code> ，若数组中元素全部满足条件则最小整数即为数组长度加 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= <span class="number">0</span> &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>])</span><br><span class="line">                swap(i, nums[i] - <span class="number">1</span>, nums);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先遍历</title>
    <url>/2020/06/21/DFS/</url>
    <content><![CDATA[<p>借助栈和集合实现树和图的深度优先遍历, 每次从栈中取出一个节点 <code>A</code> , 遍历与节点 <code>A</code> 相邻的后续节点 <code>Bn</code> , 若集合中没有该后续 <code>Bn</code> 则将节点 <code>A</code> 放回栈中, 并将后续节点 <code>Bn</code> 放入栈和集合中, 输出后续节点 <code>Bn</code> . 每遍历完一个后续节点就跳出当前循环, 避免出现横向遍历 ( 如下图, 可能会产生 2, 3, 4 的错误输出 ).</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200620202932.png"></p>
<p>以上图为例, 图的节点定义及整体结构见<a href="https://zcybupt.github.io/post/Graph/">上一篇博客</a></p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DFS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(GraphNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Stack&lt;GraphNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;GraphNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        stack.push(node);</span><br><span class="line">        set.add(node);</span><br><span class="line">        System.out.print(node.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">GraphNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">for</span> (GraphNode next : cur.nexts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                    stack.push(cur);</span><br><span class="line">                    stack.push(next);</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    System.out.print(next.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[][] nodes = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> GraphBuilder.createGraph(nodes);</span><br><span class="line">        dfs(graph.nodes.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">4</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    ele_stack = []</span><br><span class="line">    ele_set = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    ele_stack.append(node)</span><br><span class="line">    ele_set.add(node)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(node.value, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> ele_stack:</span><br><span class="line">        current_node = ele_stack.pop()</span><br><span class="line">        <span class="keyword">for</span> next_node <span class="keyword">in</span> current_node.nexts:</span><br><span class="line">            <span class="keyword">if</span> next_node <span class="keyword">not</span> <span class="keyword">in</span> ele_set:</span><br><span class="line">                ele_stack.append(current_node)</span><br><span class="line">                ele_stack.append(next_node)</span><br><span class="line">                ele_set.add(next_node)</span><br><span class="line">                <span class="built_in">print</span>(next_node.value, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>有序数组查找元素的起止范围</title>
    <url>/2020/08/21/FindFirstAndLastPositionOfElementInSortedArray/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-34"><a href="#题目-LeetCode-34" class="headerlink" title="题目(LeetCode #34)"></a>题目(<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LeetCode #34</a>)</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p>
<p><strong>示例1：</strong></p>
<blockquote>
<p><strong>输入:</strong> nums = [5,7,7,8,8,10], target = 8<br><strong>输出:</strong> [3,4]</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p><strong>输入:</strong> nums = [5,7,7,8,8,10], target = 6<br><strong>输出:</strong> [-1, -1]</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>先进行二分查找找到目标值 <code>target</code> ，再从两侧逐位逼近 <code>mid</code> ，判断是否与 <code>target</code> 相等即可找到开始合结束位置。</p>
<p>查找阶段时间复杂度为 <code>O(logn)</code> ，但在查找首尾时若输入数组全部为 <code>target</code> ，如 <code>[8, 8, 8, 8 , 8]</code> ，则将退化至 <code>O(n)</code> 。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrLen</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arrLen - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">while</span> (nums[left] != target) left++;</span><br><span class="line">                <span class="keyword">while</span> (nums[right] != target) right--;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="built_in">list</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>: <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        arr_len = <span class="built_in">len</span>(nums)</span><br><span class="line">        left , right = <span class="number">0</span>, arr_len - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">while</span> nums[left] != target: left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> nums[right] != target: right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> [left, right]</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target: left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    arrLen := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> arrLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left, right := <span class="number">0</span>, arrLen - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">for</span> nums[left] != target &#123;</span><br><span class="line">                left++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> nums[right] != target &#123;</span><br><span class="line">                right--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;left, right&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>在方法一的基础上，在查找首尾时也采用二分查找，时间复杂度整体为 <code>O(logn)</code> 。</p>
<p>与一般的二分法查找相等位置不同，查找起始位置的终止条件为：前一个元素与当前元素不相等；查找终止位置的结束条件为：后一个元素与当前元素不相等。</p>
<p>以输入 <code>nums = [1, 2, 3, 3, 3, 3, 3, 3, 4]</code> 和 <code>target = 3</code> ，查找目标值的开始位置为例。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200822184455.png"></p>
<p>首先根据二分法找到与 <code>target</code> 相等的位置，在此即为 <code>4</code> 。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200822184746.png"></p>
<p>由于有 <code>nums[mid] == nums[mid - 1]</code> ，将 <code>right</code> 指向 <code>mid - 1</code> 。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200822185022.png"></p>
<p>重新计算 <code>mid</code> 为 <code>3 // 2 = 1</code> 。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200822185216.png"></p>
<p>此时有 <code>nums[mid] &lt; target</code> ，将 <code>left</code> 指向 <code>mid + 1</code> 。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200822185418.png"></p>
<p>重新计算 <code>mid</code> 为 2，此时 <code>nums[mid] != nums[mid - 1]</code> ，返回 <code>mid</code> 当前值即为目标值的开始位置。</p>
<p>查找 <code>target</code> 的结束位置与上述过程类似，不再赘述。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;</span><br><span class="line">            binarySearch(nums, target, <span class="literal">true</span>),</span><br><span class="line">            binarySearch(nums, target, <span class="literal">false</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">boolean</span> isSearchFirst)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrLen</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (arrLen == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arrLen - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSearchFirst) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mid &gt; <span class="number">0</span> &amp;&amp; nums[mid] == nums[mid - <span class="number">1</span>]) right = mid - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mid &lt; arrLen - <span class="number">1</span> &amp;&amp; nums[mid] == nums[mid + <span class="number">1</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="built_in">list</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>: <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            self.binary_search(nums, target, <span class="literal">True</span>),</span><br><span class="line">            self.binary_search(nums, target, <span class="literal">False</span>)</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">self, nums: <span class="built_in">list</span>, target: <span class="built_in">int</span>, is_search_first: <span class="built_in">bool</span></span>):</span><br><span class="line">        arr_len = <span class="built_in">len</span>(nums)</span><br><span class="line">        left, right = <span class="number">0</span>, arr_len - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target: right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target: left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> is_search_first:</span><br><span class="line">                    <span class="keyword">if</span> mid &gt; <span class="number">0</span> <span class="keyword">and</span> nums[mid] == nums[mid - <span class="number">1</span>]: right = mid - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>: <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> mid &lt; arr_len - <span class="number">1</span> <span class="keyword">and</span> nums[mid] == nums[mid + <span class="number">1</span>]: left = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>: <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span> &#123;</span><br><span class="line">        binarySearch(nums, target, <span class="literal">true</span>),</span><br><span class="line">        binarySearch(nums, target, <span class="literal">false</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>, isSearchFirst <span class="type">bool</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    arrLen := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> arrLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    left, right := <span class="number">0</span>, arrLen - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> isSearchFirst &#123;</span><br><span class="line">                <span class="keyword">if</span> mid &gt; <span class="number">0</span> &amp;&amp; nums[mid] == nums[mid - <span class="number">1</span>] &#123;</span><br><span class="line">                    right = mid <span class="number">-1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> mid &lt; arrLen - <span class="number">1</span> &amp;&amp; nums[mid] == nums[mid + <span class="number">1</span>] &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找峰值</title>
    <url>/2020/06/15/FindPeakElement/</url>
    <content><![CDATA[<h3 id="寻找峰值元素-LeetCode-162"><a href="#寻找峰值元素-LeetCode-162" class="headerlink" title="寻找峰值元素 (LeetCode #162)"></a>寻找峰值元素 (<a href="https://leetcode-cn.com/problems/find-peak-element/">LeetCode #162</a>)</h3><p>给定一个输入数组 <code>nums</code> ，其中 <code>nums[i] ≠ nums[i+1]</code> ，找到峰值元素并返回其索引。</p>
<p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p>
<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p>
<p>示例 1:</p>
<blockquote>
<p>  输入: nums = [1,2,3,1]<br>  输出: 2<br>  解释: 3 是峰值元素，你的函数应该返回其索引 2。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>  输入: nums = [1,2,1,3,5,6,4]<br>  输出: 1 或 5<br>  解释: 你的函数可以返回索引 1，其峰值元素为 2；<br>       或者返回索引 5， 其峰值元素为 6。</p>
</blockquote>
<p>说明: </p>
<p>解法应该是 O(logN) 时间复杂度的.</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>本题采用二分法, 假定最后一个元素的索引为 <code>N</code>, 首先判断 <code>0</code> 和 <code>1</code> 位置元素, <code>N</code> 和 <code>N-1</code> 位置元素的大小关系, 若 <code>num[0] &gt; num[1]</code> 或 <code>num[N] &gt; num[N-1]</code> , 则返回 <code>0</code> 或 <code>N</code> 即可. 若前两个条件均不满足则 <code>0</code> 和 <code>N</code> 之间必有峰值, 取中间元素 <code>num[mid]</code> , 若该元素也不是峰值, 则继续二分. 若 <code>num[mid]</code> &lt; <code>num[mid-1]</code> , 则峰值必在 <code>0</code> 和 <code>mid</code> 之间, 反之则在 <code>mid</code> 与 <code>N</code> 之间.</p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindPeakElement</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) right = mid;	<span class="comment">// 左边高, 峰值在左, 可能是 mid</span></span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>; <span class="comment">// 右边高, 峰值在右, 包含 mid + 1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FindPeakElement</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPeakElement</span>(<span class="params">self, nums</span>):</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        mid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right):</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[mid + <span class="number">1</span>]: right = mid</span><br><span class="line">        	<span class="keyword">else</span>: left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树结点的中序后继</title>
    <url>/2020/06/14/FindSuccessor/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉树和其中的一个结点, 求该结点的中序遍历后继, 结点定义如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    Node parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>结点的中序后继有以下几种情况:</p>
<ul>
<li>  结点有右子树: 该节点的中序后继即为其右子树最左的结点, 如头图中 1 的后继即为 6</li>
<li>  结点没有右子树: 则需一直向上查找, 直到某个结点为其父结点的左子树为止, 其后继即为该父节点, 如 5 的后继为 1; 若无满足条件的结点则返回 null, 如 7 无后继</li>
</ul>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindSuccessor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">findSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getLeftMost(node.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> node.parent;</span><br><span class="line">            <span class="keyword">while</span> (parent != <span class="literal">null</span> &amp;&amp; parent.left != node) &#123;</span><br><span class="line">                node = parent;</span><br><span class="line">                parent = node.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getLeftMost</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FindSuccessor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_successor</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> self.get_left_most(node.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            parent = node.parent</span><br><span class="line">            <span class="keyword">while</span> parent <span class="keyword">and</span> parent.left != node:</span><br><span class="line">                node = parent</span><br><span class="line">                parent = node.parent</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> parent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_left_most</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">while</span> node.left:</span><br><span class="line">                node = node.left</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个唯一数字</title>
    <url>/2022/01/16/FirstUniqueNumber/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-1429"><a href="#题目-LeetCode-1429" class="headerlink" title="题目(LeetCode #1429)"></a>题目(LeetCode #1429)</h2><p>You have a queue of integers, you need to retrieve the first unique integer in the queue.</p>
<p>Implement the <code>FirstUnique</code> class:</p>
<ul>
<li><code>FirstUnique(int[] nums)</code> Initializes the object with the numbers in the queue.</li>
<li><code>int showFirstUnique()</code> returns the value of <strong>the first unique</strong> integer of the queue, and returns <strong>-1</strong> if there is no such integer.</li>
<li><code>void add(int value)</code> insert value to the queue.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[<span class="string">&quot;FirstUnique&quot;</span>,<span class="string">&quot;showFirstUnique&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;showFirstUnique&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;showFirstUnique&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;showFirstUnique&quot;</span>]</span><br><span class="line">[[[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]],[],[<span class="number">5</span>],[],[<span class="number">2</span>],[],[<span class="number">3</span>],[]]</span><br><span class="line">Output: [null,<span class="number">2</span>,null,<span class="number">2</span>,null,<span class="number">3</span>,null,-<span class="number">1</span>] </span><br><span class="line">Explanation:</span><br><span class="line">FirstUnique firstUnique = new FirstUnique([<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]);</span><br><span class="line">firstUnique.showFirstUnique(); // <span class="keyword">return</span> <span class="number">2</span> </span><br><span class="line">firstUnique.add(<span class="number">5</span>);            // the queue <span class="keyword">is</span> now [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>] </span><br><span class="line">firstUnique.showFirstUnique(); // <span class="keyword">return</span> <span class="number">2</span> </span><br><span class="line">firstUnique.add(<span class="number">2</span>);            // the queue <span class="keyword">is</span> now [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>] </span><br><span class="line">firstUnique.showFirstUnique(); // <span class="keyword">return</span> <span class="number">3</span> </span><br><span class="line">firstUnique.add(<span class="number">3</span>);            // the queue <span class="keyword">is</span> now [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>] </span><br><span class="line">firstUnique.showFirstUnique(); // <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[<span class="string">&quot;FirstUnique&quot;</span>,<span class="string">&quot;showFirstUnique&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;showFirstUnique&quot;</span>]</span><br><span class="line">[[[<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>]],[],[<span class="number">7</span>],[<span class="number">3</span>],[<span class="number">3</span>],[<span class="number">7</span>],[<span class="number">17</span>],[]]</span><br><span class="line">Output: </span><br><span class="line">[null,-<span class="number">1</span>,null,null,null,null,null,<span class="number">17</span>]</span><br><span class="line">Explanation: </span><br><span class="line">FirstUnique firstUnique = new FirstUnique([<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>]); </span><br><span class="line">firstUnique.showFirstUnique(); // <span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">firstUnique.add(<span class="number">7</span>);            // the queue <span class="keyword">is</span> now [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>] </span><br><span class="line">firstUnique.add(<span class="number">3</span>);            // the queue <span class="keyword">is</span> now [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">3</span>] </span><br><span class="line">firstUnique.add(<span class="number">3</span>);            // the queue <span class="keyword">is</span> now [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">3</span>] </span><br><span class="line">firstUnique.add(<span class="number">7</span>);            // the queue <span class="keyword">is</span> now [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">7</span>] </span><br><span class="line">firstUnique.add(<span class="number">17</span>);           // the queue <span class="keyword">is</span> now [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">17</span>] </span><br><span class="line">firstUnique.showFirstUnique(); // <span class="keyword">return</span> <span class="number">17</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[<span class="string">&quot;FirstUnique&quot;</span>,<span class="string">&quot;showFirstUnique&quot;</span>,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;showFirstUnique&quot;</span>]</span><br><span class="line">[[[<span class="number">809</span>]],[],[<span class="number">809</span>],[]]</span><br><span class="line">Output: </span><br><span class="line">[null,<span class="number">809</span>,null,-<span class="number">1</span>] </span><br><span class="line">Explanation:</span><br><span class="line">FirstUnique firstUnique = new FirstUnique([<span class="number">809</span>]); </span><br><span class="line">firstUnique.showFirstUnique(); // <span class="keyword">return</span> <span class="number">809</span> </span><br><span class="line">firstUnique.add(<span class="number">809</span>);          // the queue <span class="keyword">is</span> now [<span class="number">809</span>,<span class="number">809</span>] </span><br><span class="line">firstUnique.showFirstUnique(); // <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>方法一：</strong>可以使用队列保存输入的所有数字，并创建一个 Map 来保存各数字的出现次数，执行 <code>add</code> 时直接将新元素添加至队尾；执行 <code>firstUnique</code> 时从队首逐个判断是否唯一，若不唯一则弹出该元素，直到找到第一个唯一的元素为止。这种方法时间和空间复杂度都是 <code>O(n)</code>，可能需要弹出很多元素才能找到结果。</p>
<p><strong>方法二：</strong>创建一个队列保存输入的数字，并使用一个 Set 保存所有数字，添加元素时先判断该数字是否已经出现过，若出现过则从队列中移除该元素。时间和空间复杂度仍都为 <code>O(n)</code>，<code>firstUnique</code> 操作的时间复杂度降为 <code>O(1)</code>，但 <code>add</code> 操作最坏情况下仍为 <code>O(n)</code>。该解法中的队列可改用 <code>LinkedHashSet</code>，进一步降低 <code>add</code> 时移除重复元素的复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstUnique</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; unique = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; all = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FirstUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (all.add(num)) unique.add(num);</span><br><span class="line">        <span class="keyword">else</span> unique.remove(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">showFirstUnique</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unique.isEmpty() ? -<span class="number">1</span> : unique.iterator().next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>队列</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>折纸问题</title>
    <url>/2020/06/12/FoldPaper/</url>
    <content><![CDATA[<h3 id="题目-牛客网"><a href="#题目-牛客网" class="headerlink" title="题目 (牛客网)"></a>题目 (<a href="https://www.nowcoder.com/practice/430180b66a7547e1963b69b1d0efbd3c">牛客网</a>)</h3><p>请把纸条竖着放在桌⼦上，然后从纸条的下边向上⽅对折，压出折痕后再展 开。此时有1条折痕，突起的⽅向指向纸条的背⾯，这条折痕叫做“下”折痕 ；突起的⽅向指向纸条正⾯的折痕叫做“上”折痕。如果每次都从下边向上⽅ 对折，对折N次。请从上到下计算出所有折痕的⽅向。</p>
<p>给定折的次数<strong>n</strong>,请返回从上到下的折痕的数组，若为下折痕则对应元素为”down”,若为上折痕则为”up”.</p>
<p>测试样例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回: [&quot;down&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200613150110.png"></p>
<p>该题可看作一棵二叉树, 树的头结点为 down, 所有左子树的头结点都为 down, 所有右子树的头结点都为 up, 最终从上到下的折痕顺序为该二叉树的中序遍历结果.</p>
<p>因左右子树的头结点分别为 down 或 up, 故可用 down 的布尔值代替左右, 省去创建节点的空间. 以下实现最大空间复杂度为树的高度, 即折叠次数.</p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoldPaper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printAllFolds</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        printProcess(<span class="number">1</span>, N, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printProcess</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> N, <span class="type">boolean</span> down)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; N)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        printProcess(i + <span class="number">1</span>, N, <span class="literal">true</span>);</span><br><span class="line">        System.out.print(down ? <span class="string">&quot;down &quot;</span> : <span class="string">&quot;up &quot;</span>);</span><br><span class="line">        printProcess(i + <span class="number">1</span>, N, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_all_folds</span>(<span class="params">N</span>):</span><br><span class="line">    print_process(<span class="number">1</span>, N, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_process</span>(<span class="params">i, N, down</span>):</span><br><span class="line">    <span class="keyword">if</span> i &gt; N: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    print_process(i + <span class="number">1</span>, N, <span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;down&quot;</span>, end=<span class="string">&quot; &quot;</span>) <span class="keyword">if</span> down <span class="keyword">else</span> <span class="built_in">print</span>(<span class="string">&quot;up&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    print_process(i + <span class="number">1</span>, N, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print_all_folds(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>Medium</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang堆的实现</title>
    <url>/2020/08/13/GoHeap/</url>
    <content><![CDATA[<h2 id="堆的使用"><a href="#堆的使用" class="headerlink" title="堆的使用"></a>堆的使用</h2><p>Golang 中没有给出堆的具体实现，仅提供了标准容器库 <code>container/heap</code> ，需手动实现。</p>
<p>heap 接口定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	sort.Interface</span><br><span class="line">	Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">	Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口同时继承了 <code>sort.Interface</code> ，定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">	Len() <span class="type">int</span></span><br><span class="line">	<span class="comment">// Less reports whether the element with</span></span><br><span class="line">	<span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">	Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">	<span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">	Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>故创建堆时需实现 <code>Len()</code> 、<code>Less(i, j int)</code> 、<code>Swap(i, j int)</code> 、<code>Push(x interface&#123;&#125;)</code> 、<code>Pop()</code> 五个方法。</p>
<p>向堆中插入节点时，堆会自动调整结构，Golang 中始终保持最后一个元素为堆顶，故 Pop 时返回<strong>最后一个节点</strong>并删除即可。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/heap&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonHeap []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ph PersonHeap)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(ph)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ph PersonHeap)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	ph[i], ph[j] = ph[j], ph[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ph PersonHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ph[i].Age &lt; ph[j].Age <span class="comment">// 大根堆</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ph *PersonHeap)</span></span> Push(p <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	*ph = <span class="built_in">append</span>(*ph, p.(Person))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ph *PersonHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(*ph)</span><br><span class="line">	result := (*ph)[n<span class="number">-1</span>]</span><br><span class="line">	*ph = (*ph)[:n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().Unix())</span><br><span class="line">	hp := &amp;PersonHeap&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">6</span>; i++ &#123;</span><br><span class="line">		*hp = <span class="built_in">append</span>(*hp, Person&#123;<span class="string">&quot;p&quot;</span> + strconv.Itoa(i), rand.Intn(<span class="number">50</span>)&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;原始切片: %#v\n&quot;</span>, hp)</span><br><span class="line"></span><br><span class="line">	heap.Init(hp)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;堆: %#v\n&quot;</span>, hp)</span><br><span class="line"></span><br><span class="line">	fmt.Println(hp.Pop())</span><br><span class="line">	heap.Push(hp, Person&#123;<span class="string">&quot;newP&quot;</span>, <span class="number">30</span>&#125;)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, hp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题-LeetCode-23"><a href="#例题-LeetCode-23" class="headerlink" title="例题(LeetCode #23)"></a>例题(<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">LeetCode #23</a>)</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:<br>[<br>&emsp;&emsp;1-&gt;4-&gt;5,<br>&emsp;&emsp;1-&gt;3-&gt;4,<br>&emsp;&emsp;2-&gt;6<br>]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/heap&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val  <span class="type">int</span></span><br><span class="line">	Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*ListNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(pq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pq[i].Val &lt; pq[j].Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	(*pq)[i].Val, (*pq)[j].Val = (*pq)[j].Val, (*pq)[i].Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	*pq = <span class="built_in">append</span>(*pq, x.(*ListNode))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	result := (*pq)[<span class="built_in">len</span>(*pq)<span class="number">-1</span>]</span><br><span class="line">	*pq = (*pq)[:<span class="built_in">len</span>(*pq)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">if</span> lists == <span class="literal">nil</span> || <span class="built_in">len</span>(lists) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dummyHead := &amp;ListNode&#123;<span class="number">0</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	curNode := dummyHead</span><br><span class="line">	<span class="keyword">var</span> pq PriorityQueue</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, list := <span class="keyword">range</span> lists &#123;</span><br><span class="line">		tmp := list</span><br><span class="line">		<span class="keyword">for</span> tmp != <span class="literal">nil</span> &#123;</span><br><span class="line">			heap.Push(&amp;pq, tmp)</span><br><span class="line">			tmp = tmp.Next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(pq) != <span class="number">0</span> &#123;</span><br><span class="line">		curNode.Next = heap.Pop(&amp;pq).(*ListNode)</span><br><span class="line">		curNode = curNode.Next</span><br><span class="line">	&#125;</span><br><span class="line">	curNode.Next = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dummyHead.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l1 := &amp;ListNode&#123;<span class="number">1</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	l1.Next = &amp;ListNode&#123;<span class="number">4</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	l1.Next.Next = &amp;ListNode&#123;<span class="number">5</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line">	l2 := &amp;ListNode&#123;<span class="number">1</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	l2.Next = &amp;ListNode&#123;<span class="number">3</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	l2.Next.Next = &amp;ListNode&#123;<span class="number">4</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line">	l3 := &amp;ListNode&#123;<span class="number">2</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	l3.Next = &amp;ListNode&#123;<span class="number">6</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line">	lists := []*ListNode&#123;l1, l2, l3&#125;</span><br><span class="line"></span><br><span class="line">	result := mergeKLists(lists)</span><br><span class="line">	<span class="keyword">for</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, result.Val)</span><br><span class="line">		result = result.Next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 自定义类型排序</title>
    <url>/2020/09/07/GoSortInterface/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-56"><a href="#题目-LeetCode-56" class="headerlink" title="题目(LeetCode #56)"></a>题目(<a href="https://leetcode-cn.com/problems/merge-intervals">LeetCode #56</a>)</h2><p>给出一个区间的集合，请合并所有重叠的区间。 </p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p><strong>输入:</strong> intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]<br><strong>输出:</strong> [[1, 6], [8, 10], [15, 18]]<br><strong>解释:</strong> 区间 [1, 3] 和 [2, 6] 重叠, 将它们合并为 [1, 6].</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p><strong>输入:</strong> intervals = [[1, 4], [4, 5]]<br><strong>输出:</strong> [[1, 5]]<br><strong>解释:</strong> 区间 [1, 4] 和 [4, 5] 可被视为重叠区间。</p>
</blockquote>
<p><strong>提示：</strong> <code>intervals[i][0] &lt;= intervals[i][1]</code></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul>
<li>  先按照每个区间的左端点进行排序，保证可以合并的区间是连续的。</li>
<li>遍历区间数组，判断结果集中最后一个区间的右端点与当前数组的左端点的关系：<ul>
<li>  若 <code>curInterval[0] &lt; mergedList[-1][1]</code> ，则区间无重合，直接将当前区间放入结果集即可</li>
<li>  若 <code>curInterval[0] &gt;= mergedList[-1][1]</code> ，则区间重合，需更新结果集中最后一个区间的右端点为 <code>max(curInterval[1], mergerdList[-1][1])</code></li>
</ul>
</li>
</ul>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> intervals == <span class="literal">nil</span> || <span class="built_in">len</span>(intervals) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> intervals</span><br><span class="line">	&#125;</span><br><span class="line">	quickSort(intervals, <span class="number">0</span>, <span class="built_in">len</span>(intervals)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result [][]<span class="type">int</span></span><br><span class="line">	result = <span class="built_in">append</span>(result, intervals[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">for</span> _, interval := <span class="keyword">range</span> intervals[<span class="number">1</span>:] &#123;</span><br><span class="line">		lastInterval := result[<span class="built_in">len</span>(result)<span class="number">-1</span>]</span><br><span class="line">		<span class="keyword">if</span> lastInterval[<span class="number">1</span>] &lt; interval[<span class="number">0</span>] &#123;</span><br><span class="line">			result = <span class="built_in">append</span>(result, interval)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			lastInterval[<span class="number">1</span>] = max(lastInterval[<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums [][]<span class="type">int</span>, L, R <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> L &lt; R &#123;</span><br><span class="line">		pIndex := partition(nums, L, R)</span><br><span class="line">		quickSort(nums, L, pIndex<span class="number">-1</span>)</span><br><span class="line">		quickSort(nums, pIndex+<span class="number">1</span>, R)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums [][]<span class="type">int</span>, L, R <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	P := nums[L]</span><br><span class="line">	<span class="keyword">for</span> L != R &#123;</span><br><span class="line">		<span class="keyword">for</span> L &lt; R &amp;&amp; nums[R][<span class="number">0</span>] &gt;= P[<span class="number">0</span>] &#123;</span><br><span class="line">			R--</span><br><span class="line">		&#125;</span><br><span class="line">		nums[L] = nums[R]</span><br><span class="line">		<span class="keyword">for</span> L &lt; R &amp;&amp; nums[L][<span class="number">0</span>] &lt;= P[<span class="number">0</span>] &#123;</span><br><span class="line">			L++</span><br><span class="line">		&#125;</span><br><span class="line">		nums[R] = nums[L]</span><br><span class="line">	&#125;</span><br><span class="line">	nums[L] = P</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> L</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Go-内置排序"><a href="#Go-内置排序" class="headerlink" title="Go 内置排序"></a>Go 内置排序</h3><p>调用 <code>sort</code> 包对自定义类型进行排序时，需实现其中的 <code>Less()</code> 、<code>Len()</code> 、<code>Swap()</code> 三个方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> intervals == <span class="literal">nil</span> || <span class="built_in">len</span>(intervals) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> intervals</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(intss(intervals))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result [][]<span class="type">int</span></span><br><span class="line">	result = <span class="built_in">append</span>(result, intervals[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">for</span> _, interval := <span class="keyword">range</span> intervals[<span class="number">1</span>:] &#123;</span><br><span class="line">		lastInterval := result[<span class="built_in">len</span>(result)<span class="number">-1</span>]</span><br><span class="line">		<span class="keyword">if</span> lastInterval[<span class="number">1</span>] &lt; interval[<span class="number">0</span>] &#123;</span><br><span class="line">			result = <span class="built_in">append</span>(result, interval)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			lastInterval[<span class="number">1</span>] = max(lastInterval[<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> intss [][]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s intss)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s intss)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s[i][<span class="number">0</span>] &lt; s[j][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s intss)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2020/06/20/Graph/</url>
    <content><![CDATA[<p>实际开发中常用二维矩阵表示图, 矩阵中的每一行即为一条边, 格式如 [权重, 起始点, 结束点]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>以上矩阵所表示的结构如下:</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200620172336.png"></p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;   <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">in</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 入度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">out</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 出度</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;GraphNode&gt; nexts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 当前点出发指向的所有相邻节点</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Edge&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();       <span class="comment">// 从当前点出发的所有边</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> GraphNode from;</span><br><span class="line">    <span class="keyword">public</span> GraphNode to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> weight, GraphNode from, GraphNode to)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.from = from;</span><br><span class="line">        <span class="built_in">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer, GraphNode&gt; nodes;   <span class="comment">// 所有点集, key 为节点编号</span></span><br><span class="line">    <span class="keyword">public</span> HashSet&lt;Edge&gt; edges;                 <span class="comment">// 所有边集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">()</span> &#123;</span><br><span class="line">        nodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Graph <span class="title function_">createGraph</span><span class="params">(Integer[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>();</span><br><span class="line">        <span class="keyword">for</span> (Integer[] node : matrix) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> node[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> node[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> node[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (!graph.nodes.containsKey(from)) &#123;</span><br><span class="line">                graph.nodes.put(from, <span class="keyword">new</span> <span class="title class_">GraphNode</span>(from));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!graph.nodes.containsKey(to)) &#123;</span><br><span class="line">                graph.nodes.put(to, <span class="keyword">new</span> <span class="title class_">GraphNode</span>(to));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">GraphNode</span> <span class="variable">fromNode</span> <span class="operator">=</span> graph.nodes.get(from);</span><br><span class="line">            <span class="type">GraphNode</span> <span class="variable">toNode</span> <span class="operator">=</span> graph.nodes.get(to);</span><br><span class="line">            <span class="type">Edge</span> <span class="variable">newEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Edge</span>(weight, fromNode, toNode);</span><br><span class="line">            fromNode.nexts.add(toNode);</span><br><span class="line">            fromNode.edges.add(newEdge);</span><br><span class="line">            fromNode.out++;</span><br><span class="line">            toNode.in++;</span><br><span class="line">            graph.edges.add(newEdge);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.in_degree = <span class="number">0</span></span><br><span class="line">        self.out_degree = <span class="number">0</span></span><br><span class="line">        self.nexts = []</span><br><span class="line">        self.edges = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, weight, from_node, to_node</span>):</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.from_node = from_node</span><br><span class="line">        self.to_node = to_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.nodes = <span class="built_in">dict</span>()</span><br><span class="line">        self.edges = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_graph</span>(<span class="params">matrix</span>):</span><br><span class="line">    graph = Graph()</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> matrix:</span><br><span class="line">        weight = node[<span class="number">0</span>]</span><br><span class="line">        from_val = node[<span class="number">1</span>]</span><br><span class="line">        to_val = node[<span class="number">2</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> from_val <span class="keyword">not</span> <span class="keyword">in</span> graph.nodes.keys():</span><br><span class="line">            graph.nodes[from_val] = GraphNode(from_val)</span><br><span class="line">        <span class="keyword">if</span> to_val <span class="keyword">not</span> <span class="keyword">in</span> graph.nodes.keys():</span><br><span class="line">            graph.nodes[to_val] = GraphNode(to_val)</span><br><span class="line">            </span><br><span class="line">        from_node = graph.nodes.get(from_val)</span><br><span class="line">        to_node = graph.nodes.get(to_val)</span><br><span class="line">        new_edge = Edge(weight, from_node, to_node)</span><br><span class="line">        </span><br><span class="line">        from_node.nexts.append(to_node)</span><br><span class="line">        from_node.edges.append(new_edge)</span><br><span class="line">        from_node.out_degree += <span class="number">1</span></span><br><span class="line">        to_node.in_degree += <span class="number">1</span></span><br><span class="line">        graph.edges.add(new_edge)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> graph</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔问题</title>
    <url>/2020/06/27/Hannoi/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>打印 <code>n</code> 层汉诺塔从最左边移动到最右边的全部过程</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>假定三根柱子分别为 <code>from</code> , <code>to</code> 和 <code>help</code> , 该问题可划分为 3 个步骤</p>
<ol>
<li> 将 <code>1~(n-1)</code> 从 <code>from</code> 移动到 <code>help</code> 上</li>
<li> 将 <code>n</code> 从 <code>from</code> 移动到 <code>to</code> 上</li>
<li> 将 <code>1~(n-1)</code> 从 <code>help</code> 移动到 <code>to</code> 上</li>
</ol>
<p>其中, 将 <code>1~(n-1)</code> 从 <code>help</code> 移动到 <code>to</code> 的过程又可分为多个子问题, 需不断调整三个柱子的角色.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hannoi</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hannoi</span><span class="params">(<span class="type">int</span> n, String from, String to, String help)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;move &quot;</span> + <span class="number">1</span> + <span class="string">&quot; from &quot;</span> + from + <span class="string">&quot; to &quot;</span> + to);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hannoi(n - <span class="number">1</span>, from, help, to);</span><br><span class="line">            System.out.println(<span class="string">&quot;move &quot;</span> + n + <span class="string">&quot; from &quot;</span> + from + <span class="string">&quot; to &quot;</span> + to);</span><br><span class="line">            hannoi(n - <span class="number">1</span>, help, to, from);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        hannoi(<span class="number">3</span>, <span class="string">&quot;left&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;mid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hannoi</span>(<span class="params">n, source, target, assist</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;move 1 from &#x27;</span> + source + <span class="string">&#x27; to &#x27;</span> + target)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hannoi(n - <span class="number">1</span>, source, assist, target)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;move &#x27;</span> + <span class="built_in">str</span>(n) + <span class="string">&#x27; from &#x27;</span> + source + <span class="string">&#x27; to &#x27;</span> + target)</span><br><span class="line">        hannoi(n - <span class="number">1</span>, assist, target, source)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>点击计数器</title>
    <url>/2022/01/19/HitCounter/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-362"><a href="#题目-LeetCode-362" class="headerlink" title="题目(LeetCode #362)"></a>题目(LeetCode #362)</h2><p>Design a hit counter which counts the number of hits received in the past 5 minutes.</p>
<p>Each function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.</p>
<p>It is possible that several hits arrive roughly at the same time.</p>
<p>Example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HitCounter counter = new HitCounter();</span><br><span class="line"></span><br><span class="line">// hit at timestamp <span class="number">1.</span></span><br><span class="line">counter.hit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">// hit at timestamp <span class="number">2.</span></span><br><span class="line">counter.hit(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">// hit at timestamp <span class="number">3.</span></span><br><span class="line">counter.hit(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">// get hits at timestamp <span class="number">4</span>, should <span class="keyword">return</span> <span class="number">3.</span></span><br><span class="line">counter.getHits(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">// hit at timestamp <span class="number">300.</span></span><br><span class="line">counter.hit(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">// get hits at timestamp <span class="number">300</span>, should <span class="keyword">return</span> <span class="number">4.</span></span><br><span class="line">counter.getHits(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">// get hits at timestamp <span class="number">301</span>, should <span class="keyword">return</span> <span class="number">3.</span></span><br><span class="line">counter.getHits(<span class="number">301</span>); </span><br></pre></td></tr></table></figure>

<p>Follow up:<br>What if the number of hits per second could be very large? Does your design scale?</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>使用队列保存所有的 timestamp，获取点击数时将所有与当前时间戳相距 5 分钟以上的元素弹出，返回剩余队列长度即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HitCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HitCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hit</span><span class="params">(<span class="type">int</span> timestamp)</span> &#123;</span><br><span class="line">        queue.add(timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHits</span><span class="params">(<span class="type">int</span> timestamp)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; timestamp - queue.peek() &gt;= <span class="number">300</span>)</span><br><span class="line">            queue.poll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>对于 follow up 中的情况，可使用两个数组分别保存时间戳和点击次数，每次调用 hit 时将时间戳对 300 取余得到对应的索引，若该索引对应的时间戳与当前输入不同，则说明已超过 5 分钟。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HitCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] times, hits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HitCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        times = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">300</span>];</span><br><span class="line">        hits = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">300</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hit</span><span class="params">(<span class="type">int</span> timestamp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> timestamp % <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">if</span> (times[idx] != timestamp) &#123;</span><br><span class="line">            times[idx] = timestamp;</span><br><span class="line">            hits[idx] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hits[idx]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHits</span><span class="params">(<span class="type">int</span> timestamp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timestamp - times[i] &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                cnt += hits[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>队列</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>链表相交问题</title>
    <url>/2020/03/09/IntersectionOfTwoLinkedLists/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个<strong>单链表</strong>的头结点 <code>head1</code> 和 <code>head2</code> , 这两个链表<strong>可能有环也可能无环</strong>, 请判断这两个链表是否相交, 若相交则返回第一个相交结点</p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>如果链表的长度分别为 <code>M</code> 和 <code>N</code> , 时间复杂度为 <code>O(M+N)</code> , 额外空间复杂度为 <code>O(1)</code></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>可采用先将一个链表中的结点放入 <code>HashSet</code> 中, 再遍历另一个链表判断结点是否已在该 <code>HashSet</code> 中的方法, 但额外空间复杂度不符合条件.</p>
<p>不使用 <code>HashSet</code> 的解法: </p>
<p>先<a href="https://zcybupt.github.io/post/LinkedListCycle/">判断链表是否有环</a></p>
<ol>
<li><p>若链表无环</p>
<p> 此时若两链表相交则至少共用两链表的最后一个结点, 只需判断两链表的最后一个结点是否相同即可. 若要找到第一个相交结点需先统计链表长度 <code>L1</code> 和 <code>L2</code> , 较长的链表的指针先移动 <code>abs(L1-L2)</code> 步, 剩余的部分即与较短的链表长度相同, 再同时移动相同步数后即可找到第一个相交结点.</p>
<p> <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200309152208.png"></p>
</li>
<li><p>若一个链表有环一个无环</p>
<p> 此时对两个单链表来说二者不可能相交</p>
<p> <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200309152026.png"></p>
</li>
<li><p>若两个链表都有环</p>
<p> 此时有三种情况</p>
<p> <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200309151404.png"></p>
<ul>
<li>  若两个链表的入环结点相同, 则为图2</li>
<li>  若另两个链表的入环结点不同, 则可能有图 1 和图 3 两种可能. 可从一个入环结点开始继续遍历, 若再次遍历回该结点之前经过了另一个入环结点则为图 3 情况, 否则为图 1 情况, 即二者不相交.</li>
</ul>
</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntersectionList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">getEntrance</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="literal">null</span> || fast.next.next == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 entranceA 和 entranceB 设为 null 时, 为求两个无环链表的交点,</span></span><br><span class="line"><span class="comment">     * 当 entranceA 和 entranceB 不为 null 时, 为求交点在入环结点前的两个链表的交点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headA     链表 1 的头结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entranceA 链表 1 的入环结点, 若无环则为 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headB     链表 2 的头结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entranceB 链表 2 的入环结点, 若无环则为 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两链表的交点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getNodeHelper1</span><span class="params">(ListNode headA, ListNode entranceA, ListNode headB, ListNode entranceB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmpA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmpB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tmpA != entranceA) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            tmpA = tmpA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tmpB != entranceB) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            tmpB = tmpB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmpA != tmpB)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无论 A 和 B 谁长都能保证 tmpA 始终指向长的, tmpB 指向短的</span></span><br><span class="line">        tmpA = count &gt; <span class="number">0</span> ? headA : headB;</span><br><span class="line">        tmpB = tmpA == headA ? headB : headA;</span><br><span class="line">        count = count &gt; <span class="number">0</span> ? count : -count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将长的链表指针拨到与另一条链表等长处</span></span><br><span class="line">        <span class="keyword">while</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            tmpA = tmpA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tmpA != tmpB) &#123;</span><br><span class="line">            tmpA = tmpA.next;</span><br><span class="line">            tmpB = tmpB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmpA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当两链表均有环且入环结点不同, 即两链表交点在环上时</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entranceA 链表 1 入环结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entranceB 链表 2 入环结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两链表交点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getNodeHelper2</span><span class="params">(ListNode entranceA, ListNode entranceB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmpA</span> <span class="operator">=</span> entranceA.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tmpA != entranceA) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmpA == entranceB)</span><br><span class="line">                <span class="keyword">return</span> tmpA;</span><br><span class="line">            tmpA = tmpA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">entranceA</span> <span class="operator">=</span> getEntrance(headA);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">entranceB</span> <span class="operator">=</span> getEntrance(headB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两链表均无环</span></span><br><span class="line">        <span class="keyword">if</span> (entranceA == <span class="literal">null</span> &amp;&amp; entranceB == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getNodeHelper1(headA, <span class="literal">null</span>, headB, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两链表均有环</span></span><br><span class="line">        <span class="keyword">if</span> (entranceA != <span class="literal">null</span> &amp;&amp; entranceB != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 两链表入环结点相同, 交点在入环结点前或与入环结点重合</span></span><br><span class="line">            <span class="keyword">if</span> (entranceA == entranceB) &#123;</span><br><span class="line">                <span class="keyword">return</span> getNodeHelper1(headA, entranceA, headB, entranceB);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 两链表交点在环上(此时两个入环结点均可为交点, 情况 3), 或两个带环链表无交点(情况 1)</span></span><br><span class="line">            <span class="keyword">return</span> getNodeHelper2(entranceA, entranceB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个链表有环, 一个链表无环, 不可能相交, 直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntersectionList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_entrance</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">and</span> head.<span class="built_in">next</span> <span class="keyword">and</span> head.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = head.<span class="built_in">next</span></span><br><span class="line">            fast = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> slow != fast:</span><br><span class="line">                <span class="keyword">if</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            fast = head</span><br><span class="line">            <span class="keyword">while</span> slow != fast:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> fast</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_length</span>(<span class="params">self, head, entrance</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> head != entrance:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count, head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_node_helper1</span>(<span class="params">self, head_a, head_b, entrance_a=<span class="literal">None</span>, entrance_b=<span class="literal">None</span></span>):</span><br><span class="line">        length_a, tail_a = self.get_length(head_a, entrance_a)</span><br><span class="line">        length_b, tail_b = self.get_length(head_b, entrance_b)</span><br><span class="line"></span><br><span class="line">        tmp_a = head_a <span class="keyword">if</span> length_a &gt; length_b <span class="keyword">else</span> head_b</span><br><span class="line">        tmp_b = head_b <span class="keyword">if</span> tmp_a == head_a <span class="keyword">else</span> head_a</span><br><span class="line">        steps = <span class="built_in">abs</span>(length_a - length_b)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> steps != <span class="number">0</span>:</span><br><span class="line">            steps -= <span class="number">1</span></span><br><span class="line">            tmp_a = tmp_a.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> tmp_a != tmp_b:</span><br><span class="line">            tmp_a = tmp_a.<span class="built_in">next</span></span><br><span class="line">            tmp_b = tmp_b.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmp_a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_node_helper2</span>(<span class="params">self, entrance_a, entrace_b</span>):</span><br><span class="line">        tmp_a = entrance_a.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> tmp_a != entrance_a:</span><br><span class="line">            <span class="keyword">if</span> tmp_a == entrace_b:</span><br><span class="line">                <span class="keyword">return</span> tmp_a</span><br><span class="line">            tmp_a = tmp_a.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_intersection_node</span>(<span class="params">self, head_a, head_b</span>):</span><br><span class="line">        <span class="keyword">if</span> head_a <span class="keyword">and</span> head_b:</span><br><span class="line">            entrance_a = self.get_entrance(head_a)</span><br><span class="line">            entrance_b = self.get_entrance(head_b)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> entrance_a <span class="keyword">and</span> <span class="keyword">not</span> entrance_b:</span><br><span class="line">                <span class="keyword">return</span> self.get_node_helper1(head_a, head_b)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> entrance_a <span class="keyword">and</span> entrance_b:</span><br><span class="line">                <span class="keyword">if</span> entrance_a == entrance_b:</span><br><span class="line">                    <span class="keyword">return</span> self.get_node_helper1(head_a, head_b, entrance_a, entrance_b)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> self.get_node_helper2(entrance_a, entrance_b)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="例题-LeetCode-160"><a href="#例题-LeetCode-160" class="headerlink" title="例题 LeetCode # 160"></a>例题 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists">LeetCode # 160</a></h2><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200309201612.png"></p>
<p>在节点 c1 开始相交。</p>
<p>示例 1：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200309201627.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>


<p>示例 2：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200309201657.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">2</span>, listA = [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], listB = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], skipA = <span class="number">3</span>, skipB = <span class="number">1</span></span><br><span class="line">输出：Reference of the node <span class="keyword">with</span> value = <span class="number">2</span></span><br><span class="line">输入解释：相交节点的值为 <span class="number">2</span> （注意，如果两个列表相交则不能为 <span class="number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]。在 A 中，相交节点前有 <span class="number">3</span> 个节点；在 B 中，相交节点前有 <span class="number">1</span> 个节点。</span><br></pre></td></tr></table></figure>


<p>示例 3：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200309201731.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">0</span>, listA = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>], listB = [<span class="number">1</span>,<span class="number">5</span>], skipA = <span class="number">3</span>, skipB = <span class="number">2</span></span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">1</span>,<span class="number">5</span>]。由于这两个链表不相交，所以 intersectVal 必须为 <span class="number">0</span>，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>


<p>注意：</p>
<ul>
<li>  如果两个链表没有交点，返回 null.</li>
<li>  在返回结果后，两个链表仍须保持原有的结构。</li>
<li>  可假定整个链表结构中<strong>没有循环</strong>。</li>
<li>  程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li>
</ul>
<h3 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntersectionList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmpA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmpB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tmpA != <span class="literal">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            tmpA = tmpA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tmpB != <span class="literal">null</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            tmpB = tmpB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmpA != tmpB)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无论 A 和 B 谁长都能保证 tmpA 始终指向长的, tmpB 指向短的</span></span><br><span class="line">        tmpA = count &gt; <span class="number">0</span> ? headA : headB;</span><br><span class="line">        tmpB = tmpA == headA ? headB : headA;</span><br><span class="line">        count = count &gt; <span class="number">0</span> ? count : -count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将长的链表指针拨到与另一条链表等长处</span></span><br><span class="line">        <span class="keyword">while</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            tmpA = tmpA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tmpA != tmpB) &#123;</span><br><span class="line">            tmpA = tmpA.next;</span><br><span class="line">            tmpB = tmpB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmpA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntersectionList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_length</span>(<span class="params">self, head</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count, head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, head_a, head_b</span>):</span><br><span class="line">        length_a, tail_a = self.get_length(head_a)</span><br><span class="line">        length_b, tail_b = self.get_length(head_b)</span><br><span class="line"></span><br><span class="line">        tmp_a = head_a <span class="keyword">if</span> length_a &gt; length_b <span class="keyword">else</span> head_b</span><br><span class="line">        tmp_b = head_b <span class="keyword">if</span> tmp_a == head_a <span class="keyword">else</span> head_a</span><br><span class="line">        steps = <span class="built_in">abs</span>(length_a - length_b)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> steps != <span class="number">0</span>:</span><br><span class="line">            steps -= <span class="number">1</span></span><br><span class="line">            tmp_a = tmp_a.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> tmp_a != tmp_b:</span><br><span class="line">            tmp_a = tmp_a.<span class="built_in">next</span></span><br><span class="line">            tmp_b = tmp_b.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmp_a</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>判断一个链表是否为回文结构</title>
    <url>/2020/03/01/IsPalindrome/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-234"><a href="#题目-LeetCode-234" class="headerlink" title="题目 LeetCode # 234"></a>题目 <a href="https://leetcode-cn.com/problems/palindrome-linked-list/">LeetCode # 234</a></h2><p>判断一个链表是否为回文结构</p>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span> 返回 true</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">3</span> -&gt;<span class="number">3</span> -&gt; <span class="number">1</span> 返回 true</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> 返回 false</span><br></pre></td></tr></table></figure>

<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>时间复杂度 <code>O(N)</code> , <strong>空间复杂度 <code>O(1)</code></strong></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>若不考虑空间复杂度, 可将所有元素存入栈中, 边出栈边比较即可, 此时空间复杂度为 <code>O(N)</code> ; 也可先 <a href="https://zcybupt.github.io/post/MiddleNode/">利用快慢指针找到中间指针</a> , 再将中间指针后的部分存入栈中, 出栈时与链表前半部分比较, 此时空间占用为 <code>N/2</code> , 空间复杂度仍为 <code>O(N)</code> . 若要实现空间复杂度 <code>O(1)</code> , 可考虑先利用快慢指针找到中间结点, 后将中间结点后的结点的指针方向反向, 即可实现由链表尾向中间结点的遍历, 之后还原链表结构即可. 链表逆序过程中需注意边界, 前半部分最后一个元素和逆序后的后半部分的最后一个元素的 <code>next</code> 均需置空, 否则遍历时很容易死循环.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsPalindrome</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fastPointer</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slowPointer</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fastPointer != <span class="literal">null</span> &amp;&amp; fastPointer.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fastPointer = fastPointer.next.next;</span><br><span class="line">            slowPointer = slowPointer.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slowPointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// LeetCode 测试用例中输入为[]时要求返回true, 很沙雕</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">middleNode</span> <span class="operator">=</span> middleNode(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tailNode</span> <span class="operator">=</span> reversePointer(middleNode);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftPointer</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rightPointer</span> <span class="operator">=</span> tailNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (leftPointer != <span class="literal">null</span> &amp;&amp; rightPointer != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftPointer.val != rightPointer.val) &#123;</span><br><span class="line">                reversePointer(rightPointer);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            leftPointer = leftPointer.next;</span><br><span class="line">            rightPointer = rightPointer.next;</span><br><span class="line">        &#125;</span><br><span class="line">        reversePointer(tailNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reversePointer</span><span class="params">(ListNode startNode)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> startNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = fast.next;</span><br><span class="line">            fast.next = slow;</span><br><span class="line">            slow = fast;</span><br><span class="line">            fast = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        startNode.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IsPalindrome</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middle_node</span>(<span class="params">self, head</span>):</span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_pointer</span>(<span class="params">self, start_node</span>):</span><br><span class="line">        slow = start_node</span><br><span class="line">        fast = start_node.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            tmp = fast.<span class="built_in">next</span></span><br><span class="line">            fast.<span class="built_in">next</span> = slow</span><br><span class="line">            slow = fast</span><br><span class="line">            fast = tmp</span><br><span class="line"></span><br><span class="line">        start_node.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_palindrome</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        middle_node = self.middle_node(head)</span><br><span class="line">        tail_node = self.reverse_pointer(middle_node)</span><br><span class="line"></span><br><span class="line">        left_pointer = head</span><br><span class="line">        right_pointer = tail_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left_pointer <span class="keyword">and</span> right_pointer:</span><br><span class="line">            <span class="keyword">if</span> left_pointer.val != right_pointer.val:</span><br><span class="line">                self.reverse_pointer(right_pointer)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            left_pointer = left_pointer.<span class="built_in">next</span></span><br><span class="line">            right_pointer = right_pointer.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        self.reverse_pointer(tail_node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2020/07/18/KMP/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-28"><a href="#题目-LeetCode-28" class="headerlink" title="题目(LeetCode #28)"></a>题目(<a href="https://leetcode-cn.com/problems/implement-strstr/">LeetCode #28</a>)</h2><p>实现 <code>strStr()</code> 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p><strong>输入:</strong> haystack = “hello”, needle = “ll”<br><strong>输出:</strong> 2</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p><strong>输入:</strong> haystack = “aaaaa”, needle = “bba”<br><strong>输出:</strong> -1</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>参考资料：</p>
<ul>
<li><p><a href="https://www.bilibili.com/video/BV1Px411z7Yo">KMP字符串匹配算法1</a></p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1hW411a7ys">KMP字符串匹配算法2</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI5ODA5NTgyMw==&mid=2247483968&idx=1&sn=3c21f29eb6c5083f85ac7c97d2051303&chksm=ecaa47e0dbddcef6a97a453df68bc6c6ff040bdd84f58caf99b1f3a8cb84d7405062b039c396&token=1263366918&lang=zh_CN#rd">图解KMP</a></p>
</li>
</ul>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getNextTable(String needle) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> needle.length();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lp</span> <span class="operator">=</span> -<span class="number">1</span>, rp = <span class="number">0</span>;    <span class="comment">// 左右指针, 即文章中的 k 和 index</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rp &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lp == -<span class="number">1</span> || needle.charAt(rp) == needle.charAt(lp))</span><br><span class="line">                <span class="comment">// lp = -1 时, 左右指针均向右移动</span></span><br><span class="line">                <span class="comment">// 当左右指针所指元素相等时, 均向右移动</span></span><br><span class="line">                next[++rp] = ++lp;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 左右指针所指元素不等, 左指针移向其所指字符的对应 next 指向的位置</span></span><br><span class="line">                lp = next[lp];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">haystackLen</span> <span class="operator">=</span> haystack.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">needleLen</span> <span class="operator">=</span> needle.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needleLen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">haystackCur</span> <span class="operator">=</span> <span class="number">0</span>, needleCur = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = getNextTable(needle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (haystackCur &lt; haystackLen &amp;&amp; needleCur &lt; needleLen) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(haystackCur) == needle.charAt(needleCur)) &#123;</span><br><span class="line">                <span class="comment">// 对比两个字符串, 各位相同时两指针右移</span></span><br><span class="line">                haystackCur++;</span><br><span class="line">                needleCur++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不相同则根据 next 表查找 needleCur 移向的位置</span></span><br><span class="line">                <span class="comment">// needleCur 移动到了开头, 退无可退, 主串指针继续后移</span></span><br><span class="line">                <span class="keyword">if</span> (needleCur == <span class="number">0</span>) haystackCur++;</span><br><span class="line">                <span class="keyword">else</span> needleCur = next[needleCur];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> needleCur == needleLen ? haystackCur - needleCur : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KMP</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_next_table</span>(<span class="params">self, needle</span>):</span><br><span class="line">        length = <span class="built_in">len</span>(needle)</span><br><span class="line">        lp, rp = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        next_table = [<span class="number">0</span>] * length</span><br><span class="line">        next_table[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> rp &lt; length - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> needle[lp] == needle[rp] <span class="keyword">or</span> lp == -<span class="number">1</span>:</span><br><span class="line">                rp += <span class="number">1</span></span><br><span class="line">                lp += <span class="number">1</span></span><br><span class="line">                next_table[rp] = lp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lp = next_table[lp]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next_table</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_index</span>(<span class="params">self, haystack, needle</span>):</span><br><span class="line">        haystack_len = <span class="built_in">len</span>(haystack)</span><br><span class="line">        needle_len = <span class="built_in">len</span>(needle)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> needle_len == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        haystack_cur, needle_cur = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        next_table = self.get_next_table(needle)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> haystack_cur &lt; haystack_len <span class="keyword">and</span> needle_cur &lt; needle_len:</span><br><span class="line">            <span class="keyword">if</span> haystack[haystack_cur] == needle[needle_cur]:</span><br><span class="line">                haystack_cur += <span class="number">1</span></span><br><span class="line">                needle_cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> needle_cur == <span class="number">0</span>: haystack_cur += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: needle_cur = next_table[needle_cur]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> haystack_cur - needle_cur <span class="keyword">if</span> needle_cur == needle_len <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNextTable</span><span class="params">(needle <span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(needle)</span><br><span class="line">	lp, rp := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">	next := <span class="built_in">make</span>([]<span class="type">int</span>, length)</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> rp &lt; length<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> lp == <span class="number">-1</span> || needle[lp] == needle[rp] &#123;</span><br><span class="line">			rp++</span><br><span class="line">			lp++</span><br><span class="line">			next[rp] = lp</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			lp = next[lp]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIndex</span><span class="params">(haystack, needle <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	haystackLen := <span class="built_in">len</span>(haystack)</span><br><span class="line">	needleLen := <span class="built_in">len</span>(needle)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> needleLen == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	haystackCur, needleCur := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	next := getNextTable(needle)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> haystackCur &lt; haystackLen &amp;&amp; needleCur &lt; needleLen &#123;</span><br><span class="line">		<span class="keyword">if</span> haystack[haystackCur] == needle[needleCur] &#123;</span><br><span class="line">			haystackCur++</span><br><span class="line">			needleCur++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> needleCur == <span class="number">0</span> &#123;</span><br><span class="line">				haystackCur++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				needleCur = next[needleCur]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> needleCur == needleLen &#123;</span><br><span class="line">		<span class="keyword">return</span> haystackCur - needleCur</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>限重最大值问题</title>
    <url>/2020/06/26/Knapsack/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个数组 <code>w</code> 和 <code>v</code> ，两个数组长度相等，<code>w[i]</code> 表示第i件商品的 重量，<code>v[i]</code> 表示第i件商品的价值。 再给定一个整数 <code>bag</code> ，要求你挑选商品的重量加起来一定不能超过 <code>bag</code> ，返回满足这个条件下，你能获得的最大价值。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>解法类似<a href="https://zcybupt.github.io/post/SumToTarget/">上一篇博客</a></p>
<h4 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h4><p>穷举所有可能的结果, 迭代过程中判断累计重量 <code>acc_weight</code> 是否超过 <code>bag</code> , 若超过则返回 <code>Integer.MIN_VALUE</code> , 相当于直接舍弃该分支. 另一个迭代的基础条件为当 <code>i</code> 达到 <code>w.length</code> 时, 返回 <code>0</code> , 因为第 <code>i</code> 次递归的返回值为当前商品的价值 <code>v[i]</code> 加上后续商品的价值与只有后续商品价值二者中的较大者, <code>i</code> 等于 <code>w.length</code> 时, 没有后续商品, 故直接返回 <code>0</code> .</p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Knapsack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> i, <span class="type">int</span> accWeight, <span class="type">int</span> bag)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (accWeight &gt; bag) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;   <span class="comment">// 重量超过 bag, 舍弃</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == w.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(</span><br><span class="line">                maxValue(w, v, i + <span class="number">1</span>, accWeight, bag),</span><br><span class="line">                v[i] + maxValue(w, v, i + <span class="number">1</span>, accWeight + w[i], bag)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] w = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] v = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">19</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bag</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(maxValue(w, v, <span class="number">0</span>, <span class="number">0</span>, bag));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_value</span>(<span class="params">w, v, i, acc_weight, bag</span>):</span><br><span class="line">    <span class="keyword">if</span> acc_weight &gt; bag: <span class="keyword">return</span> <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(w): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(</span><br><span class="line">        max_value(w, v, i + <span class="number">1</span>, acc_weight, bag),</span><br><span class="line">        v[i] + max_value(w, v, i + <span class="number">1</span>, acc_weight + w[i], bag)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>此类<strong>无后效性</strong>的递归问题均可转化为动态递归.</p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol>
<li> 分析可变参数, 求出表空间</li>
<li> 确定最终状态</li>
<li> 根据 base case 确定初始状态</li>
<li> 分析一个普遍位置的依赖关系</li>
<li> 根据依赖顺序, 逆序求出整张表</li>
</ol>
<h5 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">Knapsack</span> &#123;</span><br><span class="line">    public static <span class="built_in">int</span> maxValue(<span class="built_in">int</span>[] w, <span class="built_in">int</span>[] v, <span class="built_in">int</span> bag) &#123;</span><br><span class="line">        <span class="built_in">int</span>[][] dp = new <span class="built_in">int</span>[w.length + <span class="number">1</span>][bag + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= bag; i++) &#123;</span><br><span class="line">            dp[w.length][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = w.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = bag; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j + w[i] &lt;= bag)</span><br><span class="line">                    dp[i][j] = Math.<span class="built_in">max</span>(</span><br><span class="line">                            dp[i + <span class="number">1</span>][j],</span><br><span class="line">                            dp[i + <span class="number">1</span>][j + w[i]] + v[i]</span><br><span class="line">                    );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_value</span>(<span class="params">w, v, bag</span>):</span><br><span class="line">    dp = [[<span class="number">0</span>] * (bag + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w) + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(bag, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[i][j] = dp[i + <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j + w[i] &lt;= bag:</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(</span><br><span class="line">                    dp[i + <span class="number">1</span>][j],</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + w[i]] + v[i]</span><br><span class="line">                )</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>无重复字符的最长子串</title>
    <url>/2020/08/02/LengthOfLongestSubstring/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-3"><a href="#题目-LeetCode-3" class="headerlink" title="题目(LeetCode #3)"></a>题目(<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LeetCode #3</a>)</h2><p>给定一个字符串，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p><strong>输入:</strong> “abcabcbb”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p><strong>输入:</strong> “bbbbb”<br><strong>输出:</strong> 1<br><strong>解释:</strong> 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p><strong>输入:</strong> “pwwkew”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 因为无重复字符的最长子串是 “wke”，所以其长度为 3。答案必须是<strong>子串</strong>的长度，”pwke” 是一个子序列，不是子串。</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>可采用滑动窗口法，将窗口内的字符保存到集合中，窗口的左边界向右移动时，弹出已不在窗口内的元素；窗口的右边界向右移动时判断字符是否已在集合中，若不在则加入，若已有则终止循环，记录当前最长长度。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashSet&lt;Character&gt; charSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rk</span> <span class="operator">=</span> -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                charSet.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; length &amp;&amp; !charSet.contains(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">                charSet.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">                rk++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abcabcbb&quot;</span>;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        System.out.println(solution.lengthOfLongestSubstring(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        char_set = <span class="built_in">set</span>()</span><br><span class="line">        rk, ans = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>: char_set.remove(s[i - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> rk + <span class="number">1</span> &lt; length <span class="keyword">and</span> s[rk + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> char_set:</span><br><span class="line">                char_set.add(s[rk + <span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, rk - i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Golang 中没有集合，使用 map 实现过于繁琐，可采用 int 数组来模拟集合操作。</p>
<p>将每个字符的 <code>ASCII</code> 值作为数组的索引，数组内存储的为该字符的出现与否（1 或 0）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> window [<span class="number">128</span>]<span class="type">int</span>         <span class="comment">// ASCII 总共定义了 128 个字符</span></span><br><span class="line">	length := <span class="built_in">len</span>(s)</span><br><span class="line">	rk, ans := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">			window[s[i<span class="number">-1</span>]] = <span class="number">0</span>  <span class="comment">// 左边界移出窗口</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> rk+<span class="number">1</span> &lt; length &amp;&amp; window[s[rk+<span class="number">1</span>]] == <span class="number">0</span> &#123;</span><br><span class="line">			window[s[rk+<span class="number">1</span>]] = <span class="number">1</span> <span class="comment">// 右边界移入窗口</span></span><br><span class="line">			rk++</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="type">int</span>(math.Max(<span class="type">float64</span>(ans), <span class="type">float64</span>(rk-i+<span class="number">1</span>)))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>最低字典序排列字符串</title>
    <url>/2020/07/13/LexicographicalString/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串类型的数组 <code>strs</code> , 找到一种拼接方式, 使得把所有字符串拼接起来之后形成的字符串具有最低的字典序.</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>不可通过将各个数组元素按字典序排列再拼接的方式来解, 如对数组 <code>[&#39;b&#39;, &#39;ba&#39;]</code> 来说, 若按元素字典序来排列将得到 <code>bba</code> , 而实际上该结果并没有 <code>bab</code> 小, 故这种做法不可取.</p>
<p>本题应比较 <code>str1 + str2</code> 和 <code>str2 + str1</code> 的字典序大小, 以此为标准重写比较函数, 排序后拼接即可.</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LowestLexicography</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">lowestString</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(strs, (a, b) -&gt; (a + b).compareTo(b + a));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            result += str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>以冒泡排序为例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_lowest_lexicography</span>(<span class="params">strings</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strings)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strings) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> strings[j] + strings[j + <span class="number">1</span>] &gt; strings[j + <span class="number">1</span>] + strings[j]:</span><br><span class="line">                strings[j], strings[j + <span class="number">1</span>] = strings[j + <span class="number">1</span>], strings[j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(strings)</span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">func getLowestLexicography(strs []string) string &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strs); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(strs)-<span class="number">1</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> strs[j]+strs[j+<span class="number">1</span>] &gt; strs[j+<span class="number">1</span>]+strs[j] &#123;</span><br><span class="line">				strs[j], strs[j+<span class="number">1</span>] = strs[j+<span class="number">1</span>], strs[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> strings.Join(strs, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>贪心问题</tag>
        <tag>字典序</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表</title>
    <url>/2020/03/08/LinkedListCycle/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表, 判断链表中是否有环, 若有则返回链表尾指向的结点.</p>
<h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>遍历时使用 <code>HashSet</code> 保存所有节点, 若遍历到重复节点则返回该节点</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CycleList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        HashSet&lt;ListNode&gt; nodeSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeSet.contains(head))</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            nodeSet.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CycleList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head</span>):     </span><br><span class="line">        node_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> node_set:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            node_set.add(head)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>使用快慢指针, 该解法空间复杂度为 <code>O(1)</code> , 慢指针每次移动一个位置, 快指针每次移动两个位置, 该方法利用了两个定律:</p>
<ul>
<li>  若链表中有环, 则两指针必相遇</li>
<li>  两指针相遇后, 快指针放回头结点, 从此快慢指针都每次移动一个位置, <strong><u>两指针必在第一个入环节点处相遇</u></strong></li>
</ul>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CycleList</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="literal">null</span> || fast.next.next ==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CycleList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">and</span> head.<span class="built_in">next</span> <span class="keyword">and</span> head.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = head.<span class="built_in">next</span></span><br><span class="line">            fast = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> slow != fast:</span><br><span class="line">                <span class="keyword">if</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            fast = head</span><br><span class="line">            <span class="keyword">while</span> slow != fast:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> fast</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="例题-LeetCode-141"><a href="#例题-LeetCode-141" class="headerlink" title="例题 LeetCode # 141"></a>例题 <a href="https://leetcode-cn.com/problems/linked-list-cycle">LeetCode # 141</a></h2><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置(索引从 0 开始)。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p>示例 1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200308190110.png"></p>
<p>示例 2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200308190124.png"></p>
<p>示例 3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], pos = -<span class="number">1</span></span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200308190316.png"></p>
<h3 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h3><p>空间复杂度为 <code>O(1)</code></p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CycleList</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="literal">null</span> || fast.next.next ==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python-2"><a href="#Python-2" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CycleList</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">and</span> head.<span class="built_in">next</span> <span class="keyword">and</span> head.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = head.<span class="built_in">next</span></span><br><span class="line">            fast = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> slow != fast:</span><br><span class="line">                <span class="keyword">if</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher算法</title>
    <url>/2020/07/20/Manacher/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-5"><a href="#题目-LeetCode-5" class="headerlink" title="题目(LeetCode #5)"></a>题目(<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">LeetCode #5</a>)</h2><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入:</strong> “babad”<br><strong>输出:</strong> “bab”<br><strong>注意:</strong> “aba” 也是一个有效答案。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>  <strong>输入:</strong> “cbbd”<br>  <strong>输出:</strong> “bb”</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="扩展中心法"><a href="#扩展中心法" class="headerlink" title="扩展中心法"></a>扩展中心法</h3><p>遍历字符串，由每个字符串向两侧扩展逐一比对。</p>
<p>时间复杂度为 <code>O(n²)</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.max(len1, len2);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">expandAroundCenter</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            left--; right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h3><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>在原始字符串的每个字符的左右两边都加上特殊字符，使处理后的字符串长度均为奇数，以此来解决偶回文时用扩展法不能找到回文中心而导致的找不到回文子串的问题。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200721172042.png" alt="处理前"></p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200721172128.png" alt="处理后"></p>
<h4 id="最长回文子串长度"><a href="#最长回文子串长度" class="headerlink" title="最长回文子串长度"></a>最长回文子串长度</h4><p>下表中 <code>p</code> 数组存储的是以各字符为中心的回文子串的最大长度。观察可知，预处理后的字符串的最长回文子串的回文半径减 <code>1</code> 即为原字符串的最长回文子串长度。以字符串 <code>cabbaf</code> 为例，处理后的最长回文子串的回文半径为 <code>p[6] = 5</code> ，<code>p[6] - 1 = 4</code> 即为原字符串的最长回文子串 <code>abba</code> 的长度。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200721172934.png"></p>
<p>所以原字符串的最长回文子串长度 <code>maxLen = p[i] - 1</code></p>
<h4 id="最长回文子串的起始索引"><a href="#最长回文子串的起始索引" class="headerlink" title="最长回文子串的起始索引"></a>最长回文子串的起始索引</h4><p>在 <code>#c#a#b#b#a#f#</code> 中，<code>p[6] = 5</code> ，用索引 <code>i</code> 减去最长回文半径 <code>p[i]</code> 即可得到原字符串的最长回文子串的起始索引，即 <code>i - p[i] = 6 - 5 = 1</code> ；但对奇回文 <code>aba</code> 来说，用这种方法得到的结果为 <code>3 - p[3] = 3 - 4 = -1</code> ，下标越界。</p>
<p>为解决下标越界的问题，可在预处理后的字符串前再添加一个特殊字符，而为了使字符串长度保持为奇数，其后也需添加另一个字符。而原字符串的最长回文子串的起始索引变为 <code>(i - p[i]) / 2</code> 。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200721180408.png"></p>
<p>对 <code>cabbaf</code> 来说，原字符串的最长回文子串的起始索引为 <code>(7 - p[7]) / 2 = (7 - 5) / 2 = 1</code></p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200721180435.png"></p>
<p>对 <code>aba</code> 来说，原字符串的最长回文子串的起始索引为 <code>(3 - p[3]) / 2 = (3 - 3) / 2 = 0</code></p>
<p>故原字符串的最长回文子串的起始索引可表示为 <code>index = (i - p[i]) / 2</code></p>
<h4 id="计算-p-数组"><a href="#计算-p-数组" class="headerlink" title="计算 p 数组"></a>计算 p 数组</h4><p>定义两个变量 <code>C</code> 和 <code>R</code> ，分别为某一回文子串的中心字符的索引和右边界。如对 <code>^#c#a#b#b#a#f#$</code> 中的 <code>#a#b#b#a#</code> 来说，<code>C = 7</code> ，<code>p[C] = 5</code> ，以 <code>7</code> 为中心的回文子串的右边界即为 <code>R = C + p[C] = 12 </code> ；当 <code>C = 12</code> 时，以 <code>12</code> 为中心的回文子串的右边界即为 <code>R = C + p[C] = 12 + 2 = 14</code> 。</p>
<p>故可得回文子串右边界与其半径之间的关系为：<code>R = C + p[C]</code></p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200721192607.png"></p>
<p>由于回文子串关于 <code>C</code> 对称，由该子串上某位置 <code>i</code> 可得其对称位置 <code>j</code> ，由 <code>i + j = 2 * C</code> 知 <code>j = 2 * C - i</code> 。</p>
<ul>
<li>  若以 <code>j</code> 为中心的回文子串的右边界在 <code>R</code> 以内，即 <code>j + p[j] &lt; R</code> 时，由对称性可知，<code>p[j] = p[i]</code> ；</li>
<li>  若以 <code>j</code> 为中心的回文子串的右边界大于 <code>R</code> ，即 <code>j + p[j] &gt; R</code> 时，图中红色部分为关于 <code>j</code> 对称的回文子串，故此时有 <code>p[j] = R - j</code> ；</li>
<li>  若 <code>j + p[j] &gt;= R</code> ，则令 <code>p[j] = 1</code> ，此时也需更新 <code>C</code> 和 <code>R</code> ，继续向后用扩展中心法计算 <code>p</code> 各位置的值。</li>
</ul>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manacher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">preprocess</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;^&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            result += <span class="string">&quot;#&quot;</span> + s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result + <span class="string">&quot;#$&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">tmpStr</span> <span class="operator">=</span> preprocess(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tmpStr.length();</span><br><span class="line">        <span class="type">int</span>[] p = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">C</span> <span class="operator">=</span> <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> -<span class="number">1</span>;    <span class="comment">// 最长回文子串长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;      <span class="comment">// 最长回文子串中心索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            p[i] = R &gt; i ? Math.min(p[<span class="number">2</span> * C - i], R - i) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (tmpStr.charAt(i + p[i]) == tmpStr.charAt(i - p[i]))</span><br><span class="line">                p[i]++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (R &lt; p[i] + i) &#123;</span><br><span class="line">                R = p[i] + i;</span><br><span class="line">                C = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (maxLen &lt; p[i] - <span class="number">1</span>) &#123;</span><br><span class="line">                maxLen = p[i] - <span class="number">1</span>;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (index - maxLen) / <span class="number">2</span>;   <span class="comment">// (i - p[i]) / 2</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Manacher</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longest_palindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) == <span class="number">0</span>: <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        tmp_str = <span class="string">&#x27;^#&#x27;</span> + <span class="string">&#x27;&#x27;</span>.join([x + <span class="string">&#x27;#&#x27;</span> <span class="keyword">for</span> x <span class="keyword">in</span> s]) + <span class="string">&quot;$&quot;</span></span><br><span class="line">        length = <span class="built_in">len</span>(tmp_str)</span><br><span class="line">        p = [<span class="number">0</span>] * length</span><br><span class="line">        c, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        max_len = -<span class="number">1</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length - <span class="number">1</span>):</span><br><span class="line">            p[i] = <span class="built_in">min</span>(p[<span class="number">2</span> * c - i], r - i) <span class="keyword">if</span> r &gt; i <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> tmp_str[i + p[i]] == tmp_str[i - p[i]]:</span><br><span class="line">                p[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> r &lt; i + p[i]:</span><br><span class="line">                r = i + p[i]</span><br><span class="line">                c = i</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> max_len &lt; p[i] - <span class="number">1</span>:</span><br><span class="line">                max_len = p[i] - <span class="number">1</span></span><br><span class="line">                index = i</span><br><span class="line"></span><br><span class="line">        start = (index - max_len) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_len]</span><br></pre></td></tr></table></figure>

<h5 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preprocess</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	result := <span class="string">&quot;^#&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">		result += <span class="type">string</span>(ch) + <span class="string">&quot;#&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result + <span class="string">&quot;$&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tmpStr := preprocess(s)</span><br><span class="line">	length := <span class="built_in">len</span>(tmpStr)</span><br><span class="line">	p := <span class="built_in">make</span>([]<span class="type">int</span>, length)</span><br><span class="line">	C, R := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	maxLen := <span class="number">0</span></span><br><span class="line">	index := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> R &gt; i &#123;</span><br><span class="line">			p[i] = <span class="type">int</span>(math.Min(<span class="type">float64</span>(p[<span class="number">2</span>*C-i]), <span class="type">float64</span>(R-i)))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			p[i] = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> tmpStr[i+p[i]] == tmpStr[i-p[i]] &#123;</span><br><span class="line">			p[i]++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> R &lt; i+p[i] &#123;</span><br><span class="line">			R = i + p[i]</span><br><span class="line">			C = i</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> maxLen &lt; p[i]<span class="number">-1</span> &#123;</span><br><span class="line">			maxLen = p[i] - <span class="number">1</span></span><br><span class="line">			index = i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	start := (index - maxLen) / <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> s[start : start+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/392172762e55">马拉车算法</a></p>
<p><a href="https://leetcode.wang/leetCode-5-Longest-Palindromic-Substring.html">leetcode.wang</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>子数组最大累加和</title>
    <url>/2020/07/11/MaxSumOfSubarray/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-53"><a href="#题目-LeetCode-53" class="headerlink" title="题目(LeetCode #53)"></a>题目(<a href="https://leetcode-cn.com/problems/maximum-subarray/submissions/">LeetCode #53</a>)</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<blockquote>
<p>  输入: [-2,1,-3,4,-1,2,1,-5,4],<br>  输出: 6<br>  解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>创建两个变量, <code>current</code> 和 <code>maxSum</code> , 遍历数组, 将每个元素累加到 <code>current</code> 上, 再与 <code>maxSum</code> 比较, 使 <code>maxSum</code> 总保存 <code>current</code> 的最大值, 若累加过程中 <code>current</code> 变为负数, 则手动将其归零, 继续计算.</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxSumOfSubarray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            current += num;</span><br><span class="line">            maxSum = Math.max(current, maxSum);</span><br><span class="line">            current = Math.max(current, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxSumOfSubarray</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        current = <span class="number">0</span></span><br><span class="line">        max_sum = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            current += num</span><br><span class="line">            max_sum = <span class="built_in">max</span>(current, max_sum)</span><br><span class="line">            current = <span class="built_in">max</span>(<span class="number">0</span>, current)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Go 中整型常量可定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> INT_MAX = <span class="type">int</span>(^<span class="type">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>) 	<span class="comment">// 有符号最大值</span></span><br><span class="line"><span class="keyword">const</span> INT_MIN = ^INT_MAX			<span class="comment">// 有符号最小值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UINT_MIN <span class="type">uint</span> = <span class="number">0</span>				<span class="comment">// 无符号最小值, 即为 0</span></span><br><span class="line"><span class="keyword">const</span> UINT_MAX = ^<span class="type">uint</span>(<span class="number">0</span>)			<span class="comment">// 无符号最大值</span></span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> nums == <span class="literal">nil</span> || <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	current := <span class="number">0</span></span><br><span class="line">	maxSum := ^<span class="type">int</span>(^<span class="type">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		current += num</span><br><span class="line">		maxSum = max(current, maxSum)</span><br><span class="line">		current = max(<span class="number">0</span>, current)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>投资最大化问题</title>
    <url>/2020/06/08/MaximizedCapital/</url>
    <content><![CDATA[<h3 id="题目-LeetCode-502"><a href="#题目-LeetCode-502" class="headerlink" title="题目 (LeetCode #502)"></a>题目 (<a href="https://leetcode-cn.com/problems/ipo/">LeetCode #502</a>)</h3><p>假设 力扣（LeetCode）即将开始其 IPO。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。</p>
<p>给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。</p>
<p>总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>  输入: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].</p>
<p>  输出: 4</p>
<p>  解释:<br>  由于你的初始资本为 0，你尽可以从 0 号项目开始。<br>  在完成后，你将获得 1 的利润，你的总资本将变为 1。<br>  此时你可以选择开始 1 号或 2 号项目。<br>  由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。<br>  因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。</p>
</blockquote>
<p><strong>注意:</strong></p>
<ol>
<li> 假设所有输入数字都是非负整数。</li>
<li> 表示利润和资本的数组的长度不超过 50000。</li>
<li> 答案保证在 32 位有符号整数范围内。</li>
</ol>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>本题是一个标准的贪心问题, 每一轮投资可以分为两步, 先将所有项目按成本 C 排序放入一个小根堆中, 再将所有成本小于现有资本的项目弹出, 按纯利润 P 排序放入另一个大根堆中, 弹出利润最高的元素, 将利润 P 与原资本相加得到新的资本, 循环以上步骤, 直至做完 k 个项目.</p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaximizedCapital</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> p;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.p = p;</span><br><span class="line">            <span class="built_in">this</span>.c = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMaximizedCapital</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> W, <span class="type">int</span>[] Profits, <span class="type">int</span>[] Capital)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Node&gt; minCost = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a.c - b.c;</span><br><span class="line">        &#125;);</span><br><span class="line">        PriorityQueue&lt;Node&gt; maxProfit = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> b.p - a.p;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Profits.length; i++) &#123;</span><br><span class="line">            minCost.add(<span class="keyword">new</span> <span class="title class_">Node</span>(Profits[i], Capital[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!minCost.isEmpty() &amp;&amp; minCost.peek().c &lt;= W)&#123;</span><br><span class="line">                maxProfit.add(minCost.poll());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (maxProfit.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> W;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            W += maxProfit.poll().p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> W;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><p>计算利润时, 成本不影响结果, 故可只取利润存入列表中.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaximizedCapital</span>:</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">MaximizedCapital</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaximizedCapital</span>(<span class="params">self, k, W, Profits, Capital</span>):</span><br><span class="line">        captal = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(Capital, Profits)), key=<span class="keyword">lambda</span> x: -x[<span class="number">0</span>])</span><br><span class="line">        profit = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">while</span> captal <span class="keyword">and</span> captal[-<span class="number">1</span>][<span class="number">0</span>] &lt;= W:</span><br><span class="line">                profit.append(captal.pop()[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            tmp_max = <span class="built_in">max</span>(profit) <span class="keyword">if</span> profit <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            W += tmp_max</span><br><span class="line">            <span class="keyword">if</span> profit:</span><br><span class="line">                profit.remove(tmp_max)</span><br><span class="line">        <span class="keyword">return</span> W</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>随时找到数据流的中位数</title>
    <url>/2020/06/07/MedianFinder/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-189"><a href="#题目-LeetCode-189" class="headerlink" title="题目 (LeetCode #189)"></a>题目 (<a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">LeetCode #189</a>)</h2><p>有一个源源不断地生成整数的数据流, 假设你有足够的空间来保存生成的数. 设计一个名叫 <code>MedianHolder</code> 的结构, 使之可以随时取得之前生成的所有数的中位数.</p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ol>
<li> 如果 <code>MedianHolder</code> 已经保存了生成的 <code>N</code> 个数, 那么任意时刻将一个新数加入到 <code>MedianHolder</code> 的过程, 其时间复杂度是 <code>O(logN)</code></li>
<li> 取得已经产生的 <code>N</code> 个数整体的中位数的过程, 时间复杂度为 <code>O(1)</code></li>
</ol>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>创建一个大根堆和一个小根堆, 尽量保证两个堆中元素数量均为 <code>n/2</code> , 在添加元素时, 新元素若大于大根堆堆顶元素则放入小根堆, 若小于小根堆堆顶则放入大根堆, 这样即可保证前 <code>n/2</code> 个数都在大根堆中, 后 <code>n/2</code> 个数都在小根堆中, 中位数即为两堆的堆顶元素. 添加元素的同时确保小根堆的长度不小于大根堆, 若最后数据总数为奇数, 中位数即为小根堆堆顶元素; 若为偶数则为两堆堆顶元素和的一半.</p>
<p>添加新数的时间复杂度即为堆调整的时间复杂度, 即 <code>O(logN)</code> , 取得中位数的时间复杂度为 <code>O(1)</code></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        minHeap.add(num);</span><br><span class="line">        maxHeap.add(minHeap.poll());</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() &lt; maxHeap.size())</span><br><span class="line">            minHeap.add(maxHeap.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == minHeap.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (maxHeap.peek() + minHeap.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>heapq 中默认定义为小根堆, 通过保存相反数实现大根堆.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.max_heap = []</span><br><span class="line">        self.min_heap = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addNum</span>(<span class="params">self, num</span>):</span><br><span class="line">        heappush(self.min_heap, num)</span><br><span class="line">        heappush(self.max_heap, -heappop(self.min_heap))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.min_heap) &lt; <span class="built_in">len</span>(self.max_heap):</span><br><span class="line">            heappush(self.min_heap, -heappop(self.max_heap))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedian</span>(<span class="params">self</span>):</span><br><span class="line">        max_len = <span class="built_in">len</span>(self.max_heap)</span><br><span class="line">        min_len = <span class="built_in">len</span>(self.min_heap)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> min_len == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.min_heap[<span class="number">0</span>] <span class="keyword">if</span> max_len != min_len <span class="keyword">else</span> (-self.max_heap[<span class="number">0</span>] + self.min_heap[<span class="number">0</span>]) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>链表的中间结点</title>
    <url>/2020/03/01/MiddleNode/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-876"><a href="#题目-LeetCode-876" class="headerlink" title="题目 LeetCode # 876"></a>题目 <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">LeetCode # 876</a></h2><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p>示例 1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：此列表中的结点 <span class="number">3</span> (序列化形式：[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">返回的结点值为 <span class="number">3</span> (测评系统对该结点序列化表述是 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val = <span class="number">3</span>, ans.<span class="built_in">next</span>.val = <span class="number">4</span>, ans.<span class="built_in">next</span>.<span class="built_in">next</span>.val = <span class="number">5</span>, 以及 ans.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = NULL.</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：此列表中的结点 <span class="number">4</span> (序列化形式：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">由于该列表有两个中间结点，值分别为 <span class="number">3</span> 和 <span class="number">4</span>，我们返回第二个结点。</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>使用快慢指针, 快指针步长为 2, 慢指针步长为 1, 当快指针走到末尾时, 慢指针恰好走到中点. 循环的终止条件应为快指针的下个或下下个结点为空.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiddleNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fastPointer</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slowPointer</span> <span class="operator">=</span> head;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">        若要获取偶数长度链表中间结点中的前一个则改为:</span></span><br><span class="line"><span class="comment">        while (fastPointer.next != null &amp;&amp; fastPointer.next.next != null)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (fastPointer != <span class="literal">null</span> &amp;&amp; fastPointer.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fastPointer = fastPointer.next.next;</span><br><span class="line">            slowPointer = slowPointer.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slowPointer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">middle_node</span>(<span class="params">head</span>):</span><br><span class="line">    slow = fast = head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>最小栈问题</title>
    <url>/2020/02/11/MinStack/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>实现一个特殊的栈, 在实现栈的基本功能的基础上, 再实现返回栈中最小元素的操作</p>
<h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><ul>
<li>  <code>pop</code> 、<code>push</code> 、<code>getMin</code> 操作的时间复杂度均为 <code>O(1)</code></li>
<li>  可使用现成的栈结构</li>
</ul>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>若使用变量来保存最小值, 在进行多次出入栈操作之后无法保证 <code>getMin()</code> 返回值正确.</p>
<p>使用 <code>minStack</code> 来保存最小值栈, 入栈时若小于 <code>minStack</code> 栈顶元素则压入新元素; 若大于则再压入一个 <code>minStack</code> 栈顶元素.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> newEle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty()) &#123;</span><br><span class="line">            minStack.push(newEle);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEle &lt; getMin()) &#123;</span><br><span class="line">            minStack.push(newEle);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minStack.push(getMin());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dataStack.push(newEle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        minStack.pop();</span><br><span class="line">        <span class="keyword">return</span> dataStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Empty stack&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-LeetCode-155"><a href="#例题-LeetCode-155" class="headerlink" title="例题: LeetCode #155"></a>例题: <a href="https://leetcode-cn.com/problems/min-stack/">LeetCode #155</a></h3><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li><p>push(x) – 将元素 x 推入栈中。</p>
</li>
<li><p>pop() – 删除栈顶的元素。</p>
</li>
<li><p>top() – 获取栈顶元素。</p>
</li>
<li><p>getMin() – 检索栈中的最小元素。</p>
</li>
</ul>
<p>示例:</p>
<blockquote>
<p>  MinStack minStack = new MinStack();<br>  minStack.push(-2);<br>  minStack.push(0);<br>  minStack.push(-3);<br>  minStack.getMin();   –&gt; 返回 -3.<br>  minStack.pop();<br>  minStack.top();          –&gt; 返回 0.<br>  minStack.getMin();   –&gt; 返回 -2.</p>
</blockquote>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty()) &#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; getMin()) &#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minStack.push(getMin());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dataStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        minStack.pop();</span><br><span class="line">        dataStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Empty stack&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.data_stack = []</span><br><span class="line">        self.min_stack = []</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, new_ele</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.min_stack) == <span class="number">0</span>:</span><br><span class="line">            self.min_stack.append(new_ele)</span><br><span class="line">        <span class="keyword">elif</span> new_ele &lt; self.min_stack[-<span class="number">1</span>]:</span><br><span class="line">            self.min_stack.append(new_ele)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.min_stack.append(self.min_stack[-<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        self.data_stack.append(new_ele)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.data_stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.min_stack.pop()</span><br><span class="line">        self.data_stack.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data_stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.min_stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>切割金条问题</title>
    <url>/2020/06/08/MinimalCost/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一块金条切成两半, 是需要花费和长度数值一样的铜板的. 比如长度为 <code>20</code> 的 金条, 不管切成长度多大的两半, 都要花费 <code>20</code> 个铜板. 一群人想整分整块金条, 怎么分最省铜板?</p>
<p>例, 给定数组 <code>&#123;10,20,30&#125;</code>, 代表一共三个人, 整块金条长度为 <code>10</code> + <code>20</code> + <code>30</code> = <code>60</code> . 金条要分成 <code>10</code>, <code>20</code>, <code>30</code> 三个部分. </p>
<ul>
<li>  如果先把长度 <code>60</code> 的金条分成 <code>10</code> 和 <code>50</code> , 花费 <code>60</code> 再把长度 <code>50</code> 的金条分成 <code>20</code> 和 <code>30</code>, 花费 <code>50</code> ,  一共花费 <code>110</code> 铜板.</li>
<li>  如果先把长度 <code>60</code> 的金条分成 <code>30</code> 和 <code>30</code>, 花费 <code>60</code>  再把长度 <code>30</code> 金条分成 <code>10</code> 和 <code>20</code> ，花费 <code>30</code>  一共花费 <code>90</code> 铜板.</li>
</ul>
<p>输入一个数组, 返回分割的最小代价.</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200608181441.png"></p>
<p>如图, 该问题可看作哈夫曼树, 树中的叶结点即为最终的划分结果, 相当于给了叶结点, 求什么情况下非叶结点的和最小. 可采用贪心算法, 利用堆结构. 将所有节点存入小根堆中. 每次依次弹出两个元素, 求和, 并将和放回小根堆中, 循环计算即可得到最小值.</p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimalCost</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimalCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (priorityQueue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp1</span> <span class="operator">=</span> priorityQueue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp2</span> <span class="operator">=</span> priorityQueue.poll();</span><br><span class="line">            priorityQueue.add(tmp1 + tmp2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> priorityQueue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_minimal_cost</span>(<span class="params">result_list</span>):</span><br><span class="line">    heapify(result_list)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(result_list) != <span class="number">1</span>:</span><br><span class="line">        tmp1 = heappop(result_list)</span><br><span class="line">        tmp2 = heappop(result_list)</span><br><span class="line">        heappush(result_list, tmp1 + tmp2)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result_list[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>堆</tag>
        <tag>哈夫曼编码</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组最小路径和</title>
    <url>/2020/06/24/MinimalPathSum/</url>
    <content><![CDATA[<h3 id="题目-LeetCode-64"><a href="#题目-LeetCode-64" class="headerlink" title="题目 (LeetCode #64)"></a>题目 (<a href="https://leetcode-cn.com/problems/minimum-path-sum">LeetCode #64</a>)</h3><p>给定一个包含非负整数的 <code>m x n</code> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明:</strong> 每次只能向下或者向右移动一步。</p>
<p><strong>示例:</strong></p>
<p>输入:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>输出: 7</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><h5 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h5><p>从左上角到右下角, 每次移动只有向右或向下两种可能, 需递归地找出左右两个方向到右下角路径和较小者即可.</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200624102923.png"></p>
<p>暴力递归不记录子状态的结果, <code>F(E)</code> , <code>F(H)</code>, <code>F(F)</code> 进行了多次重复计算, 占用较多空间, 数据较多时会超时, 可改用计划搜索的方法进行优化.</p>
<h6 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimalPathSum</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length &lt; <span class="number">1</span> || grid[<span class="number">0</span>] == <span class="literal">null</span> || grid[<span class="number">0</span>].length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> process(grid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == grid.length - <span class="number">1</span> &amp;&amp; j == grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> grid[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == grid.length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> grid[i][j] + process(grid, i, j + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> grid[i][j] + process(grid, i + <span class="number">1</span>, j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid[i][j] + Math.min(process(grid, i, j + <span class="number">1</span>), process(grid, i + <span class="number">1</span>, j));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_minimal_path_sum</span>(<span class="params">grid</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="built_in">len</span>(grid) &lt; <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>] <span class="keyword">or</span> <span class="built_in">len</span>(grid[<span class="number">0</span>]) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> process(grid, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">grid, i, j</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(grid) - <span class="number">1</span> <span class="keyword">and</span> j == <span class="built_in">len</span>(grid[<span class="number">0</span>]) - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> grid[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(grid) - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> grid[i][j] + process(grid, i, j + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> j == <span class="built_in">len</span>(grid[<span class="number">0</span>]) - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> grid[i][j] + process(grid, i + <span class="number">1</span>, j)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grid[i][j] + <span class="built_in">min</span>(process(grid, i + <span class="number">1</span>, j), process(grid, i, j + <span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="计划搜索"><a href="#计划搜索" class="headerlink" title="计划搜索"></a>计划搜索</h5><p>将每个子状态的运算结果存入缓存中, 若之前计算过则直接返回计算结果.</p>
<h6 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimalPathSum</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> HashMap&lt;String, Integer&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minimalPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length &lt; <span class="number">1</span> || grid[<span class="number">0</span>] == <span class="literal">null</span> || grid[<span class="number">0</span>].length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> process(grid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> i + <span class="string">&quot;_&quot;</span> + j;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.get(key);	<span class="comment">// 存入 Map 时, 已经包含了 grid[i][j] 的值, 故不需重复加</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == grid.length - <span class="number">1</span> &amp;&amp; j == grid[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">            result = grid[i][j];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == grid.length - <span class="number">1</span>) &#123;</span><br><span class="line">            result = grid[i][j] + process(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == grid[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">            result = grid[i][j] + process(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = grid[i][j] + Math.min(process(grid, i + <span class="number">1</span>, j), process(grid, i, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cache.put(key, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinimalPathSum</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.result_dict = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_minimal_path_sum</span>(<span class="params">self, grid</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="built_in">len</span>(grid) &lt; <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>] <span class="keyword">or</span> <span class="built_in">len</span>(grid[<span class="number">0</span>]) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.result_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">return</span> self.process(grid, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">self, grid, i, j</span>):</span><br><span class="line">        key = <span class="built_in">str</span>(i) + <span class="string">&quot;_&quot;</span> + <span class="built_in">str</span>(j)</span><br><span class="line">        <span class="keyword">if</span> self.result_dict.get(key):</span><br><span class="line">            <span class="keyword">return</span> self.result_dict.get(key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(grid) - <span class="number">1</span> <span class="keyword">and</span> j == <span class="built_in">len</span>(grid[<span class="number">0</span>]) - <span class="number">1</span>:</span><br><span class="line">            result = grid[i][j]</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="built_in">len</span>(grid) - <span class="number">1</span>:</span><br><span class="line">            result = grid[i][j] + self.process(grid, i, j + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> j == <span class="built_in">len</span>(grid[<span class="number">0</span>]) - <span class="number">1</span>:</span><br><span class="line">            result = grid[i][j] + self.process(grid, i + <span class="number">1</span>, j)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = grid[i][j] + <span class="built_in">min</span>(self.process(grid, i + <span class="number">1</span>, j), self.process(grid, i, j + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        self.result_dict[key] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><p>左上角到右下角的最短距离与右下角到左上角最短距离相同, 为便于表示, 以下改为求右下角到左上角的最短距离.</p>
<p>由以上计划搜索部分知, 当矩阵中某点的位置即 <code>i</code> 和 <code>j</code> 的值确定时, 该点到左上角的最短路径就确定了, 故可单独求出矩阵中各元素到左上角的最短路径, 每个元素的最短路径值仅由其相邻的左边和上边元素决定, 其对应关系如下例, 故输出矩阵中的右下角即为左上角到右下角的最短距离.</p>
<p><strong>输入</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>	<span class="number">8</span>	<span class="number">6</span>	<span class="number">0</span>	<span class="number">5</span>	<span class="number">9</span>	<span class="number">9</span>	<span class="number">6</span>	<span class="number">3</span>	<span class="number">4</span>	<span class="number">0</span>	<span class="number">5</span>	<span class="number">7</span>	<span class="number">3</span>	<span class="number">9</span>	<span class="number">3</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">9</span>	<span class="number">2</span>	<span class="number">5</span>	<span class="number">5</span>	<span class="number">4</span>	<span class="number">9</span>	<span class="number">1</span>	<span class="number">4</span>	<span class="number">6</span>	<span class="number">9</span>	<span class="number">5</span>	<span class="number">6</span>	<span class="number">7</span>	<span class="number">3</span>	<span class="number">2</span>	</span><br><span class="line"><span class="number">8</span>	<span class="number">2</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">3</span>	<span class="number">3</span>	<span class="number">1</span>	<span class="number">6</span>	<span class="number">9</span>	<span class="number">1</span>	<span class="number">1</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">2</span>	<span class="number">1</span>	<span class="number">9</span>	</span><br><span class="line"><span class="number">1</span>	<span class="number">3</span>	<span class="number">6</span>	<span class="number">9</span>	<span class="number">9</span>	<span class="number">5</span>	<span class="number">0</span>	<span class="number">3</span>	<span class="number">4</span>	<span class="number">9</span>	<span class="number">1</span>	<span class="number">0</span>	<span class="number">9</span>	<span class="number">6</span>	<span class="number">2</span>	<span class="number">7</span>	</span><br><span class="line"><span class="number">8</span>	<span class="number">6</span>	<span class="number">2</span>	<span class="number">2</span>	<span class="number">1</span>	<span class="number">3</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">7</span>	<span class="number">2</span>	<span class="number">7</span>	<span class="number">5</span>	<span class="number">4</span>	<span class="number">8</span>	<span class="number">4</span>	<span class="number">8</span>	</span><br><span class="line"><span class="number">4</span>	<span class="number">1</span>	<span class="number">9</span>	<span class="number">5</span>	<span class="number">8</span>	<span class="number">9</span>	<span class="number">9</span>	<span class="number">2</span>	<span class="number">0</span>	<span class="number">2</span>	<span class="number">5</span>	<span class="number">1</span>	<span class="number">8</span>	<span class="number">7</span>	<span class="number">0</span>	<span class="number">9</span>	</span><br><span class="line"><span class="number">6</span>	<span class="number">2</span>	<span class="number">1</span>	<span class="number">7</span>	<span class="number">8</span>	<span class="number">1</span>	<span class="number">8</span>	<span class="number">5</span>	<span class="number">5</span>	<span class="number">7</span>	<span class="number">0</span>	<span class="number">2</span>	<span class="number">5</span>	<span class="number">7</span>	<span class="number">2</span>	<span class="number">1</span>	</span><br><span class="line"><span class="number">8</span>	<span class="number">1</span>	<span class="number">7</span>	<span class="number">6</span>	<span class="number">2</span>	<span class="number">8</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">2</span>	<span class="number">6</span>	<span class="number">4</span>	<span class="number">0</span>	<span class="number">5</span>	<span class="number">4</span>	<span class="number">1</span>	<span class="number">3</span>	</span><br><span class="line"><span class="number">9</span>	<span class="number">2</span>	<span class="number">1</span>	<span class="number">7</span>	<span class="number">6</span>	<span class="number">1</span>	<span class="number">4</span>	<span class="number">3</span>	<span class="number">8</span>	<span class="number">6</span>	<span class="number">5</span>	<span class="number">5</span>	<span class="number">3</span>	<span class="number">9</span>	<span class="number">7</span>	<span class="number">3</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">6</span>	<span class="number">0</span>	<span class="number">2</span>	<span class="number">4</span>	<span class="number">3</span>	<span class="number">7</span>	<span class="number">6</span>	<span class="number">1</span>	<span class="number">3</span>	<span class="number">8</span>	<span class="number">6</span>	<span class="number">9</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">8</span>	</span><br><span class="line"><span class="number">4</span>	<span class="number">3</span>	<span class="number">7</span>	<span class="number">2</span>	<span class="number">4</span>	<span class="number">3</span>	<span class="number">6</span>	<span class="number">4</span>	<span class="number">0</span>	<span class="number">3</span>	<span class="number">9</span>	<span class="number">5</span>	<span class="number">3</span>	<span class="number">6</span>	<span class="number">9</span>	<span class="number">3</span>	</span><br><span class="line"><span class="number">2</span>	<span class="number">1</span>	<span class="number">8</span>	<span class="number">8</span>	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span>	<span class="number">5</span>	<span class="number">8</span>	<span class="number">7</span>	<span class="number">3</span>	<span class="number">7</span>	<span class="number">7</span>	<span class="number">5</span>	<span class="number">8</span>	<span class="number">3</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">7</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">0</span>	<span class="number">3</span>	<span class="number">5</span>	<span class="number">0</span>	<span class="number">8</span>	<span class="number">0</span>	<span class="number">8</span>	<span class="number">7</span>	<span class="number">4</span>	<span class="number">3</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">4</span>	<span class="number">3</span>	<span class="number">4</span>	<span class="number">9</span>	<span class="number">0</span>	<span class="number">1</span>	<span class="number">9</span>	<span class="number">7</span>	<span class="number">7</span>	<span class="number">8</span>	<span class="number">6</span>	<span class="number">4</span>	<span class="number">6</span>	<span class="number">9</span>	<span class="number">5</span>	</span><br><span class="line"><span class="number">6</span>	<span class="number">5</span>	<span class="number">1</span>	<span class="number">9</span>	<span class="number">9</span>	<span class="number">2</span>	<span class="number">2</span>	<span class="number">7</span>	<span class="number">4</span>	<span class="number">2</span>	<span class="number">7</span>	<span class="number">2</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">7</span>	<span class="number">2</span>	</span><br><span class="line"><span class="number">7</span>	<span class="number">1</span>	<span class="number">9</span>	<span class="number">6</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">7</span>	<span class="number">0</span>	<span class="number">9</span>	<span class="number">6</span>	<span class="number">6</span>	<span class="number">4</span>	<span class="number">4</span>	<span class="number">5</span>	<span class="number">1</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">3</span>	<span class="number">4</span>	<span class="number">9</span>	<span class="number">2</span>	<span class="number">8</span>	<span class="number">3</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">6</span>	<span class="number">9</span>	<span class="number">7</span>	<span class="number">0</span>	<span class="number">2</span>	<span class="number">4</span>	<span class="number">2</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">5</span>	<span class="number">1</span>	<span class="number">8</span>	<span class="number">8</span>	<span class="number">4</span>	<span class="number">6</span>	<span class="number">8</span>	<span class="number">5</span>	<span class="number">2</span>	<span class="number">4</span>	<span class="number">1</span>	<span class="number">6</span>	<span class="number">2</span>	<span class="number">2</span>	<span class="number">9</span>	<span class="number">7</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>	<span class="number">11</span>	<span class="number">17</span>	<span class="number">17</span>	<span class="number">22</span>	<span class="number">31</span>	<span class="number">40</span>	<span class="number">46</span>	<span class="number">49</span>	<span class="number">53</span>	<span class="number">53</span>	<span class="number">58</span>	<span class="number">65</span>	<span class="number">68</span>	<span class="number">77</span>	<span class="number">80</span>	</span><br><span class="line"><span class="number">3</span>	<span class="number">12</span>	<span class="number">14</span>	<span class="number">19</span>	<span class="number">24</span>	<span class="number">28</span>	<span class="number">37</span>	<span class="number">38</span>	<span class="number">42</span>	<span class="number">48</span>	<span class="number">57</span>	<span class="number">62</span>	<span class="number">68</span>	<span class="number">75</span>	<span class="number">78</span>	<span class="number">80</span>	</span><br><span class="line"><span class="number">11</span>	<span class="number">13</span>	<span class="number">15</span>	<span class="number">18</span>	<span class="number">21</span>	<span class="number">24</span>	<span class="number">25</span>	<span class="number">31</span>	<span class="number">40</span>	<span class="number">41</span>	<span class="number">42</span>	<span class="number">48</span>	<span class="number">54</span>	<span class="number">56</span>	<span class="number">57</span>	<span class="number">66</span>	</span><br><span class="line"><span class="number">12</span>	<span class="number">15</span>	<span class="number">21</span>	<span class="number">27</span>	<span class="number">30</span>	<span class="number">29</span>	<span class="number">25</span>	<span class="number">28</span>	<span class="number">32</span>	<span class="number">41</span>	<span class="number">42</span>	<span class="number">42</span>	<span class="number">51</span>	<span class="number">57</span>	<span class="number">59</span>	<span class="number">66</span>	</span><br><span class="line"><span class="number">20</span>	<span class="number">21</span>	<span class="number">23</span>	<span class="number">25</span>	<span class="number">26</span>	<span class="number">29</span>	<span class="number">25</span>	<span class="number">25</span>	<span class="number">32</span>	<span class="number">34</span>	<span class="number">41</span>	<span class="number">46</span>	<span class="number">50</span>	<span class="number">58</span>	<span class="number">62</span>	<span class="number">70</span>	</span><br><span class="line"><span class="number">24</span>	<span class="number">22</span>	<span class="number">31</span>	<span class="number">30</span>	<span class="number">34</span>	<span class="number">38</span>	<span class="number">34</span>	<span class="number">27</span>	<span class="number">27</span>	<span class="number">29</span>	<span class="number">34</span>	<span class="number">35</span>	<span class="number">43</span>	<span class="number">50</span>	<span class="number">50</span>	<span class="number">59</span>	</span><br><span class="line"><span class="number">30</span>	<span class="number">24</span>	<span class="number">25</span>	<span class="number">32</span>	<span class="number">40</span>	<span class="number">39</span>	<span class="number">42</span>	<span class="number">32</span>	<span class="number">32</span>	<span class="number">36</span>	<span class="number">34</span>	<span class="number">36</span>	<span class="number">41</span>	<span class="number">48</span>	<span class="number">50</span>	<span class="number">51</span>	</span><br><span class="line"><span class="number">38</span>	<span class="number">25</span>	<span class="number">32</span>	<span class="number">38</span>	<span class="number">40</span>	<span class="number">47</span>	<span class="number">43</span>	<span class="number">34</span>	<span class="number">34</span>	<span class="number">40</span>	<span class="number">38</span>	<span class="number">36</span>	<span class="number">41</span>	<span class="number">45</span>	<span class="number">46</span>	<span class="number">49</span>	</span><br><span class="line"><span class="number">47</span>	<span class="number">27</span>	<span class="number">28</span>	<span class="number">35</span>	<span class="number">41</span>	<span class="number">42</span>	<span class="number">46</span>	<span class="number">37</span>	<span class="number">42</span>	<span class="number">46</span>	<span class="number">43</span>	<span class="number">41</span>	<span class="number">44</span>	<span class="number">53</span>	<span class="number">53</span>	<span class="number">52</span>	</span><br><span class="line"><span class="number">47</span>	<span class="number">33</span>	<span class="number">28</span>	<span class="number">30</span>	<span class="number">34</span>	<span class="number">37</span>	<span class="number">44</span>	<span class="number">43</span>	<span class="number">43</span>	<span class="number">46</span>	<span class="number">51</span>	<span class="number">47</span>	<span class="number">53</span>	<span class="number">53</span>	<span class="number">53</span>	<span class="number">60</span>	</span><br><span class="line"><span class="number">51</span>	<span class="number">36</span>	<span class="number">35</span>	<span class="number">32</span>	<span class="number">36</span>	<span class="number">39</span>	<span class="number">45</span>	<span class="number">47</span>	<span class="number">43</span>	<span class="number">46</span>	<span class="number">55</span>	<span class="number">52</span>	<span class="number">55</span>	<span class="number">59</span>	<span class="number">62</span>	<span class="number">63</span>	</span><br><span class="line"><span class="number">53</span>	<span class="number">37</span>	<span class="number">43</span>	<span class="number">40</span>	<span class="number">40</span>	<span class="number">44</span>	<span class="number">50</span>	<span class="number">52</span>	<span class="number">51</span>	<span class="number">53</span>	<span class="number">56</span>	<span class="number">59</span>	<span class="number">62</span>	<span class="number">64</span>	<span class="number">70</span>	<span class="number">66</span>	</span><br><span class="line"><span class="number">53</span>	<span class="number">44</span>	<span class="number">49</span>	<span class="number">46</span>	<span class="number">41</span>	<span class="number">43</span>	<span class="number">43</span>	<span class="number">46</span>	<span class="number">51</span>	<span class="number">51</span>	<span class="number">59</span>	<span class="number">59</span>	<span class="number">67</span>	<span class="number">71</span>	<span class="number">74</span>	<span class="number">69</span>	</span><br><span class="line"><span class="number">53</span>	<span class="number">48</span>	<span class="number">51</span>	<span class="number">50</span>	<span class="number">50</span>	<span class="number">43</span>	<span class="number">44</span>	<span class="number">53</span>	<span class="number">58</span>	<span class="number">58</span>	<span class="number">66</span>	<span class="number">65</span>	<span class="number">69</span>	<span class="number">75</span>	<span class="number">83</span>	<span class="number">74</span>	</span><br><span class="line"><span class="number">59</span>	<span class="number">53</span>	<span class="number">52</span>	<span class="number">59</span>	<span class="number">59</span>	<span class="number">45</span>	<span class="number">46</span>	<span class="number">53</span>	<span class="number">57</span>	<span class="number">59</span>	<span class="number">66</span>	<span class="number">67</span>	<span class="number">69</span>	<span class="number">72</span>	<span class="number">79</span>	<span class="number">76</span>	</span><br><span class="line"><span class="number">66</span>	<span class="number">54</span>	<span class="number">61</span>	<span class="number">65</span>	<span class="number">60</span>	<span class="number">47</span>	<span class="number">53</span>	<span class="number">53</span>	<span class="number">62</span>	<span class="number">65</span>	<span class="number">71</span>	<span class="number">71</span>	<span class="number">73</span>	<span class="number">77</span>	<span class="number">78</span>	<span class="number">76</span>	</span><br><span class="line"><span class="number">69</span>	<span class="number">58</span>	<span class="number">67</span>	<span class="number">67</span>	<span class="number">68</span>	<span class="number">50</span>	<span class="number">51</span>	<span class="number">53</span>	<span class="number">59</span>	<span class="number">68</span>	<span class="number">75</span>	<span class="number">71</span>	<span class="number">73</span>	<span class="number">77</span>	<span class="number">79</span>	<span class="number">76</span>	</span><br><span class="line"><span class="number">74</span>	<span class="number">59</span>	<span class="number">67</span>	<span class="number">75</span>	<span class="number">72</span>	<span class="number">56</span>	<span class="number">59</span>	<span class="number">58</span>	<span class="number">60</span>	<span class="number">64</span>	<span class="number">65</span>	<span class="number">71</span>	<span class="number">73</span>	<span class="number">75</span>	<span class="number">84</span>	<span class="number">83</span></span><br></pre></td></tr></table></figure>

<h6 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimalPathSum</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dynamicProgramming</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length &lt; <span class="number">1</span> || grid[<span class="number">0</span>] == <span class="literal">null</span> || grid[<span class="number">0</span>].length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">column</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][column];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; column; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; column; j++) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; column; j++) &#123;</span><br><span class="line">                System.out.print(dp[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[row - <span class="number">1</span>][column - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Python-2"><a href="#Python-2" class="headerlink" title="Python"></a>Python</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinimalPathSum</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dynamic_programming</span>(<span class="params">grid</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="built_in">len</span>(grid) &lt; <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>] <span class="keyword">or</span> <span class="built_in">len</span>(grid[<span class="number">0</span>]) &lt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        row = <span class="built_in">len</span>(grid)</span><br><span class="line">        column = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>] * column <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, row):</span><br><span class="line">            dp[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, column):</span><br><span class="line">            dp[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j] + dp[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, column):</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[row - <span class="number">1</span>][column - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2020/06/22/MinimumSpanningTree/</url>
    <content><![CDATA[<p>最小生成树是一副连通加权无向图中一棵权值最小的生成树。一个连通图可能有多个生成树。当图中的边具有权值时，总会有一个生成树的边的权值之和小于或者等于其它生成树的边的权值之和 (<a href="%5Bhttps://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%5D(https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91)">Wikipedia</a>)。</p>
<p>常见算法有 Kruskal 算法和 Prim 算法</p>
<h4 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h4><p>按照边的权重顺序（从小到大）将边加入生成树中，但是若加入该边会与生成树形成环则不加入该边。直到树中含有顶点数减一条边为止。这些边组成的就是该图的最小生成树。</p>
<p>实现过程中, 可利用小根堆来依次返回权重最小的边, 利用<a href="https://zcybupt.github.io/post/UnionFind/">并查集</a>来避免生成树形成回路.</p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><p><strong>UnionFind</strong> 定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;GraphNode, GraphNode&gt; parentMap;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;GraphNode, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(Collection&lt;GraphNode&gt; nodes)</span> &#123;</span><br><span class="line">        parentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        sizeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化并查集, 此时每个结点自成一个集合, 指针指向它本身</span></span><br><span class="line">        <span class="keyword">for</span> (GraphNode node : nodes) &#123;</span><br><span class="line">            parentMap.put(node, node);</span><br><span class="line">            sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到代表结点并整理结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代表结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> GraphNode <span class="title function_">findHead</span><span class="params">(GraphNode node)</span> &#123;</span><br><span class="line">        <span class="type">GraphNode</span> <span class="variable">parent</span> <span class="operator">=</span> parentMap.get(node);</span><br><span class="line">        <span class="keyword">if</span> (parent != node) &#123;</span><br><span class="line">            parent = findHead(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parentMap.put(node, parent);    <span class="comment">// 整理结点</span></span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(GraphNode node1, GraphNode node2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findHead(node1) == findHead(node2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(GraphNode a, GraphNode b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">GraphNode</span> <span class="variable">aHead</span> <span class="operator">=</span> findHead(a);</span><br><span class="line">        <span class="type">GraphNode</span> <span class="variable">bHead</span> <span class="operator">=</span> findHead(b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aHead == bHead)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">aSetSize</span> <span class="operator">=</span> sizeMap.get(aHead);</span><br><span class="line">        <span class="type">int</span> <span class="variable">bSetSize</span> <span class="operator">=</span> sizeMap.get(bHead);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aSetSize &lt;= bSetSize) &#123;</span><br><span class="line">            parentMap.put(aHead, bHead);</span><br><span class="line">            sizeMap.put(bHead, aSetSize + bSetSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parentMap.put(bHead, aHead);</span><br><span class="line">            sizeMap.put(aHead, aSetSize + bSetSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Kruskal</strong> 实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KruskalMST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title function_">kruskalMST</span><span class="params">(Graph graph)</span> &#123;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">unionFind</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(graph.nodes.values());</span><br><span class="line">        PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a.weight - b.weight;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        priorityQueue.addAll(graph.edges);</span><br><span class="line"></span><br><span class="line">        Set&lt;Edge&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> priorityQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!unionFind.isSameSet(edge.from, edge.to)) &#123;</span><br><span class="line">                result.add(edge);</span><br><span class="line">                unionFind.union(edge.from, edge.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><p><code>UnionFindSet</code> 定义见<a href="https://zcybupt.github.io/post/UnionFind/#python">并查集</a></p>
<p>由于 <code>Edge</code> 对象不能够直接比较大小, 需重写 <code>Edge</code> 的比较函数, <code>__lt__</code> 对应 <code>&lt;</code> , <code>__gt__</code> 对应 <code>&gt;</code> , 只重写其中一个, 另一个会自动取反. 比较相等时结果相同.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, weight, from_node, to_node</span>):</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.from_node = from_node</span><br><span class="line">        self.to_node = to_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="comment"># 重写 &lt; 比较函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> self.weight &lt; other.weight <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p><strong>Kruskal 实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">kruskal_mst</span>(<span class="params">graph</span>):</span><br><span class="line">    union_find_set = UnionFindSet(graph.nodes.values())</span><br><span class="line">    heap = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> graph.edges:</span><br><span class="line">        heappush(heap, edge)</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> heap:</span><br><span class="line">        edge = heappop(heap)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> union_find_set.is_same_set(edge.from_node, edge.to_node):</span><br><span class="line">            result.add(edge)</span><br><span class="line">            union_find_set.union(edge.from_node, edge.to_node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h4><p>从任意一个节点开始, 将与其相连的几条边全部放入一个小根堆中, 每次弹出小根堆中权重最小的边, 获取该边的另一端节点放入集合中, 并将另一端节点的所有直接相连的边放入小根堆中, 迭代直到小根堆中的边全部取出为止.</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200623110909.png"></p>
<h5 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimMST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title function_">primMST</span><span class="params">(Graph graph)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a.weight - b.weight;</span><br><span class="line">        &#125;);</span><br><span class="line">        HashSet&lt;GraphNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Edge&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 遍历所有节点, 考虑到可能有多棵生成树不相连的情况</span></span><br><span class="line">        <span class="keyword">for</span> (GraphNode node : graph.nodes.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(node)) &#123;</span><br><span class="line">                set.add(node);</span><br><span class="line">                priorityQueue.addAll(node.edges);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> priorityQueue.poll();</span><br><span class="line">                    <span class="type">GraphNode</span> <span class="variable">toNode</span> <span class="operator">=</span> edge.to;</span><br><span class="line">                    <span class="keyword">if</span> (!set.contains(toNode)) &#123;</span><br><span class="line">                        set.add(toNode);</span><br><span class="line">                        result.add(edge);</span><br><span class="line">                        priorityQueue.addAll(toNode.edges);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Prim 算法需沿着边迭代加入点, 故建立无向图时需建立双向指针</span></span><br><span class="line">        Integer[][] nodes = &#123;</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>&#125;, &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>&#125;, &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> Code_26_GraphBuilder.createGraph(nodes);</span><br><span class="line">        Set&lt;Edge&gt; result = primMST(graph);</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : result) &#123;</span><br><span class="line">            System.out.println(edge.weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h5 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">prim_mst</span>(<span class="params">graph</span>):</span><br><span class="line">    edge_heap = []</span><br><span class="line">    node_set = <span class="built_in">set</span>()</span><br><span class="line">    result = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph.nodes.values():</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> node_set:</span><br><span class="line">            node_set.add(node)</span><br><span class="line">            <span class="keyword">for</span> edge <span class="keyword">in</span> node.edges:</span><br><span class="line">                heappush(edge_heap, edge)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> edge_heap:</span><br><span class="line">                edge = heappop(edge_heap)</span><br><span class="line">                to_node = edge.to_node</span><br><span class="line">                <span class="keyword">if</span> to_node <span class="keyword">not</span> <span class="keyword">in</span> node_set:</span><br><span class="line">                    node_set.add(to_node)</span><br><span class="line">                    result.add(edge)</span><br><span class="line">                    <span class="keyword">for</span> next_edge <span class="keyword">in</span> to_node.edges:</span><br><span class="line">                        heappush(edge_heap, next_edge)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Morris遍历</title>
    <url>/2020/07/26/MorrisTraversal/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>无论是手动创建栈遍历树还是递归（即调用系统栈）遍历树，其空间复杂度均为 <code>O(N)</code> ，而 Morris 实现了 <code>O(1)</code> 常数空间复杂度的树的遍历。</p>
<p>递归遍历树的过程中，每个节点均被遍历了三次，前中后序取决于打印的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursiveTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recursiveTraverse</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先序遍历</span></span><br><span class="line">        <span class="comment">// System.out.println(head.val);</span></span><br><span class="line"></span><br><span class="line">        recursiveTraverse(head.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        <span class="comment">// System.out.println(head.val);</span></span><br><span class="line">        </span><br><span class="line">        recursiveTraverse(head.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        <span class="comment">// System.out.println(head.val);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Morris 遍历实质上是人为地追踪递归过程中遍历位置的变化。其过程如下：</p>
<p>设 <code>cur</code> 为当前节点。</p>
<ol>
<li> 若 <code>cur</code> 无左子树，<code>cur</code> 向右移动</li>
<li>若 <code>cur</code> 有左子树，找到左子树上最右节点，记为 <code>rightmost</code><ol>
<li>若 <code>rightmost</code> 的右孩子为 <code>null</code> ，<code>rightmost.right = cur</code> ，<code>cur</code> 向左移动</li>
<li>若 <code>rightmost</code> 的右孩子为 <code>cur</code> ，<code>rightmost.right = null</code> ，<code>cur</code> 向右移动</li>
</ol>
</li>
</ol>
<ul>
<li><p>  若某节点有左子树，则该节点将被遍历两次（即 <code>2.2</code> ），若没有左子树则将被遍历一次；</p>
</li>
<li><p>在第二遍历某节点时，当前节点总是该节点左子树的 <code>rightmost</code> 的后继（节点的后继指中序遍历输出结果的后续节点）</p>
</li>
<li><p>  通过 <code>rightmost</code> 的右孩子的指向来判断是第一次还是第二次遍历到当前节点。</p>
</li>
</ul>
<p>下图为每一步迭代的结果（从左至右，从上到下），cur代表当前节点，深色节点表示该节点已输出。（图源：<a href="https://www.cnblogs.com/anniekim/archive/2013/06/15/morristraversal.html">AnnieKim</a>）</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200727191413.png"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>第一次到达一个节点时就输出。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MorrisTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morrisPreorderTraverse</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur2 = cur1.left;</span><br><span class="line">            <span class="keyword">if</span> (cur2 != <span class="literal">null</span>) &#123;                       <span class="comment">// cur1 有左子树</span></span><br><span class="line">                <span class="keyword">while</span> (cur2.right != <span class="literal">null</span> &amp;&amp; cur2.right != cur1) &#123;</span><br><span class="line">                    cur2 = cur2.right;                <span class="comment">// 左子树上最右节点, 此时 cur2 即为 rightmost</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur2.right == <span class="literal">null</span>) &#123;             <span class="comment">// rightmost 的右孩子为空, 此时为第一次遍历当前节点</span></span><br><span class="line">                    cur2.right = cur1;</span><br><span class="line">                    System.out.print(cur1.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 第一次遍历一个节点, 打印该节点</span></span><br><span class="line">                    cur1 = cur1.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur2.right = <span class="literal">null</span>;                <span class="comment">// rightmost 的右孩子指向 cur1, 此时为第二次遍历当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(cur1.val + <span class="string">&quot; &quot;</span>);     <span class="comment">// 节点无左子树, 只会遍历一遍, 故直接输出</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.right;                        <span class="comment">// cur1 无左子树或 rightmost 的右孩子指向 cur1 时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">morris_preorder_traverse</span>(<span class="params">head: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    cur1 = head</span><br><span class="line">    <span class="keyword">while</span> cur1:</span><br><span class="line">        cur2 = cur1.left</span><br><span class="line">        <span class="keyword">if</span> cur2:</span><br><span class="line">            <span class="keyword">while</span> cur2.right <span class="keyword">and</span> cur2.right != cur1:</span><br><span class="line">                cur2 = cur2.right</span><br><span class="line">            <span class="keyword">if</span> cur2.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur2.right = cur1</span><br><span class="line">                <span class="built_in">print</span>(cur1.val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">                cur1 = cur1.left</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur2.right = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(cur1.val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        cur1 = cur1.right</span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	val   <span class="type">int</span></span><br><span class="line">	left  *TreeNode</span><br><span class="line">	right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">morrisPreorderTraverse</span><span class="params">(head *TreeNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cur1 := head</span><br><span class="line">	<span class="keyword">var</span> cur2 *TreeNode</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> cur1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		cur2 = cur1.left</span><br><span class="line">		<span class="keyword">if</span> cur2 != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> cur2.right != <span class="literal">nil</span> &amp;&amp; cur2.right != cur1 &#123;</span><br><span class="line">				cur2 = cur2.right</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> cur2.right == <span class="literal">nil</span> &#123;</span><br><span class="line">				cur2.right = cur1</span><br><span class="line">				fmt.Printf(<span class="string">&quot;%d &quot;</span>, cur1.val)</span><br><span class="line">				cur1 = cur1.left</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				cur2.right = <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d &quot;</span>, cur1.val)</span><br><span class="line">		&#125;</span><br><span class="line">		cur1 = cur1.right</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>有左子树的节点第二次回到该节点时再打印；无左子树的节点只会遍历一次，故直接输出。如下图输出顺序为 <code>2 1 3</code> 。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200727220729.png"></p>
<p>当前节点无左子树或第二次遍历当前节点（即 <code>rightmost</code> 的右孩子指向 <code>cur1</code>）时均需输出当前节点值，而只有这两种情况需将指针右移，故可理解为只要向右移动就输出。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MorrisTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morrisInOrderTraverse</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur2 = cur1.left;</span><br><span class="line">            <span class="keyword">if</span> (cur2 != <span class="literal">null</span>) &#123;               <span class="comment">// cur1 有左子树</span></span><br><span class="line">                <span class="keyword">while</span> (cur2.right != <span class="literal">null</span> &amp;&amp; cur2.right != cur1) &#123;</span><br><span class="line">                    cur2 = cur2.right;        <span class="comment">// 左子树上最右节点, 此时 cur2 即为 rightmost</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur2.right == <span class="literal">null</span>) &#123;     <span class="comment">// rightmost 的右孩子为空, 此时为第一次遍历当前节点</span></span><br><span class="line">                    cur2.right = cur1;</span><br><span class="line">                    cur1 = cur1.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur2.right = <span class="literal">null</span>;        <span class="comment">// rightmost 的右孩子指向 cur1, 此时为第二次遍历当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(cur1.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 当前节点无左子树或第二次遍历当前节点</span></span><br><span class="line">            cur1 = cur1.right;                <span class="comment">// cur1 无左子树或 rightmost 的右孩子指向 cur1 时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">morris_in_order_traverse</span>(<span class="params">head: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    cur1 = head</span><br><span class="line">    <span class="keyword">while</span> cur1:</span><br><span class="line">        cur2 = cur1.left</span><br><span class="line">        <span class="keyword">if</span> cur2:</span><br><span class="line">            <span class="keyword">while</span> cur2.right <span class="keyword">and</span> cur2.right != cur1:</span><br><span class="line">                cur2 = cur2.right</span><br><span class="line">            <span class="keyword">if</span> cur2.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur2.right = cur1</span><br><span class="line">                cur1 = cur1.left</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur2.right = <span class="literal">None</span></span><br><span class="line">        <span class="built_in">print</span>(cur1.val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        cur1 = cur1.right</span><br></pre></td></tr></table></figure>

<h4 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">morrisInOrderTraverse</span><span class="params">(head *TreeNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cur1 := head</span><br><span class="line">	<span class="keyword">var</span> cur2 *TreeNode</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> cur1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		cur2 = cur1.left</span><br><span class="line">		<span class="keyword">if</span> cur2 != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> cur2.right != <span class="literal">nil</span> &amp;&amp; cur2.right != cur1 &#123;</span><br><span class="line">				cur2 = cur2.right</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> cur2.right == <span class="literal">nil</span> &#123;</span><br><span class="line">				cur2.right = cur1</span><br><span class="line">				cur1 = cur1.left</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				cur2.right = <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, cur1.val)</span><br><span class="line">		cur1 = cur1.right</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>第二次遍历到某节点时，逆序打印其左子树的右边界。遍历完后再逆序打印整棵树的右边界即为后序遍历。</p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MorrisTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morrisPostOrderTraverse</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur2 = cur1.left;</span><br><span class="line">            <span class="keyword">if</span> (cur2 != <span class="literal">null</span>) &#123;             <span class="comment">// cur1 有左子树</span></span><br><span class="line">                <span class="keyword">while</span> (cur2.right != <span class="literal">null</span> &amp;&amp; cur2.right != cur1) &#123;</span><br><span class="line">                    cur2 = cur2.right;      <span class="comment">// 左子树上最右节点, 此时 cur2 即为 rightmost</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur2.right == <span class="literal">null</span>) &#123;   <span class="comment">// rightmost 的右孩子为空, 此时为第一次遍历当前节点</span></span><br><span class="line">                    cur2.right = cur1;</span><br><span class="line">                    cur1 = cur1.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur2.right = <span class="literal">null</span>;      <span class="comment">// rightmost 的右孩子指向 cur1, 此时为第二次遍历当前节点</span></span><br><span class="line">                    printEdge(cur1.left);   <span class="comment">// 第二次遍历到该节点, 打印左子树的右边界</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.right;              <span class="comment">// cur1 无左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        printEdge(head);                    <span class="comment">// 打印整棵树的右边界</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printEdge</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tail</span> <span class="operator">=</span> reverseEdge(head);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        recursiveTraverse(tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">reverseEdge</span><span class="params">(TreeNode from)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (from != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = from.right;</span><br><span class="line">            from.right = pre;</span><br><span class="line">            pre = from;</span><br><span class="line">            from = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python-2"><a href="#Python-2" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">morris_post_order_traverse</span>(<span class="params">head: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    cur1 = head</span><br><span class="line">    <span class="keyword">while</span> cur1:</span><br><span class="line">        cur2 = cur1.left</span><br><span class="line">        <span class="keyword">if</span> cur2:</span><br><span class="line">            <span class="keyword">while</span> cur2.right <span class="keyword">and</span> cur2.right != cur1:</span><br><span class="line">                cur2 = cur2.right</span><br><span class="line">            <span class="keyword">if</span> cur2.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur2.right = cur1</span><br><span class="line">                cur1 = cur1.left</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur2.right = <span class="literal">None</span></span><br><span class="line">                print_edge(cur1.left)</span><br><span class="line">        cur1 = cur1.right</span><br><span class="line">    print_edge(head)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_edge</span>(<span class="params">head: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    tail = reverse_edge(head)</span><br><span class="line">    cur = tail</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="built_in">print</span>(cur.val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        cur = cur.right</span><br><span class="line"></span><br><span class="line">    reverse_edge(tail)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_edge</span>(<span class="params">head: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        rear = head.right</span><br><span class="line">        head.right = pre</span><br><span class="line">        pre = head</span><br><span class="line">        head = rear</span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<h4 id="Go-2"><a href="#Go-2" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">morrisPostOrderTraverse</span><span class="params">(head *TreeNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cur1 := head</span><br><span class="line">	<span class="keyword">var</span> cur2 *TreeNode</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> cur1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		cur2 = cur1.left</span><br><span class="line">		<span class="keyword">if</span> cur2 != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> cur2.right != <span class="literal">nil</span> &amp;&amp; cur2.right != cur1 &#123;</span><br><span class="line">				cur2 = cur2.right</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> cur2.right == <span class="literal">nil</span> &#123;</span><br><span class="line">				cur2.right = cur1</span><br><span class="line">				cur1 = cur1.left</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				cur2.right = <span class="literal">nil</span></span><br><span class="line">				printEdge(cur1.left)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cur1 = cur1.right</span><br><span class="line">	&#125;</span><br><span class="line">	printEdge(head)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printEdge</span><span class="params">(head *TreeNode)</span></span> &#123;</span><br><span class="line">	tail := reverseEdge(head)</span><br><span class="line">	cur := tail</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, cur.val)</span><br><span class="line">		cur = cur.right</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reverseEdge(tail)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseEdge</span><span class="params">(head *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">var</span> pre *TreeNode</span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := head.right</span><br><span class="line">		head.right = pre</span><br><span class="line">		pre = head</span><br><span class="line">		head = next</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据流中的移动平均值</title>
    <url>/2022/01/15/MovingAverage/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-346"><a href="#题目-LeetCode-346" class="headerlink" title="题目(LeetCode #346)"></a>题目(LeetCode #346)</h2><p>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.</p>
<p>Example:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MovingAverage</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MovingAverage</span>(<span class="number">3</span>);</span><br><span class="line">m.next(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">m.next(<span class="number">10</span>) = (<span class="number">1</span> + <span class="number">10</span>) / <span class="number">2</span></span><br><span class="line">m.next(<span class="number">3</span>) = (<span class="number">1</span> + <span class="number">10</span> + <span class="number">3</span>) / <span class="number">3</span></span><br><span class="line">m.next(<span class="number">5</span>) = (<span class="number">10</span> + <span class="number">3</span> + <span class="number">5</span>) / <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>可使用固定大小的队列实现滑动窗口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovingAverage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> previousSum;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovingAverage</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.size() == maxSize)</span><br><span class="line">            previousSum -= data.poll();</span><br><span class="line"></span><br><span class="line">        data.add(val);</span><br><span class="line">        previousSum += val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> previousSum / data.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MovingAverage</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MovingAverage</span>(<span class="number">3</span>);</span><br><span class="line">        System.out.println(m.next(<span class="number">1</span>));</span><br><span class="line">        System.out.println(m.next(<span class="number">10</span>));</span><br><span class="line">        System.out.println(m.next(<span class="number">3</span>));</span><br><span class="line">        System.out.println(m.next(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>队列</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个排列</title>
    <url>/2020/08/18/NextPermutation/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-31"><a href="#题目-LeetCode-31" class="headerlink" title="题目(LeetCode #31)"></a>题目(<a href="https://leetcode-cn.com/problems/next-permutation/">LeetCode #31</a>)</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须<strong>原地</strong>修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> -&gt; <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span></span><br><span class="line"><span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> -&gt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span> -&gt; <span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><a href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/">参考题解</a></p>
<p>仿照 C++ 中 <code>next_permutation</code> 的实现方法。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol>
<li> 下一个数比当前数大：将<strong>后面的大数与前面的小数交换</strong> ，如 <code>123456</code> ，将 <code>5</code> 和 <code>6</code> 交换得到 <code>123465</code> ；</li>
<li>下一个数的增幅应尽量小，使之满足字典序中的 <strong>下一个</strong>，为了满足该条件需进行如下操作：<ol>
<li> 在 <strong>尽可能靠右的低位</strong>进行交换，需<strong>从后向前</strong>查找；</li>
<li> 将一个<strong>尽可能小的大数</strong>与前面的<strong>小数</strong>交换，如 <code>123465</code> ，下一个排列应该将 <code>5</code> 与 <code>4</code> 交换而不是将 <code>6</code> 和 <code>4</code> 交换；</li>
<li> 将<strong>大数</strong>换到前面后，需将<strong>大数</strong>后面的<strong>所有数</strong>重置为<strong>升序</strong>，升序排列即为最小排列。以 <code>123465</code> 为例：首先按照上一步，交换 <code>5</code> 和 <code>4</code> ，得到 <code>123564</code> 。调整 <code>5</code> 后的数为升序，得到 <code>123546</code> ，即为下一个排列。</li>
</ol>
</li>
</ol>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li> <strong>从后向前</strong>查找第一个<strong>相邻升序</strong>的元素对 <code>(i, j)</code> ，满足 <code>nums[i] &lt; nums[j]</code> 。此时 <code>[j, end)</code> 必然为降序；</li>
<li> 在 <code>[j, end)</code> <strong>从后向前</strong>查找第一个满足 <code>nums[i] &lt; nums[k]</code> 的 <code>k</code> 。<code>nums[i]</code> 和 <code>nums[k]</code> 即为上述<strong>小数</strong>和<strong>大数</strong>；</li>
<li> 交换 <code>nums[i]</code> 和 <code>nums[k]</code> ；</li>
<li> 此时 <code>[j, end)</code> 必然为降序，逆置 <code>[j, end)</code> 使其升序；</li>
<li> 若在步骤 1 找不到符合的相邻元素对，则说明当前数组单调递减，直接跳到步骤 4，整体逆序即可。</li>
</ol>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>以求 <code>12385764</code> 的下一个排列为例：</p>
<ol>
<li><p>初始时：</p>
<p> <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200819114340.png"></p>
</li>
<li><p>从后向前查找第一个相邻升序的元素对 <code>(i, j)</code> ，这里 <code>i=4</code> ，<code>j=5</code> ，对应值为 <code>5</code> 和 <code>7</code> ：</p>
<p> <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200819114506.png"></p>
</li>
<li><p>从后向前查找第一个大于 <code>nums[i]</code> 的值 <code>nums[k]</code> ，此例中 <code>nums[i] = 5</code> ，故 <code>nums[k]=6</code></p>
<p> <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200819114626.png"></p>
</li>
<li><p>交换 <code>nums[i]</code> 和 <code>nums[k]</code> ，即 <code>5</code> 和 <code>6</code>：</p>
<p> <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200819114752.png"></p>
</li>
<li><p>交换后 <code>[j, end)</code> 必仍是降序，逆置 <code>[j, end)</code> ，使其变为升序：</p>
<p> <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200819114909.png"></p>
</li>
<li><p>故 <code>12385764</code> 的下一个排列为 <code>12386457</code> ，逆序后对比如下：</p>
<p> <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200901180301.png"></p>
</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrLen</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (arrLen &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arrLen - <span class="number">2</span>, j = arrLen - <span class="number">1</span>, k = arrLen - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">            i--; j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= nums[k]) k--;</span><br><span class="line">            swap(i, k, nums);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = j, j = arrLen - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">            swap(i, j, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextPermutation</span>(<span class="params">self, nums: <span class="built_in">list</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        arr_len = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> arr_len &lt;= <span class="number">1</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        i, j, k = arr_len - <span class="number">2</span>, arr_len - <span class="number">1</span>, arr_len - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt;= nums[j]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> nums[i] &gt;= nums[k]: k -= <span class="number">1</span></span><br><span class="line">            nums[i], nums[k] = nums[k], nums[i]</span><br><span class="line"></span><br><span class="line">        i, j = j, arr_len - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextPermutation</span><span class="params">(nums []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    arrLen := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> arrLen &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i, j, k := arrLen - <span class="number">2</span>, arrLen - <span class="number">1</span>, arrLen - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j] &#123;</span><br><span class="line">        i--</span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> nums[i] &gt;= nums[k] &#123;</span><br><span class="line">            k--</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i], nums[k] = nums[k], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i, j = j, arrLen - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        i++</span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>分隔链表</title>
    <url>/2020/03/02/PartitionList/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p>示例:</p>
<p>输入: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head = <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span>, x = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>输出: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>每部分中结点从左到右顺序与原链表的先后次序一致</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>可创建三个指针分别保存三个部分的结点, 新结点追加即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PartitionList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">middle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> middle;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node3</span> <span class="operator">=</span> right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &lt; x) &#123;</span><br><span class="line">                node1.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">                node1.next = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.val == x) &#123;</span><br><span class="line">                node2.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">                node2.next = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node3.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                node3 = node3.next;</span><br><span class="line">                node3.next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node1.next = middle.next;</span><br><span class="line">        node2.next = right.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="例题-LeetCode-86"><a href="#例题-LeetCode-86" class="headerlink" title="例题: LeetCode # 86"></a>例题: <a href="https://leetcode-cn.com/problems/partition-list/">LeetCode # 86</a></h2><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p>示例:</p>
<p>输入: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head = <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span>, x = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PartitionList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &lt; x) &#123;</span><br><span class="line">                node1.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">                node1.next = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node2.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">                node2.next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node1.next = right.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PartitionList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, head, x</span>):</span><br><span class="line">        left = ListNode(<span class="number">0</span>)</span><br><span class="line">        right = ListNode(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        node1 = left</span><br><span class="line">        node2 = right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                node1.<span class="built_in">next</span> = head</span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">                node1 = node1.<span class="built_in">next</span></span><br><span class="line">                node1.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node2.<span class="built_in">next</span> = head</span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">                node2 = node2.<span class="built_in">next</span></span><br><span class="line">                node2.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">        node1.<span class="built_in">next</span> = right.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> left.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列</title>
    <url>/2020/09/01/Permutations/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-46"><a href="#题目-LeetCode-46" class="headerlink" title="题目(LeetCode #46)"></a>题目(<a href="https://leetcode-cn.com/problems/permutations/">LeetCode #46</a>)</h2><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p><strong>输入:</strong>  [1, 2, 3]<br><strong>输出:</strong><br>[<br>&emsp;&emsp;[1, 2, 3],<br>&emsp;&emsp;[1, 3, 2],<br>&emsp;&emsp;[2, 1, 3],<br>&emsp;&emsp;[2, 3, 1],<br>&emsp;&emsp;[3, 1, 2],<br>&emsp;&emsp;[3, 2, 1]<br>]</p>
</blockquote>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>使用 <code>visited</code> 数组标记已访问过的元素。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(results, nums, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), <span class="keyword">new</span> <span class="title class_">int</span>[nums.length]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; results, <span class="type">int</span>[] nums, ArrayList&lt;Integer&gt; tmp, <span class="type">int</span>[] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.size() == nums.length) &#123;</span><br><span class="line">            results.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            tmp.add(nums[i]);</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(results, nums, tmp, visited);</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>使用切片和 <code>list</code> 的加法，在向下递归时略过当前元素即实现了对访问过元素的标记。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">nums, tmp</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                results.append(tmp)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                dfs(nums[:i] + nums[i + <span class="number">1</span>:], tmp + [nums[i]])</span><br><span class="line">        dfs(nums, [])</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute1</span>(<span class="params">self, nums: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(itertools.permutations(nums))</span><br></pre></td></tr></table></figure>

<p>调用 <code>Python</code> 的内置函数实现如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(itertools.permutations(nums))</span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><p><code>Go</code> 在实现时需注意 <code>append(nums, 2)</code> 不会修改 <code>nums</code> 数组存储的内容，但 <code>append(nums[:i], 2)</code> 会使 <code>nums</code> 数组发生改变。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> results [][]<span class="type">int</span></span><br><span class="line">    dfs(&amp;results, nums, []<span class="type">int</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(results *[][]<span class="type">int</span>, nums, tmp []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        *results = <span class="built_in">append</span>(*results, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, tmp...)) <span class="comment">// 深拷贝</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        dfs(results, combinedArr(nums[:i], nums[i+<span class="number">1</span>:]), combinedArr(tmp, []<span class="type">int</span>&#123;nums[i]&#125;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinedArr</span><span class="params">(arr1, arr2 []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">    result = <span class="built_in">append</span>(result, arr1...)</span><br><span class="line">    result = <span class="built_in">append</span>(result, arr2...)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进阶-LeetCode-47"><a href="#进阶-LeetCode-47" class="headerlink" title="进阶(LeetCode #47)"></a>进阶(<a href="https://leetcode-cn.com/problems/permutations-ii/">LeetCode #47</a>)</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p><strong>输入:</strong>  [1, 1, 2]<br><strong>输出:</strong><br>[<br>&emsp;&emsp;[1, 1, 2],<br>&emsp;&emsp;[1, 2, 1],<br>&emsp;&emsp;[2, 1, 1]<br>]</p>
</blockquote>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">参考题解</a></p>
<p>#46 中的算法流程如下，因 #47 包含重复元素，需对递归树进行剪枝：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200902171649.png"></p>
<p>观察可知，若两个分支的前几位排列相同，则这两个分支上的递归子树也相等，如 <code>[1]</code> 与 <code>[1&#39;]</code> 、<code>[2, 1]</code> 与 <code>[2, 1&#39;]</code> （即图上红框中内容）重复，可进行剪枝，在同一层判断 <code>nums[i] == nums[i - 1]</code> 是否成立即可。若只设定这一个剪枝条件，将使以下蓝框中的分支被误剪，导致返回空的解集：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200902175046.png"></p>
<p>为避免这种现象的产生，可借助 <code>visited</code> 数组对是否遍历过某分支进行标记，仅在前一个分支遍历完成（即 <code>visited[i - 1] == 0</code> 成立时）进行剪枝。故剪枝的判断条件为 <code>i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; visited[i - 1] == 0</code> 。</p>
<p>下图为递归时递归栈的调用顺序：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200902184517.png"></p>
<p><strong>注：</strong> 实际上 <code>visited[i - 1]</code> 等于 0、不等于 0、等于 1、不等于 1 四种情况下产生的结果相同，但若直接去掉则将返回空的解集🙃。<code>visited[i - 1]</code> 起到的是标记的作用，即只选择 <code>visited[i - 1]</code> 等于 0 或只选择等于 1 的分支，区别仅在于最终结果集中元素的顺序不同，详见 <a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">这篇题解</a> 的补充说明部分。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200902185042.png"></p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(res, nums, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), <span class="keyword">new</span> <span class="title class_">int</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span>[] nums, List&lt;Integer&gt; tmp, <span class="type">int</span>[] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; visited[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            tmp.add(nums[i]);</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(res, nums, tmp, visited);</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        results = []</span><br><span class="line">        arr_len = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">tmp: <span class="built_in">list</span>, visited: <span class="built_in">list</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == arr_len:</span><br><span class="line">                results.append(tmp[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(arr_len):</span><br><span class="line">                <span class="keyword">if</span> visited[i] <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> visited[i - <span class="number">1</span>]): <span class="keyword">continue</span></span><br><span class="line">                tmp.append(nums[i])</span><br><span class="line">                visited[i] = <span class="number">1</span></span><br><span class="line">                dfs(tmp, visited)</span><br><span class="line">                visited[i] = <span class="number">0</span></span><br><span class="line">                tmp.pop()</span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br><span class="line">        dfs([], [<span class="number">0</span>] * <span class="built_in">len</span>(nums))</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>

<h4 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line">func permuteUnique(nums []<span class="built_in">int</span>) [][]<span class="built_in">int</span> &#123;</span><br><span class="line">    var results [][]<span class="built_in">int</span></span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    arrLen := <span class="built_in">len</span>(nums)</span><br><span class="line">    dfs(&amp;results, nums, []<span class="built_in">int</span>&#123;&#125;, make([]<span class="built_in">int</span>, arrLen), arrLen)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func dfs(results *[][]<span class="built_in">int</span>, nums, tmp, visited []<span class="built_in">int</span>, arrLen <span class="built_in">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == arrLen &#123;</span><br><span class="line">        *results = append(*results, append([]<span class="built_in">int</span>&#123;&#125;, tmp...)) // 注意深拷贝</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; arrLen; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">1</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; visited[i - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp = append(tmp, nums[i])</span><br><span class="line">        visited[i] = <span class="number">1</span></span><br><span class="line">        dfs(results, nums, tmp, visited, arrLen)</span><br><span class="line">        tmp = tmp[:<span class="built_in">len</span>(tmp) - <span class="number">1</span>]</span><br><span class="line">        visited[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其它解法"><a href="#其它解法" class="headerlink" title="其它解法"></a>其它解法</h2><p>仿写 C++ 中的 <code>nextPermutation</code> 函数，该解法 #46、#47 均可 AC。</p>
<p>详见 <a href="https://zcybupt.github.io/post/NextPermutation/">下一个排列</a></p>
<h3 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        results.add(arrToList(nums));</span><br><span class="line">        <span class="keyword">while</span> (nextPermutation(nums)) &#123;</span><br><span class="line">            results.add(arrToList(nums));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">arrToList</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) result.add(num);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrLen</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arrLen - <span class="number">2</span>, j = arrLen - <span class="number">1</span>, k = arrLen - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">            i--; j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nums[i] &gt;= nums[k]) k--;</span><br><span class="line">        swap(nums, i, k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = j, j = arrLen - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python-2"><a href="#Python-2" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        results = []</span><br><span class="line">        arr_len = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">next_permutation</span>() -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            i, j, k = arr_len - <span class="number">2</span>, arr_len - <span class="number">1</span>, arr_len - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt;= nums[j]:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == -<span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> nums[i] &gt;= nums[k]: k -= <span class="number">1</span></span><br><span class="line">            nums[i], nums[k] = nums[k], nums[i]</span><br><span class="line"></span><br><span class="line">            i, j = j, arr_len - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br><span class="line">        results.append(nums[:])</span><br><span class="line">        <span class="keyword">while</span> next_permutation():</span><br><span class="line">            results.append(nums[:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>

<h3 id="Go-2"><a href="#Go-2" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permuteUnique</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> results [][]<span class="type">int</span></span><br><span class="line">    arrLen := <span class="built_in">len</span>(nums)</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    results = <span class="built_in">append</span>(results, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, nums...))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> nextPermutation(nums, arrLen) &#123;</span><br><span class="line">        results = <span class="built_in">append</span>(results, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, nums...))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextPermutation</span><span class="params">(nums []<span class="type">int</span>, arrLen <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    i, j, k := arrLen - <span class="number">2</span>, arrLen - <span class="number">1</span>, arrLen - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j] &#123;</span><br><span class="line">        i--</span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> nums[i] &gt;= nums[k] &#123;</span><br><span class="line">        k--</span><br><span class="line">    &#125;</span><br><span class="line">    nums[i], nums[k] = nums[k], nums[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, j = j, arrLen - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/2020/02/14/PrintMatrixSpiralOrder/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-29"><a href="#题目-LeetCode-29" class="headerlink" title="题目: LeetCode # 29"></a>题目: <a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">LeetCode # 29</a></h2><p><a href="https://leetcode-cn.com/problems/spiral-matrix/">LeetCode # 54</a> 类似</p>
<p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<p>示例 1:</p>
<p>输入:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line">    [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ],</span><br><span class="line">    [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>输出: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<p>输入:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">    [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>输出: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<h3 id="方法一：模拟坐标移动"><a href="#方法一：模拟坐标移动" class="headerlink" title="方法一：模拟坐标移动"></a>方法一：模拟坐标移动</h3><p>取左上角和右下角两个位置, 分别移动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(r1  , c1) (r1, c1+<span class="number">1</span>) ··· (r1  , c2)</span><br><span class="line">   ···                    (r1+<span class="number">1</span>, c2)</span><br><span class="line">(r2-<span class="number">1</span>, c1)                    ···</span><br><span class="line">(r2  , c1) ··· (r2, c2-<span class="number">1</span>) (r2  , c2)</span><br></pre></td></tr></table></figure>

<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row1</span> <span class="operator">=</span> <span class="number">0</span>, col1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row2</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>, col2 = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (row1 &lt;= row2 &amp;&amp; col1 &lt;= col2)</span><br><span class="line">            result.addAll(getEdge(matrix, row1++, col1++, row2--, col2--));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getEdge</span><span class="params">(<span class="type">int</span>[][] m, <span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; tmpResult = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (row1 == row2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> col1; i &lt;= col2; i++)</span><br><span class="line">                tmpResult.add(m[row1][i]);</span><br><span class="line">            <span class="keyword">return</span> tmpResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (col1 == col2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row1; i &lt;= row2; i++)</span><br><span class="line">                tmpResult.add(m[i][col1]);</span><br><span class="line">            <span class="keyword">return</span> tmpResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">curR</span> <span class="operator">=</span> row1;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curC</span> <span class="operator">=</span> col1;</span><br><span class="line">        <span class="keyword">while</span> (curC != col2) tmpResult.add(m[row1][curC++]);</span><br><span class="line">        <span class="keyword">while</span> (curR != row2) tmpResult.add(m[curR++][col2]);</span><br><span class="line">        <span class="keyword">while</span> (curC != col1) tmpResult.add(m[row2][curC--]);</span><br><span class="line">        <span class="keyword">while</span> (curR != row1) tmpResult.add(m[curR--][col1]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmpResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span>: <span class="keyword">return</span> result</span><br><span class="line">        row1, col1 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        row2, col2 = <span class="built_in">len</span>(matrix) - <span class="number">1</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_edge</span>(<span class="params">matrix: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">            <span class="keyword">if</span> row1 == row2:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(col1, col2 + <span class="number">1</span>):</span><br><span class="line">                    result.append(matrix[row1][i])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> col1 == col2:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row1, row2 + <span class="number">1</span>):</span><br><span class="line">                    result.append(matrix[i][col1])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(col1, col2): result.append(matrix[row1][i])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row1, row2): result.append(matrix[i][col2])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(col2, col1, -<span class="number">1</span>): result.append(matrix[row2][i])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row2, row1, -<span class="number">1</span>): result.append(matrix[i][col1])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (row1 &lt;= row2 <span class="keyword">and</span> col1 &lt;= col2):</span><br><span class="line">            get_edge(matrix)</span><br><span class="line">            row1, col1, row2, col2 = row1 + <span class="number">1</span>, col1 + <span class="number">1</span>, row2 - <span class="number">1</span>, col2 - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> matrix == <span class="literal">nil</span> || <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    row1, col1 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    row2, col2 := <span class="built_in">len</span>(matrix) - <span class="number">1</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row1 &lt;= row2 &amp;&amp; col1 &lt;= col2 &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, getEdge(matrix, row1, col1, row2, col2)...)</span><br><span class="line">        row1, col1, row2, col2 = row1 + <span class="number">1</span>, col1 + <span class="number">1</span>, row2 - <span class="number">1</span>, col2 - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getEdge</span><span class="params">(m [][]<span class="type">int</span>, row1, col1, row2, col2 <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tmpResult []<span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> row1 == row2 &#123;</span><br><span class="line">        <span class="keyword">for</span> i := col1; i &lt;= col2; i++ &#123;</span><br><span class="line">            tmpResult = <span class="built_in">append</span>(tmpResult, m[row1][i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmpResult</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> col1 == col2 &#123;</span><br><span class="line">        <span class="keyword">for</span> i := row1; i &lt;= row2; i++ &#123;</span><br><span class="line">            tmpResult = <span class="built_in">append</span>(tmpResult, m[i][col1])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmpResult</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := col1; i &lt; col2; i++ &#123;</span><br><span class="line">        tmpResult = <span class="built_in">append</span>(tmpResult, m[row1][i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := row1; i &lt; row2; i++ &#123;</span><br><span class="line">        tmpResult = <span class="built_in">append</span>(tmpResult, m[i][col2])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := col2; i &gt; col1; i-- &#123;</span><br><span class="line">        tmpResult = <span class="built_in">append</span>(tmpResult, m[row2][i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := row2; i &gt; row1; i-- &#123;</span><br><span class="line">        tmpResult = <span class="built_in">append</span>(tmpResult, m[i][col1])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmpResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：移动边界法"><a href="#方法二：移动边界法" class="headerlink" title="方法二：移动边界法"></a>方法二：移动边界法</h3><p>使用四个变量分别记录四个方向上的边界，每遍历完一条边则边界向中心移动一个单位。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200909163637.png"></p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>, b = matrix.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; t &lt;= b) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) result.add(matrix[t][i]);</span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= b; i++) result.add(matrix[i][r]);</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &gt;= l &amp;&amp; t &lt;= b; i--) result.add(matrix[b][i]);</span><br><span class="line">            b--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b; i &gt;= t &amp;&amp; l &lt;= r; i--) result.add(matrix[i][l]);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span>: <span class="keyword">return</span> result</span><br><span class="line">        l, r, t, b = <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r <span class="keyword">and</span> t &lt;= b:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>): result.append(matrix[t][i])</span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(t, b + <span class="number">1</span>): result.append(matrix[i][r])</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt;= r <span class="keyword">and</span> t &lt;= b):</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r, l - <span class="number">1</span>, -<span class="number">1</span>): result.append(matrix[b][i])</span><br><span class="line">                b -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b, t - <span class="number">1</span>, -<span class="number">1</span>): result.append(matrix[i][l])</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>利用 <code>zip</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> matrix:</span><br><span class="line">            res.extend(matrix[<span class="number">0</span>])</span><br><span class="line">            matrix[:] = <span class="built_in">list</span>(<span class="built_in">zip</span>(*matrix[<span class="number">1</span>:]))[::-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> matrix == <span class="literal">nil</span> || <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123; <span class="keyword">return</span> result &#125;</span><br><span class="line"></span><br><span class="line">    l, r, t, b := <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &amp;&amp; t &lt;= b &#123;</span><br><span class="line">        <span class="keyword">for</span> i := l; i &lt;= r; i++ &#123; result = <span class="built_in">append</span>(result, matrix[t][i]) &#125;</span><br><span class="line">        t++</span><br><span class="line">        <span class="keyword">for</span> i := t; i &lt;= b; i++ &#123; result = <span class="built_in">append</span>(result, matrix[i][r]) &#125;</span><br><span class="line">        r--</span><br><span class="line">        <span class="keyword">for</span> i := r; i &gt;= l &amp;&amp; t &lt;= b; i-- &#123; result = <span class="built_in">append</span>(result, matrix[b][i]) &#125;</span><br><span class="line">        b--</span><br><span class="line">        <span class="keyword">for</span> i := b; i &gt;= t &amp;&amp; l &lt;= r; i-- &#123; result = <span class="built_in">append</span>(result, matrix[i][l]) &#125;</span><br><span class="line">        l++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>之字形打印矩阵</title>
    <url>/2020/02/16/PrintMatrixZigZag/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个矩阵, 按照之字型的方式打印矩阵, 例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line"><span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"><span class="number">9</span>  <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>额外空间复杂度为 <code>O(1)</code></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题可以考虑设定两个游标 <code>a</code> 和 <code>b</code> , 初始时均指向左上角, 后分别沿上边界和左边界移动, 当运动到边的末尾时分别向下和向右移动, 打印 <code>a</code> 和 <code>b</code> 两点形成的对角线上的点即可.</p>
<p><strong>需注意 a, b 横纵坐标增加的顺序, 否则容易在拐点出现下标越界</strong></p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200216095801.png"></p>
<center>
<img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200216151246.png">
图来自<a href='https://jishuin.proginn.com/p/5174.html'>程序员客栈</a>
</center><br>

<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintMatrixZigZag</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMatrixZigZag</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endR</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endC</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">fromUp</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (row1 &lt;= endR) &#123;</span><br><span class="line">            printDiagonal(matrix, row1, col1, row2, col2, fromUp);</span><br><span class="line">            <span class="comment">// 需注意 a, b 横纵坐标增加的顺序, 否则容易在拐点出现下标越界</span></span><br><span class="line">            row1 = col1 == endC ? row1 + <span class="number">1</span> : row1;</span><br><span class="line">            col1 = col1 == endC ? col1 : col1 + <span class="number">1</span>;</span><br><span class="line">            col2 = row2 == endR ? col2 + <span class="number">1</span> : col2;</span><br><span class="line">            row2 = row2 == endR ? row2 : row2 + <span class="number">1</span>;</span><br><span class="line">            fromUp = !fromUp; <span class="comment">// 反转</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromUp True: 从上向下打印</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDiagonal</span><span class="params">(<span class="type">int</span>[][] m, <span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2, <span class="type">boolean</span> fromUp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromUp) &#123;</span><br><span class="line">            <span class="keyword">while</span> (row1 &lt;= row2) &#123;</span><br><span class="line">                System.out.print(m[row1++][col1--] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (row1 &lt;= row2) &#123;</span><br><span class="line">                System.out.print(m[row2--][col2++] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] inputMatrix = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        printMatrixZigZag(inputMatrix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_matrix_zigzag</span>(<span class="params">matrix</span>):</span><br><span class="line">    row1 = <span class="number">0</span></span><br><span class="line">    col1 = <span class="number">0</span></span><br><span class="line">    row2 = <span class="number">0</span></span><br><span class="line">    col2 = <span class="number">0</span></span><br><span class="line">    end_row = <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">    end_col = <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    from_up = <span class="literal">False</span></span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> row1 &lt;= end_row:</span><br><span class="line">        result.extend(get_diagonal(matrix, row1, col1, row2, col2, from_up))</span><br><span class="line">        row1 = row1 + <span class="number">1</span> <span class="keyword">if</span> col1 == end_col <span class="keyword">else</span> row1</span><br><span class="line">        col1 = col1 <span class="keyword">if</span> col1 == end_col <span class="keyword">else</span> col1 + <span class="number">1</span></span><br><span class="line">        col2 = col2 + <span class="number">1</span> <span class="keyword">if</span> row2 == end_row <span class="keyword">else</span> col2</span><br><span class="line">        row2 = row2 <span class="keyword">if</span> row2 == end_row <span class="keyword">else</span> row2 + <span class="number">1</span></span><br><span class="line">        from_up = <span class="keyword">not</span> from_up</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_diagonal</span>(<span class="params">m, row1, col1, row2, col2, from_up</span>):</span><br><span class="line">    tmp_result = []</span><br><span class="line">    <span class="keyword">if</span> from_up:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row1, row2 + <span class="number">1</span>):</span><br><span class="line">            tmp_result.append(m[i][col1])</span><br><span class="line">            col1 -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row2, row1 - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            tmp_result.append(m[i][col2])</span><br><span class="line">            col2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp_result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    input_matrix = [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">        [<span class="number">5</span>, <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">        [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    print_matrix_zigzag(input_matrix)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的全排列</title>
    <url>/2020/07/02/PrintPermutations/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>打印一个字符串的全部排列</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>每次递归都将后续字符与当前字符交换, 如第 <code>i</code> 次递归, 将 <code>i</code> 位置之后的字符分别与 <code>i</code> 处字符交换</p>
<p>若要去重使用集合即可</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintPermutations</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printPermutations</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        process(chars, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == chars.length) &#123;</span><br><span class="line">            System.out.println(String.valueOf(chars));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; chars.length; j++) &#123;</span><br><span class="line">            swap(chars, i, j);</span><br><span class="line">            process1(chars, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> chars[i];</span><br><span class="line">        chars[i] = chars[j];</span><br><span class="line">        chars[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_permutations</span>(<span class="params">str_input</span>):</span><br><span class="line">    char_arr = [i <span class="keyword">for</span> i <span class="keyword">in</span> str_input]</span><br><span class="line">    process(char_arr, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">char_arr, i</span>):</span><br><span class="line">    arr_len = <span class="built_in">len</span>(char_arr)</span><br><span class="line">    <span class="keyword">if</span> i == arr_len:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(char_arr))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, arr_len):</span><br><span class="line">        char_arr[i], char_arr[j] = char_arr[j], char_arr[i]</span><br><span class="line">        process(char_arr, i + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printPermutations</span><span class="params">(input <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	charArr := []<span class="type">byte</span>(input)</span><br><span class="line">	process(charArr, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(charArr []<span class="type">byte</span>, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	arrLen := <span class="built_in">len</span>(charArr)</span><br><span class="line">	<span class="keyword">if</span> i == arrLen &#123;</span><br><span class="line">		fmt.Println(<span class="type">string</span>(charArr))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := i; j &lt; arrLen; j++ &#123;</span><br><span class="line">		charArr[i], charArr[j] = charArr[j], charArr[i]</span><br><span class="line">		process(charArr, i+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>用队列实现栈</title>
    <url>/2020/02/11/QueueStack/</url>
    <content><![CDATA[<p><strong>人类迷惑行为 x 1</strong></p>
<p><code>queue</code> 只保存队列的最后一个元素, 每次 <code>top</code> 或 <code>pop</code> 操作均需将 <code>queue</code> 中元素除队列最后一个元素外的所有元素倒入 <code>help</code> 中, <code>queue</code> 中最后一个元素再出队列, 以此模拟出栈操作.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QueueStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> newEle)</span> &#123;</span><br><span class="line">        queue.add(newEle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Empty stack&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Empty stack&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        help.add(result);</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Queue</span> <span class="variable">tmp</span> <span class="operator">=</span> queue;</span><br><span class="line">        queue = help;</span><br><span class="line">        help = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题-LeetCode-225"><a href="#例题-LeetCode-225" class="headerlink" title="例题: LeetCode #225"></a>例题: <a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">LeetCode #225</a></h2><p>使用队列实现栈的下列操作：</p>
<ul>
<li><p>  push(x) – 元素 x 入栈</p>
</li>
<li><p>  pop() – 移除栈顶元素</p>
</li>
<li><p>  top() – 获取栈顶元素</p>
</li>
<li><p>  empty() – 返回栈是否为空</p>
</li>
</ul>
<p>注意:</p>
<ul>
<li>  你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。</li>
<li>  你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
<li>  你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li>
</ul>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Push element x onto stack.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the element on top of the stack and returns that element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Empty stack&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the top element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Empty stack&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        help.add(result);</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns whether the stack is empty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Queue</span> <span class="variable">tmp</span> <span class="operator">=</span> queue;</span><br><span class="line">        queue = help;</span><br><span class="line">        help = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue = []</span><br><span class="line">        self.help_queue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x onto stack.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue.insert(<span class="number">0</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element on top of the stack and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.queue) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.queue) != <span class="number">1</span>:</span><br><span class="line">            self.help_queue.insert(<span class="number">0</span>, self.queue.pop())</span><br><span class="line"></span><br><span class="line">        result = self.queue.pop()</span><br><span class="line">        self.queue, self.help_queue = self.help_queue, self.queue</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the top element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.queue) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.queue) != <span class="number">1</span>:</span><br><span class="line">            self.help_queue.insert(<span class="number">0</span>, self.queue.pop())</span><br><span class="line"></span><br><span class="line">        result = self.queue.pop()</span><br><span class="line">        self.help_queue.insert(<span class="number">0</span>, result)</span><br><span class="line">        self.queue, self.help_queue = self.help_queue, self.queue</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the stack is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue) == <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>队列</tag>
        <tag>Easy</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>删除字符串中的所有相邻重复项 II</title>
    <url>/2022/01/29/RemoveAllAdjacentDuplicatesInStringII/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-1209"><a href="#题目-LeetCode-1209" class="headerlink" title="题目(LeetCode #1209)"></a>题目(<a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string-ii/">LeetCode #1209</a>)</h2><p>给你一个字符串 <code>s</code>，「<code>k</code> 倍重复项删除操作」将会从 <code>s</code> 中选择 <code>k</code> 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。</p>
<p>你需要对 <code>s</code> 重复进行无限次这样的删除操作，直到无法继续为止。</p>
<p>在执行完所有删除操作后，返回最终得到的字符串。</p>
<p>本题答案保证唯一。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入:</strong> s = “abcd”, k = 2<br><strong>输出:</strong> “abcd”<br><strong>解释:</strong> 没有要删除的内容。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入</strong>: s = “deeedbbcccbdaa”, k = 3<br><strong>输出</strong>: “aa”<br><strong>解释</strong>：<br>先删除 “eee” 和 “ccc”，得到 “ddbbbdaa”<br>再删除 “bbb”，得到 “dddaa”<br>最后删除 “ddd”，得到 “aa”</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p><strong>输入</strong>: s = “pbbcggttciiippooaais”, k = 2<br><strong>输出</strong>: “ps”</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= s.length &lt;= 10^5</li>
<li>2 &lt;= k &lt;= 10^4</li>
<li>s 中只含有小写英文字母。</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>可使用栈保存当前遍历的字符的连续出现次数。每次循环判断当前字符与前一个字符是否相同，若相同则栈顶元素自增。若自增至 <code>k</code> 则从字符串中删除这 <code>k</code> 个字符，同时修改遍历时的索引的值，直到遍历至字符串尾部即可。时间复杂度和空间复杂度均为 <code>O(n)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">        <span class="type">int</span>[] countStack = <span class="keyword">new</span> <span class="title class_">int</span>[sb.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sb.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || sb.charAt(i) != sb.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                countStack[idx++] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">increment</span> <span class="operator">=</span> countStack[--idx] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (increment == k) &#123;</span><br><span class="line">                    sb.delete(i - k + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">                    i = i - k;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    countStack[idx++] = increment;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <url>/2020/08/11/RemoveNthNodeFromEndOfList/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-19"><a href="#题目-LeetCode-19" class="headerlink" title="题目(LeetCode #19)"></a>题目(<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">LeetCode #19</a>)</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong>n = 2</strong>.</p>
<p>当删除了倒数第二个节点后，链表变为 <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p>
</blockquote>
<p><strong>说明：</strong></p>
<p>给定的 n 保证是有效的。</p>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>利用递归的特性，从递归栈底向上累加即为倒数索引。</p>
<p><code>removeNode</code> 最终返回的值为输入链表的长度，若该返回值与 <code>n</code> 相等，则说明去掉的是第一个节点，此时头节点为 <code>head.next</code> 。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> removeNode(head, n) == n ? head.next : head; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeNode</span><span class="params">(ListNode node, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> removeNode(node.next, n);</span><br><span class="line">        <span class="keyword">if</span> (m == n)</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span> <span class="keyword">if</span> self.remove_node(head, n) == n <span class="keyword">else</span> head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_node</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        m = self.remove_node(head.<span class="built_in">next</span>, n)</span><br><span class="line">        <span class="keyword">if</span> m == n:</span><br><span class="line">            head.<span class="built_in">next</span> = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val  <span class="type">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> removeNode(head, n) == n &#123;</span><br><span class="line">        <span class="keyword">return</span> head.Next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNode</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m := removeNode(head.Next, n)</span><br><span class="line">    <span class="keyword">if</span> m == n &#123;</span><br><span class="line">        head.Next = head.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>使用快慢指针来查找索引，快指针先移动 <code>n</code> 个位置，再同时移动两指针，当快指针指向链表的尾节点时，慢指针所指即为倒数第 <code>n</code> 个节点。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            fast = fast.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        fast, slow = head, head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast: <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h4 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    fast, slow := head, head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    slow.Next = slow.Next.Next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>链表</tag>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>递归逆序栈</title>
    <url>/2020/07/07/ReverseStackUsingRecursive/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>逆序一个栈, 且不能使用额外的数据结构, 只可使用递归函数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>可将问题分为两个步骤:</p>
<ol>
<li> 弹出栈底元素并返回</li>
<li> 获取栈底元素并将其放回栈顶</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseStackUsingRecursive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ele</span> <span class="operator">=</span> getAndRemoveLastElement(stack);</span><br><span class="line">        reverse(stack);</span><br><span class="line">        stack.push(ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getAndRemoveLastElement</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> getAndRemoveLastElement(stack);</span><br><span class="line">            stack.push(result);</span><br><span class="line">            <span class="keyword">return</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">stack</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    ele = get_and_remove_last_element(stack)</span><br><span class="line">    reverse(stack)</span><br><span class="line">    stack.append(ele)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_and_remove_last_element</span>(<span class="params">stack</span>):</span><br><span class="line">    result = stack.pop()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        last = get_and_remove_last_element(stack)</span><br><span class="line">        stack.append(result)</span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><p>若不使用指针的指针则需注意引用传递, 否则会由于 stack 数组不更新进入死循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(stack []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> stack == <span class="literal">nil</span> || <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ele, stack := getAndRemoveLastElement(stack)	<span class="comment">// 需将 stack 重新赋值</span></span><br><span class="line">	reverse(stack)</span><br><span class="line">	stack = <span class="built_in">append</span>(stack, ele)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getAndRemoveLastElement</span><span class="params">(stack []<span class="type">int</span>)</span></span> (<span class="type">int</span>, []<span class="type">int</span>) &#123;</span><br><span class="line">	result := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">	stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result, stack</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		last, stack := getAndRemoveLastElement(stack)</span><br><span class="line">		stack = <span class="built_in">append</span>(stack, result)</span><br><span class="line">		<span class="keyword">return</span> last, stack</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索二维矩阵</title>
    <url>/2020/02/29/SearchMatrix/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 <code>M * N</code> 的矩阵, 矩阵中每一行从左到右依次递增, 每一列从上到下依次递增, 判断矩阵中是否含有整数K. </p>
<p>矩阵示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line"><span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line"><span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>时间复杂度为 <code>O(M + N)</code> , 空间复杂度为 <code>O(1)</code></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>可先选取左下角或右上角处的元素进行比较, 每次移动时, 均只有两种可能的移动方向. 每次查找最多横向比较 <code>N</code> 次, 纵向比较 <code>M</code> 次, 故时间复杂度为 <code>O(M + N)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本例从右上角处元素开始比较</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 输入矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标数值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否含有该数值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchMatrix</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">cuR</span> <span class="operator">=</span> M;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cuC</span> <span class="operator">=</span> N;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cuR &lt; matrix.length &amp;&amp; cuC &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[cuR][cuC] &gt; target)</span><br><span class="line">                cuC--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[cuR][cuC] &lt; target)</span><br><span class="line">                cuR++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题-LeetCode-74"><a href="#例题-LeetCode-74" class="headerlink" title="例题: LeetCode # 74"></a>例题: <a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">LeetCode # 74</a></h2><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。<br>示例:</p>
<p>输入:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">target = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>输出: true</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SearchMatrix</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">cuR</span> <span class="operator">=</span> M;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cuC</span> <span class="operator">=</span> N;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cuR &lt; matrix.length &amp;&amp; cuC &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[cuR][cuC] &gt; target)</span><br><span class="line">                cuC--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[cuR][cuC] &lt; target)</span><br><span class="line">                cuR++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SearchMatrix</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        本例从右上角元素开始比较</span></span><br><span class="line"><span class="string">        :param matrix: 输入矩阵</span></span><br><span class="line"><span class="string">        :param target: 目标数值</span></span><br><span class="line"><span class="string">        :return: 是否含有该数值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_matrix</span>(<span class="params">self, matrix, target</span>):</span><br><span class="line">        M = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        N = <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        cuR = M</span><br><span class="line">        cuC = N</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cuR &lt; <span class="built_in">len</span>(matrix) <span class="keyword">and</span> cuC &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[cuR][cuC] &gt; target:</span><br><span class="line">                cuC -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[cuR][cuC] &lt; target:</span><br><span class="line">                cuR += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>最短回文串</title>
    <url>/2020/07/22/ShortestPalindrome/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-214"><a href="#题目-LeetCode-214" class="headerlink" title="题目(LeetCode #214)"></a>题目(<a href="https://leetcode-cn.com/problems/shortest-palindrome">LeetCode #214</a>)</h2><p>给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>  <strong>输入:</strong> “aacecaaa”<br>  <strong>输出:</strong> “aaacecaaa”</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>  <strong>输入:</strong> “abcd”<br>  <strong>输出:</strong> “dcbabcd”</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>可利用<a href="https://zcybupt.github.io/post/Manacher/">Manacher 算法</a>找到原字符串包含第一个字符的最长回文子串，将该回文子串后的字符逆序加到开头即可。</p>
<p>示例 1 中，对 <code>aacecaaa</code> 来说，包含第一个字符的最长回文子串为 <code>aacecaa</code> ，需把剩余的 <code>a</code> 逆序加到开头，即得到 <code>aaacecaaa</code> ；示例 2 中，<code>abcd</code> 包含第一个字符的最长回文子串为 <code>a</code> ，<code>bcd</code> 逆序得到 <code>dcb</code> ，放到开头即得到 <code>dcbabcd</code> 。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortestPalindrome</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">preprocess</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;^&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            result += <span class="string">&quot;#&quot;</span> + s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result + <span class="string">&quot;#$&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">shortestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">tmpStr</span> <span class="operator">=</span> preprocess(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">strLen</span> <span class="operator">=</span> tmpStr.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">C</span> <span class="operator">=</span> <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] p = <span class="keyword">new</span> <span class="title class_">int</span>[strLen];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strLen - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            p[i] = R &gt; i ? Math.min(p[<span class="number">2</span> * C - i], R - i) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (tmpStr.charAt(i - p[i]) == tmpStr.charAt(i + p[i])) &#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (R &lt; p[i] + i) &#123;</span><br><span class="line">                R = p[i] + i;</span><br><span class="line">                C = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 仅保存以第一个字符开头的回文子串的最大长度</span></span><br><span class="line">            <span class="comment">// (C - p[C]) / 2 即为当前回文串的起始索引</span></span><br><span class="line">            <span class="keyword">if</span> (maxLen &lt; p[i] - <span class="number">1</span> &amp;&amp; (C - p[C]) / <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                maxLen = p[i] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逆序剩余部分字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= maxLen; i--) &#123;</span><br><span class="line">            result += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShortestPalindrome</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shortest_palindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        tmp_str = <span class="string">&quot;^#&quot;</span> + <span class="string">&quot;&quot;</span>.join([x + <span class="string">&quot;#&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> s]) + <span class="string">&quot;$&quot;</span></span><br><span class="line">        str_len = <span class="built_in">len</span>(tmp_str)</span><br><span class="line">        p = [<span class="number">0</span>] * str_len</span><br><span class="line">        c, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, str_len - <span class="number">1</span>):</span><br><span class="line">            p[i] = <span class="built_in">min</span>(p[<span class="number">2</span> * c - i], r - i) <span class="keyword">if</span> r &gt; i <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> tmp_str[i - p[i]] == tmp_str[i + p[i]]:</span><br><span class="line">                p[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> r &lt; p[i] + i:</span><br><span class="line">                r = p[i] + i</span><br><span class="line">                c = i</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> max_len &lt; p[i] - <span class="number">1</span> <span class="keyword">and</span> (c - p[c]) // <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                max_len = p[i] - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([x <span class="keyword">for</span> x <span class="keyword">in</span> s[:max_len - <span class="number">1</span>:-<span class="number">1</span>]]) + s</span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preprocess</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	result := <span class="string">&quot;^#&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">		result += <span class="type">string</span>(ch) + <span class="string">&quot;#&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result + <span class="string">&quot;$&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tmpStr := preprocess(s)</span><br><span class="line">	strLen := <span class="built_in">len</span>(tmpStr)</span><br><span class="line">	p := <span class="built_in">make</span>([]<span class="type">int</span>, strLen)</span><br><span class="line">	C, R := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	maxLen := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; strLen<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> R &gt; i &#123;</span><br><span class="line">			p[i] = min(p[<span class="number">2</span>*C-i], R-i)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			p[i] = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> tmpStr[i-p[i]] == tmpStr[i+p[i]] &#123;</span><br><span class="line">			p[i]++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> R &lt; p[i]+i &#123;</span><br><span class="line">			R = p[i] + i</span><br><span class="line">			C = i</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> maxLen &lt; p[i]<span class="number">-1</span> &amp;&amp; (C-p[C])/<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">			maxLen = p[i] - <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(s) - <span class="number">1</span>; i &gt;= maxLen; i-- &#123;</span><br><span class="line">		result += <span class="type">string</span>(s[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result + s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃表</title>
    <url>/2020/07/31/Skiplist/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/design-skiplist/">https://leetcode-cn.com/problems/design-skiplist/</a></p>
<p><a href="https://juejin.im/post/6844903446475177998">https://juejin.im/post/6844903446475177998</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/53975333">https://zhuanlan.zhihu.com/p/53975333</a></p>
<p><a href="https://lotabout.me/2018/skip-list/">https://lotabout.me/2018/skip-list/</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>跳表</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最大值</title>
    <url>/2020/07/12/SlidingWindowMaximum/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-239"><a href="#题目-LeetCode-239" class="headerlink" title="题目(LeetCode #239)"></a>题目(<a href="https://leetcode-cn.com/problems/sliding-window-maximum/">LeetCode #239</a>)</h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], 和 k = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] </span><br><span class="line">解释: </span><br><span class="line">             滑动窗口的位置              最大值</span><br><span class="line">[ <span class="number">1</span>   <span class="number">3</span>   -<span class="number">1</span> ] -<span class="number">3</span>   <span class="number">5</span>   <span class="number">3</span>   <span class="number">6</span>   <span class="number">7</span>        <span class="number">3</span></span><br><span class="line">  <span class="number">1</span> [ <span class="number">3</span>   -<span class="number">1</span>   -<span class="number">3</span> ] <span class="number">5</span>   <span class="number">3</span>   <span class="number">6</span>   <span class="number">7</span>        <span class="number">3</span></span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span> [ -<span class="number">1</span>   -<span class="number">3</span>   <span class="number">5</span> ] <span class="number">3</span>   <span class="number">6</span>   <span class="number">7</span>        <span class="number">5</span></span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span>   -<span class="number">1</span> [ -<span class="number">3</span>   <span class="number">5</span>   <span class="number">3</span> ] <span class="number">6</span>   <span class="number">7</span>        <span class="number">5</span></span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span>   -<span class="number">1</span>   -<span class="number">3</span> [ <span class="number">5</span>   <span class="number">3</span>   <span class="number">6</span> ] <span class="number">7</span>        <span class="number">6</span></span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span>   -<span class="number">1</span>   -<span class="number">3</span>   <span class="number">5</span> [ <span class="number">3</span>   <span class="number">6</span>   <span class="number">7</span> ]      <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>提示:</p>
<ul>
<li>  1 &lt;= nums.length &lt;= 10^5</li>
<li>  -10^4 &lt;= nums[i] &lt;= 10^4</li>
<li>  1 &lt;= k &lt;= nums.length</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="窗口内最值的更新结构"><a href="#窗口内最值的更新结构" class="headerlink" title="窗口内最值的更新结构"></a>窗口内最值的更新结构</h3><p>借助单调双端队列实现, 队列由头到尾单调递减, 头指针始终指向窗口内的最大值. 定义两个指针 <code>L</code> 与 <code>R</code> , 初始值为 -1, <code>L</code> 与 <code>R</code> 之间即为窗口范围. 在窗口移动的过程中, 需满足:</p>
<ol>
<li> <code>L</code> 和 <code>R</code> 不向左移动</li>
<li> <code>L</code> 不能移动到 <code>R</code> 的右侧</li>
</ol>
<p>定义一个双端队列, 其中保存输入数组中元素的索引.</p>
<ul>
<li><p>当窗口增加元素, 即 <code>R</code> 增加时, 需保持队列的单调性. 若新元素比原有元素都小, 则将其索引追加在最后; 若队列中有小于等于新元素的, 则先将所有小于等于新元素的索引弹出, 再加入新元素的索引. 以此实现队列的头指针始终指向最大元素</p>
<p>  <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200712162837.png"></p>
</li>
<li><p>  当窗口减少元素, 即 <code>L</code> 增加时, 依次弹出头结点即可.</p>
</li>
</ul>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>本题窗口宽度固定, 可用相对位置表示 <code>L</code> 与 <code>R</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowMaximum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || k &lt; <span class="number">1</span> || nums.length &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Integer&gt; maxQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 共有 arr.length - k + 1 个窗口, 即共有arr.length - win + 1个最大值</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 i 表示 R</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!maxQueue.isEmpty() &amp;&amp; nums[maxQueue.peekLast()] &lt;= nums[i]) &#123;</span><br><span class="line">                maxQueue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            maxQueue.addLast(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i - k 为过期的索引, 即窗口的 L 已越过该位置, 需弹出头结点维持窗口大小为 k</span></span><br><span class="line">            <span class="keyword">if</span> (maxQueue.peekFirst() == i - k) &#123;</span><br><span class="line">                System.out.println(i + <span class="string">&quot; &quot;</span> + k);</span><br><span class="line">                maxQueue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                result[index++] = nums[maxQueue.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SlidingWindowMaximum</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k &lt; <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums) &lt; k:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        max_queue = []</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">while</span> max_queue <span class="keyword">and</span> nums[max_queue[-<span class="number">1</span>]] &lt;= nums[i]:</span><br><span class="line">                max_queue.pop()</span><br><span class="line">            max_queue.append(i)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> max_queue[<span class="number">0</span>] == i - k:</span><br><span class="line">                max_queue = max_queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">                result.append(nums[max_queue[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> nums == <span class="literal">nil</span> || k &lt; <span class="number">0</span> || <span class="built_in">len</span>(nums) &lt; k &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	maxQueue := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	result := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums)-k+<span class="number">1</span>)</span><br><span class="line">	index := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(maxQueue) &gt; <span class="number">0</span> &amp;&amp; nums[maxQueue[<span class="built_in">len</span>(maxQueue)<span class="number">-1</span>]] &lt;= nums[i] &#123;</span><br><span class="line">			maxQueue = maxQueue[:<span class="built_in">len</span>(maxQueue)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		maxQueue = <span class="built_in">append</span>(maxQueue, i)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> maxQueue[<span class="number">0</span>] == i-k &#123;</span><br><span class="line">			maxQueue = maxQueue[<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i &gt;= k<span class="number">-1</span> &#123;</span><br><span class="line">			result[index] =nums[maxQueue[<span class="number">0</span>]]</span><br><span class="line">			index++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法汇总</title>
    <url>/2020/01/08/SortAlgorithms/</url>
    <content><![CDATA[<p>参考资料: <a href="https://www.cnblogs.com/onepixel/p/7674659.html">https://www.cnblogs.com/onepixel/p/7674659.html</a></p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20190823090305.png"></p>
<h2 id="比较排序"><a href="#比较排序" class="headerlink" title="比较排序"></a>比较排序</h2><h3 id="00-冒泡排序"><a href="#00-冒泡排序" class="headerlink" title="00. 冒泡排序"></a>00. 冒泡排序</h3><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/849589-20171015223238449-2146169197.gif"></p>
<p>时间复杂度计算</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20190822223140.png"></p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">11</span>]</span><br><span class="line">bubble_sort(input_arr)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br></pre></td></tr></table></figure>

<h3 id="01-插入排序"><a href="#01-插入排序" class="headerlink" title="01. 插入排序"></a>01. 插入排序</h3><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤 2~5。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/849589-20171015225645277-1151100000.gif"></p>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">11</span>]</span><br><span class="line">insertion_sort(input_arr)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br></pre></td></tr></table></figure>

<h3 id="02-希尔排序"><a href="#02-希尔排序" class="headerlink" title="02. 希尔排序"></a>02. 希尔排序</h3><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><p>希尔排序也是一种插入排序, 它是简单插入排序经过改进之后的一个更高效的版本, 也称为缩小增量排序</p>
<p>简单插入排序很循规蹈矩, 不管数组分布是怎么样的, 依然一步一步的对元素进行比较, 移动, 插入, 如 <code>[5,4,3,2,1,0]</code> 这种倒序序列, 数组末端的 <code>0</code> 要回到首位置很是费劲, 比较和移动元素均需 <code>n-1</code> 次. 而希尔排序在数组中采用跳跃式分组的策略, 通过某个增量将数组元素划分为若干组, 然后分组进行插入排序, 随后逐步缩小增量, 继续按组进行插入排序操作, 直至增量为1. 希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序, 小的基本在前, 大的基本在后, 微调即可.</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20191030173958.png"></p>
<p>参考: <a href="https://www.cnblogs.com/chengxiao/p/6104371.html">https://www.cnblogs.com/chengxiao/p/6104371.html</a></p>
<h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(arr)</span><br><span class="line">    gap = <span class="built_in">int</span>(length / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, length):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, -<span class="number">1</span>, -gap):  <span class="comment"># 相当于将插入排序的遍历的间隔由 1 改为 -gap, 即完成了分组</span></span><br><span class="line">                <span class="keyword">if</span> arr[j] &lt; arr[j - gap] <span class="keyword">and</span> j - gap &gt;= <span class="number">0</span>:</span><br><span class="line">                    arr[j], arr[j - gap] = arr[j - gap], arr[j]</span><br><span class="line">        gap = <span class="built_in">int</span>(gap / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">11</span>]</span><br><span class="line">shell_sort(input_arr)</span><br><span class="line"><span class="built_in">print</span>(input_arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br></pre></td></tr></table></figure>


<h3 id="03-选择排序"><a href="#03-选择排序" class="headerlink" title="03. 选择排序"></a>03. 选择排序</h3><h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><p><code>n</code> 个记录的直接选择排序可经过 <code>n-1</code> 趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ol>
<li><p>初始状态: 无序区为 <code>R[1..n]</code>，有序区为空</p>
</li>
<li><p>第 <code>i</code> 趟排序 <code>(i=1,2,3…n-1)</code> 开始时, 当前有序区和无序区分别为 <code>R[1..i-1]</code> 和 <code>R(i..n)</code>. 该趟排序从当前无序区中-选出关键字最小的记录 <code>R[k]</code>, 将它与无序区的第 <code>1</code> 个记录 <code>R</code> 交换, 使 <code>R[1..i]</code> 和<code>R[i+1..n]</code> 分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区</p>
</li>
<li><p><code>n-1</code> 趟结束，数组有序化了。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/849589-20171015224719590-1433219824.gif"></p>
<h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, length):</span><br><span class="line">            min_index = j <span class="keyword">if</span> arr[j] &lt; arr[min_index] <span class="keyword">else</span> min_index</span><br><span class="line">        arr[i], arr[min_index] = arr[min_index], arr[i]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">11</span>]</span><br><span class="line">selection_sort(input_arr)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br></pre></td></tr></table></figure>

<h3 id="04-堆排序"><a href="#04-堆排序" class="headerlink" title="04. 堆排序"></a>04. 堆排序</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆需满足:</p>
<ol>
<li>堆中某个节点的值总是不大于或不小于其父节点的值</li>
<li>堆总是一棵完全二叉树</li>
</ol>
<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20191101222843.png"></p>
<h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li><p>将初始待排序关键字序列 <code>(R1,R2…Rn)</code> 构建成大顶堆，此堆为初始的无序区</p>
</li>
<li><p>将堆顶元素 <code>R[1]</code> 与最后一个元素 <code>R[n]</code> 交换, 此时得到新的无序区 <code>(R1,R2,…Rn-1)</code> 和新的有序区 <code>(Rn)</code>, 且满足 <code>R[1,2…n-1] &lt;= R[n]</code></p>
</li>
<li><p>由于交换后新的堆顶 <code>R[1]</code> 可能违反堆的性质, 因此需要对当前无序区 <code>(R1,R2,…Rn-1)</code> 调整为新堆, 然后再次将 <code>R[1]</code> 与无序区最后一个元素交换, 得到新的无序区 <code>(R1,R2…Rn-2)</code> 和新的有序区 <code>(Rn-1,Rn)</code>. 不断重复此过程直到有序区的元素个数为 <code>n-1</code>，则整个排序过程完成。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/849589-20171015231308699-356134237.gif"></p>
<h4 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    heap_size = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(heap_size):</span><br><span class="line">        heapify(arr, i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> heap_size &gt; <span class="number">0</span>:</span><br><span class="line">        heap_size -= <span class="number">1</span></span><br><span class="line">        arr[<span class="number">0</span>], arr[heap_size] = arr[heap_size], arr[<span class="number">0</span>]</span><br><span class="line">        heap_adjust(arr, <span class="number">0</span>, heap_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数组转化为堆, 若 index 处的节点大于父节点则交换, 循环直至满足堆条件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">arr, index</span>):</span><br><span class="line">    <span class="keyword">while</span> arr[index] &gt; arr[<span class="built_in">int</span>((index - <span class="number">1</span>) / <span class="number">2</span>)]:</span><br><span class="line">        arr[index], arr[<span class="built_in">int</span>((index - <span class="number">1</span>) / <span class="number">2</span>)] = arr[<span class="built_in">int</span>((index - <span class="number">1</span>) / <span class="number">2</span>)], arr[index]</span><br><span class="line">        index = <span class="built_in">int</span>((index - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组调整为最大堆</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_adjust</span>(<span class="params">arr, index, heap_size</span>):</span><br><span class="line"></span><br><span class="line">    left = <span class="number">2</span> * index + <span class="number">1</span>  <span class="comment"># 当前节点的左孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; heap_size:</span><br><span class="line">        <span class="comment"># 求出左右子中较大的一个</span></span><br><span class="line">        largest = left + <span class="number">1</span> <span class="keyword">if</span> left + <span class="number">1</span> &lt; heap_size <span class="keyword">and</span> arr[</span><br><span class="line">            left + <span class="number">1</span>] &gt; arr[left] <span class="keyword">else</span> left</span><br><span class="line">        <span class="comment"># 求孩子与父节点中较大的一个</span></span><br><span class="line">        largest = largest <span class="keyword">if</span> arr[largest] &gt; arr[index] <span class="keyword">else</span> index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> largest == index:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        arr[index], arr[largest] = arr[largest], arr[index]</span><br><span class="line">        index = largest</span><br><span class="line">        left = <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">11</span>]</span><br><span class="line">heap_sort(input_arr)</span><br><span class="line"><span class="built_in">print</span>(input_arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br></pre></td></tr></table></figure>


<h3 id="05-归并排序"><a href="#05-归并排序" class="headerlink" title="05. 归并排序"></a>05. 归并排序</h3><h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li>把长度为n的输入序列分成两个长度为 <code>n/2</code> 的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/849589-20171015230557043-37375010.gif"></p>
<h4 id="递归示例"><a href="#递归示例" class="headerlink" title="递归示例"></a>递归示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归查找最大值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_max</span>(<span class="params">arr, L, R</span>):  <span class="comment"># L 和 R 为索引</span></span><br><span class="line">    <span class="keyword">if</span> (L == R):  <span class="comment"># base case 问题划分到 base case 时停止划分</span></span><br><span class="line">        <span class="keyword">return</span> arr[L]</span><br><span class="line">    mid = <span class="built_in">int</span>((L + R) / <span class="number">2</span>)  <span class="comment"># 写成 L + int((R - L) / 2) 可以防止溢出</span></span><br><span class="line">    max_left = get_max(arr, L, mid)</span><br><span class="line">    max_right = get_max(arr, mid + <span class="number">1</span>, R)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(max_left, max_right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">11</span>]</span><br><span class="line">get_max(input_arr, <span class="number">0</span>, <span class="built_in">len</span>(input_arr) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">44</span></span><br></pre></td></tr></table></figure>

<h4 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归过程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sort_process</span>(<span class="params">arr, L, R</span>):</span><br><span class="line">    <span class="keyword">if</span> (L == R):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    mid = L + <span class="built_in">int</span>((R - L) / <span class="number">2</span>)</span><br><span class="line">    sort_process(arr, L, mid)</span><br><span class="line">    sort_process(arr, mid + <span class="number">1</span>, R)</span><br><span class="line">    merge(arr, L, mid, R)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并过程, 非递归</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">arr, L, mid, R</span>):</span><br><span class="line">    tmp = []</span><br><span class="line">    p1 = L</span><br><span class="line">    p2 = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> p1 &lt;= mid <span class="keyword">and</span> p2 &lt;= R:  <span class="comment"># p1 p2 均不越界时</span></span><br><span class="line">        <span class="keyword">if</span> arr[p1] &lt; arr[p2]:</span><br><span class="line">            tmp.append(arr[p1])</span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(arr[p2])</span><br><span class="line">            p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid):</span><br><span class="line">        tmp.append(arr[p1])</span><br><span class="line">        p1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R):</span><br><span class="line">        tmp.append(arr[p2])</span><br><span class="line">        p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)):</span><br><span class="line">        arr[L + i] = tmp[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">11</span>]</span><br><span class="line">sort_process(input_arr, <span class="number">0</span>, <span class="built_in">len</span>(input_arr) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(input_arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br></pre></td></tr></table></figure>


<h4 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>在一个数组中, 每一个数左边比当前数小的数累加起来, 叫做这个数组的小和. 求数组 <code>[1, 3, 4, 2, 5]</code> 的小和.  </p>
<ul>
<li>1左边比1小的数，没有</li>
<li>3左边比3小的数, 1</li>
<li>4左边比4小的数, 1, 3</li>
<li>2左边比2小的数, 1</li>
<li>5左边比5小的数, 1, 3, 4, 2</li>
</ul>
<p>所以小和为 1+1+3+1+1+3+4+2=16</p>
<h5 id="基于归并排序的实现"><a href="#基于归并排序的实现" class="headerlink" title="基于归并排序的实现"></a>基于归并排序的实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sort_process</span>(<span class="params">arr, L, R</span>):</span><br><span class="line">    <span class="keyword">if</span> (arr[L] == arr[R]):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    mid = L + <span class="built_in">int</span>((R - L) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> sort_process(arr, L, mid) +\</span><br><span class="line">            sort_process(arr, mid + <span class="number">1</span>, R) + \</span><br><span class="line">            merge(arr, L, mid, R)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">arr, L, mid, R</span>):</span><br><span class="line">    tmp = []</span><br><span class="line">    p1 = L</span><br><span class="line">    p2 = mid + <span class="number">1</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> p1 &lt;= mid <span class="keyword">and</span> p2 &lt;= R:</span><br><span class="line">        <span class="keyword">if</span> arr[p1] &lt; arr[p2]:</span><br><span class="line">            result += (R - p2 + <span class="number">1</span>) * arr[p1] <span class="keyword">if</span> arr[p1] &lt; arr[p2] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            tmp.append(arr[p1])</span><br><span class="line"></span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(arr[p2])</span><br><span class="line">            p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> p1 &lt;= mid:</span><br><span class="line">        tmp.append(arr[p1])</span><br><span class="line">        p1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> p2 &lt;= R:</span><br><span class="line">        tmp.append(arr[p2])</span><br><span class="line">        p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)):</span><br><span class="line">        arr[L + i] = tmp[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_small_sum</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;小和为: %d&#x27;</span> % sort_process(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">cal_small_sum(input_arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">小和为: <span class="number">16</span></span><br></pre></td></tr></table></figure>


<h3 id="06-快速排序"><a href="#06-快速排序" class="headerlink" title="06. 快速排序"></a>06. 快速排序</h3><h4 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<p>参考 </p>
<ul>
<li><a href="http://data.biancheng.net/view/117.html">http://data.biancheng.net/view/117.html</a></li>
<li><a href="https://www.jianshu.com/p/2b2f1f79984e">https://www.jianshu.com/p/2b2f1f79984e</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/849589-20171015230936371-1413523412.gif"></p>
<h4 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h4><h5 id="原始实现"><a href="#原始实现" class="headerlink" title="原始实现"></a>原始实现</h5><p>单侧扫描, 将小于 p 的数字放到 p 的左边, 大于 p 的不动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr: <span class="built_in">list</span>, l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>):</span><br><span class="line">    lp = l <span class="comment"># 记录左指针位置, 每当有满足条件的值时就与 lp 交换位置, 并自增</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt;= arr[r]:</span><br><span class="line">            arr[lp], arr[i] = arr[i], arr[lp]</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr: <span class="built_in">list</span>, l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r, l - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        partition(arr, l, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">quick_sort(input_arr, <span class="number">0</span>, <span class="built_in">len</span>(input_arr) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(input_arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h5 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr: <span class="built_in">list</span>, l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>):</span><br><span class="line">    lp = l <span class="comment"># 记录左指针位置, 每当有满足条件的值时就与 lp 交换位置, 并自增</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt;= arr[r]:</span><br><span class="line">            arr[lp], arr[i] = arr[i], arr[lp]</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr: <span class="built_in">list</span>, l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">if</span> l &lt; r:</span><br><span class="line">        partition(arr, l, r)</span><br><span class="line">        quick_sort(arr, l, r - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">quick_sort(input_arr, <span class="number">0</span>, <span class="built_in">len</span>(input_arr) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(input_arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h5 id="改进实现"><a href="#改进实现" class="headerlink" title="改进实现"></a>改进实现</h5><p>两端扫描</p>
<ol>
<li>使用两个变量 less 和 more, less 指向首元素的元素下一个元素(最左边的首元素为中轴元素), more 指向最后一个元素</li>
<li>从前往后找, 找到一个比中轴元素大的, 然后从后往前找, 找到一个比中轴元素小的, 然后交换这两个元素, 直到这两个变量交错 ( less &gt; more ) (注意不是相遇 less == more，因为相遇的元素还未和中轴元素比较)</li>
<li>对左半数组和右半数组重复上述操作.</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改进实现, 双侧移动, 取最左侧为中轴元素</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr: <span class="built_in">list</span>, l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    r(在右侧找到比中轴小的元素) =&gt; l(中轴)</span></span><br><span class="line"><span class="string">    l(在左侧找到比中轴大的元素) =&gt; r(在右侧找到比中轴小的元素)</span></span><br><span class="line"><span class="string">                      中轴值 =&gt; l/r(此时 l == r, 即 l 和 r 均指向左右部分的交界)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    p = arr[l]</span><br><span class="line">    <span class="keyword">while</span> l != r:</span><br><span class="line">        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> arr[r] &gt;= p:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        arr[l] = arr[r]  <span class="comment"># 在右侧找到比中轴小的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> arr[l] &lt;= p:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        arr[r] = arr[l]  <span class="comment"># 在左侧找到比中轴大的元素</span></span><br><span class="line"></span><br><span class="line">    arr[l] = p  <span class="comment"># 此时 L = R, 即把中轴值赋给左右部分的交界位置</span></span><br><span class="line">    <span class="keyword">return</span> l  <span class="comment"># 返回中轴索引</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr: <span class="built_in">list</span>, l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">    <span class="keyword">if</span> l &lt; r:</span><br><span class="line">        p_index = partition(arr, l, r)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 中轴已经排好, 递归时可去除中轴</span></span><br><span class="line">        quick_sort(arr, l, p_index - <span class="number">1</span>)</span><br><span class="line">        quick_sort(arr, p_index + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">quick_sort(input_arr, <span class="number">0</span>, <span class="built_in">len</span>(input_arr) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(input_arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h4 id="随机快速排序"><a href="#随机快速排序" class="headerlink" title="随机快速排序"></a>随机快速排序</h4><p>以上为经典快速排序, 在中轴值两侧数分布不均匀时, 时间复杂度很高, 所以一般使用随机快速排序</p>
<h5 id="随机快速排序算法实现"><a href="#随机快速排序算法实现" class="headerlink" title="随机快速排序算法实现"></a>随机快速排序算法实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr: <span class="built_in">list</span>, l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="comment"># 随机选取一个数与中轴值上的数交换</span></span><br><span class="line">    rand_index = random.randint(l, r)</span><br><span class="line">    arr[rand_index], arr[l] = arr[l], arr[rand_index]</span><br><span class="line"></span><br><span class="line">    p = arr[l]</span><br><span class="line">    <span class="keyword">while</span> l != r:</span><br><span class="line">        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> arr[r] &gt;= p:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        arr[l] = arr[r]  <span class="comment"># 在右侧找到比中轴小的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> arr[l] &lt;= p:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        arr[r] = arr[l]  <span class="comment"># 在左侧找到比中轴大的元素</span></span><br><span class="line"></span><br><span class="line">    arr[l] = p  <span class="comment"># 此时 L = R, 即把中轴值赋给左右部分的交界位置</span></span><br><span class="line">    <span class="keyword">return</span> l  <span class="comment"># 返回中轴索引</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr: <span class="built_in">list</span>, l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">if</span> l &lt; r:</span><br><span class="line">        p_index = partition(arr, l, r)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 中轴已经排好, 递归时可去除中轴</span></span><br><span class="line">        quick_sort(arr, l, p_index - <span class="number">1</span>)</span><br><span class="line">        quick_sort(arr, p_index + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">quick_sort(input_arr, <span class="number">0</span>, <span class="built_in">len</span>(input_arr) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(input_arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>


<h4 id="衍生问题"><a href="#衍生问题" class="headerlink" title="衍生问题"></a>衍生问题</h4><h5 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h5><p>现有红白蓝三种不同颜色的小球，乱序排列在一起，请重新排列这些小球，使得红白蓝三色的同颜色的球在一起。这个问题之所以叫荷兰国旗问题，是因为我们可以将红白蓝三色小球想象成条状物，有序排列后正好组成荷兰国旗。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr, L, R</span>):</span><br><span class="line">    p = arr[L]</span><br><span class="line">    <span class="keyword">while</span> L != R:</span><br><span class="line">        <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> arr[R] &gt;= p:</span><br><span class="line">            R -= <span class="number">1</span></span><br><span class="line">        arr[L] = arr[R]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> arr[L] &lt;= p:</span><br><span class="line">            L += <span class="number">1</span></span><br><span class="line">        arr[R] = arr[L]</span><br><span class="line"></span><br><span class="line">    arr[L] = p</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">netherland_flag</span>(<span class="params">arr, L, R</span>):</span><br><span class="line">    <span class="keyword">if</span> L &lt; R:</span><br><span class="line">        p = partition(arr, L, R)</span><br><span class="line"></span><br><span class="line">        netherland_flag(arr, L, p - <span class="number">1</span>)</span><br><span class="line">        netherland_flag(arr, p + <span class="number">1</span>, R)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">netherland_flag(input_arr, <span class="number">0</span>, <span class="built_in">len</span>(input_arr) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(input_arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>


<h5 id="奇偶划分"><a href="#奇偶划分" class="headerlink" title="奇偶划分"></a>奇偶划分</h5><p>给出一列数, 按奇偶划分, 左侧为奇数, 右侧为偶数, 要求不额外创建数组, 划分后奇数与奇数, 偶数与偶数之间顺序与划分前相同. </p>
<p>采用快排类似的算法, 需保证 partition 部分为稳定排序, 难以实现</p>
<h2 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h2><h3 id="01-计数排序"><a href="#01-计数排序" class="headerlink" title="01. 计数排序"></a>01. 计数排序</h3><h4 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li>找出待排序的数组中最大和最小的元素</li>
<li>统计数组中每个值为 <code>i</code> 的元素出现的次数, 存入数组 <code>C</code> 的第 <code>i</code> 项</li>
<li>对所有的计数累加(从 <code>C</code> 中的第一个元素开始, 每一项和前一项相加)</li>
<li>反向填充目标数组: 将每个元素i放在新数组的第 <code>C(i)</code> 项, 每放一个元素就将 <code>C(i)</code> 减去 1</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/849589-20171015231740840-6968181.gif"></p>
<h4 id="算法实现-7"><a href="#算法实现-7" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    原算法使用数组保存数据, 因使用下标所以有序</span></span><br><span class="line"><span class="string">    本实现使用字典, 保存时无序, 输出时按序取出, 可减小一定的空间复杂度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    bucket = <span class="built_in">dict</span>()</span><br><span class="line">    max_value = <span class="built_in">max</span>(arr)</span><br><span class="line">    min_value = <span class="built_in">min</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">if</span> bucket.get(i) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            bucket[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            bucket[i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(min_value, max_value + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> bucket.get(i) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(bucket[i]):</span><br><span class="line">                arr[index] = i  <span class="comment"># 放回原数组, 减小空间复杂度</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">counting_sort(input_arr)</span><br><span class="line"><span class="built_in">print</span>(input_arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>


<h3 id="02-桶排序"><a href="#02-桶排序" class="headerlink" title="02. 桶排序"></a>02. 桶排序</h3><h4 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li>设置一个定量的数组当作空桶</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去</li>
<li>对每个不是空的桶进行排序</li>
<li>从不是空的桶里把排好序的数据拼接起来</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/demo_js_algorithmSort_bucketSort_1.png"></p>
<h4 id="算法实现-8"><a href="#算法实现-8" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>(<span class="params">arr, bucket_size</span>):</span><br><span class="line">    max_value = <span class="built_in">max</span>(arr)</span><br><span class="line">    min_value = <span class="built_in">min</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 桶的初始化</span></span><br><span class="line">    buckets = []</span><br><span class="line">    bucket_num = <span class="built_in">int</span>((max_value - min_value) / bucket_size) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bucket_num + <span class="number">1</span>):</span><br><span class="line">        buckets.append([])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ele <span class="keyword">in</span> arr:</span><br><span class="line">        buckets[<span class="built_in">int</span>((ele - min_value) / bucket_size)].append(ele)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对桶内元素进行插入排序</span></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bucket)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> bucket[j] &gt; bucket[j + <span class="number">1</span>]:</span><br><span class="line">                    bucket[j], bucket[j + <span class="number">1</span>] = bucket[j + <span class="number">1</span>], bucket[j]</span><br><span class="line"></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 将结果填回原数组</span></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> bucket:</span><br><span class="line">            arr[index] = i</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">bucket_sort(input_arr, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(input_arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>


<h4 id="衍生问题-1"><a href="#衍生问题-1" class="headerlink" title="衍生问题"></a>衍生问题</h4><h5 id="最大间隔问题-leetcode-164"><a href="#最大间隔问题-leetcode-164" class="headerlink" title="最大间隔问题 (leetcode 164)"></a>最大间隔问题 (leetcode 164)</h5><p>给定 <code>n</code> 个实数 <code>x1, x2, ..., xn</code>, 求这 <code>n</code> 个实数在实轴上相邻两个数之间的最大差值, 要求设计线性的时间算法</p>
<p>时间线性, 故不能采用排序算法, 可采用抽屉原理, 即为桶排序, 在输入过程中找出数据的最大值 <code>max_</code> 与最小值 <code>min_</code>, 在 <code>(min_, max_)</code> 区间内, 将最大值与最小值之间进行均分成 <code>n-1</code> 份, 每个区间的大小为 <code>len = (max_ - min_)/(n-1)</code> 即此时为 <code>n-1</code> 个桶, 将最大值最小值人为放置于第一个桶和最后一个桶中, 分别代表了各自桶的上限和下限. 根据这个判断剩余的 <code>n-2</code> 个元素放置的桶的位置, 因为有 <code>n-1</code> 个桶需要放置 <code>n-2</code> 个元素所以根据抽屉原理必定有一个桶是空的, 所以，最大间隙一定产生在两个不同区间之间(即两个桶之间, 就是跨区间的数才可能产生最大的间隙), 故最大的间隙一定是一个桶所放数据的最小值与另一个桶所放数据的最大值之间的差值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_gap</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    max_value = <span class="built_in">max</span>(arr)</span><br><span class="line">    min_value = <span class="built_in">min</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> max_value == min_value:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    length = <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建 N + 1 个桶</span></span><br><span class="line">    maxs = [<span class="number">0</span>] * (length + <span class="number">1</span>)</span><br><span class="line">    mins = [<span class="number">0</span>] * (length + <span class="number">1</span>)</span><br><span class="line">    has_num = [<span class="literal">False</span>] * (length + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ele <span class="keyword">in</span> arr:</span><br><span class="line">        index = <span class="built_in">int</span>((ele - min_value) * length / (max_value - min_value))</span><br><span class="line">        mins[index] = ele <span class="keyword">if</span> <span class="keyword">not</span> has_num[index] <span class="keyword">else</span> <span class="built_in">min</span>(ele, mins[index])</span><br><span class="line">        maxs[index] = ele <span class="keyword">if</span> <span class="keyword">not</span> has_num[index] <span class="keyword">else</span> <span class="built_in">max</span>(ele, maxs[index])</span><br><span class="line">        has_num[index] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    max_gap = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    tmp_max = maxs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> has_num[i]:</span><br><span class="line">            max_gap = <span class="built_in">max</span>(mins[i] - tmp_max, max_gap)</span><br><span class="line">            tmp_max = maxs[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_gap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">111</span>, <span class="number">123</span>, <span class="number">44</span>, <span class="number">54</span>, <span class="number">66</span>]</span><br><span class="line">max_gap(input_arr)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>

<h3 id="03-基数排序-Radix-Sort"><a href="#03-基数排序-Radix-Sort" class="headerlink" title="03. 基数排序(Radix Sort)"></a>03. 基数排序(Radix Sort)</h3><h4 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li>取得数组中的最大数，并取得位数</li>
<li>arr 为原始数组, 从最低位开始取每个位组成 radix 数组</li>
<li>对 radix 进行计数排序(利用计数排序适用于小范围数的特点)</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/849589-20171015232453668-1397662527.gif"></p>
<h4 id="算法实现-9"><a href="#算法实现-9" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取指定位上的数字, 索引从 0 开始</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_digit</span>(<span class="params">x, digit</span>):</span><br><span class="line">    <span class="keyword">return</span> x // <span class="number">10</span>**digit % <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最大数的位数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max_digit_length</span>(<span class="params">arr</span>):</span><br><span class="line">    max_value = <span class="built_in">max</span>(arr)</span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> max_value != <span class="number">0</span>:</span><br><span class="line">        length += <span class="number">1</span></span><br><span class="line">        max_value //= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">radix_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    max_length = max_digit_length(arr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_length):</span><br><span class="line">        bucket_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> ele <span class="keyword">in</span> arr:</span><br><span class="line">            digit = get_digit(ele, i)</span><br><span class="line">            <span class="keyword">if</span> bucket_dict.get(digit):</span><br><span class="line">                bucket_dict[digit].append(ele)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bucket_dict[digit] = [ele]</span><br><span class="line"></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> bucket_dict.get(j):</span><br><span class="line">                <span class="keyword">for</span> ele <span class="keyword">in</span> bucket_dict[j]:</span><br><span class="line">                    arr[index] = ele</span><br><span class="line">                    index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_arr = [<span class="number">999</span>, <span class="number">101</span>, <span class="number">22</span>, <span class="number">32</span>, <span class="number">45</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">90</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">44</span>]</span><br><span class="line">radix_sort(input_arr)</span><br><span class="line"><span class="built_in">print</span>(input_arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">22</span>, <span class="number">32</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">90</span>, <span class="number">101</span>, <span class="number">999</span>]</span><br></pre></td></tr></table></figure>


<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在 Java, C++ 中使用的综合排序, 当输入数组的长度小于某值时采用的是插入排序, 当大于某长度时采用的是归并排序或快速排序.</p>
<p>当数组中要排序的元素是自定义类型时, 通常采用归并排序; 当元素为基本类型(如 int, double, char 等)时, 采用的是快速排序. 差别在于排序算法的稳定性, 归并排序可保证排序后的数组保留部分原有数组的顺序, 对基本类型来说相等元素的顺序并不重要, 但对自定义类型来说可能有一定的意义.</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>用栈实现队列</title>
    <url>/2020/02/12/StackQueue/</url>
    <content><![CDATA[<p><strong>人类迷惑行为 x 2</strong></p>
<p>创建两个栈 <code>push</code> 和 <code>pop</code> , 入队数据只进入 <code>push</code> , 出队只从 <code>pop</code> 出. 通过将 <code>push</code> 栈中的数据倒入 <code>pop</code> 栈中实现队列功能, 倒数据的过程中需满足两个条件:</p>
<ol>
<li> 从<code>push</code> 栈倒入 <code>pop</code> 栈之前, <code>pop</code> 栈必须为空</li>
<li> <code>push</code> 栈中的数据一次性倒完</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; pushStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; popStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        pushStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        popStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> newEle)</span> &#123;</span><br><span class="line">        stackTransfer(popStack, pushStack);</span><br><span class="line">        pushStack.push(newEle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        stackTransfer(pushStack, popStack);</span><br><span class="line">        <span class="keyword">if</span> (popStack.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> popStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        stackTransfer(pushStack, popStack);</span><br><span class="line">        <span class="keyword">if</span> (popStack.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> popStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pushStack.isEmpty() &amp;&amp; popStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stackTransfer</span><span class="params">(Stack stack1, Stack stack2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-LeetCode-232"><a href="#例题-LeetCode-232" class="headerlink" title="例题: LeetCode #232"></a>例题: <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks">LeetCode #232</a></h3><p>使用栈实现队列的下列操作：</p>
<ul>
<li><p>  push(x) – 将一个元素放入队列的尾部。</p>
</li>
<li><p>  pop() – 从队列首部移除元素。</p>
</li>
<li><p>  peek() – 返回队列首部的元素。</p>
</li>
<li><p>  empty() – 返回队列是否为空。</p>
</li>
</ul>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line"></span><br><span class="line">queue.push(<span class="number">1</span>);</span><br><span class="line">queue.push(<span class="number">2</span>);  </span><br><span class="line">queue.peek();  <span class="comment">// 返回 1</span></span><br><span class="line">queue.pop();   <span class="comment">// 返回 1</span></span><br><span class="line">queue.empty(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ul>
<li>  你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li>
<li>  你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>  假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; pushStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; popStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        pushStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        popStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackTransfer(popStack, pushStack);</span><br><span class="line">        pushStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stackTransfer(pushStack, popStack);</span><br><span class="line">        <span class="keyword">if</span> (popStack.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> popStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        stackTransfer(pushStack, popStack);</span><br><span class="line">        <span class="keyword">if</span> (popStack.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> popStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pushStack.isEmpty() &amp;&amp; popStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Put elements from stack1 into stack2. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stackTransfer</span><span class="params">(Stack stack1, Stack stack2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.push_stack = []</span><br><span class="line">        self.pop_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack_transfer(self.pop_stack, self.push_stack)</span><br><span class="line">        self.push_stack.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack_transfer(self.push_stack, self.pop_stack)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.pop_stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.pop_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack_transfer(self.push_stack, self.pop_stack)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.pop_stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.pop_stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.push_stack) == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(self.pop_stack) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stack_transfer</span>(<span class="params">self, stack1, stack2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Put elements from stack1 into stack2.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(stack1) != <span class="number">0</span>:</span><br><span class="line">                stack2.append(stack1.pop())</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>队列</tag>
        <tag>Easy</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串转换整数（atoi）</title>
    <url>/2020/08/04/StringToIntegerAtoi/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-8"><a href="#题目-LeetCode-8" class="headerlink" title="题目(LeetCode #8)"></a>题目(<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">LeetCode #8</a>)</h2><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<ul>
<li><p>  如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</p>
</li>
<li><p>  假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</p>
</li>
<li><p>  该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</p>
</li>
</ul>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>  本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</li>
<li>  假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2<sup>31</sup>,  2<sup>31</sup> − 1]。如果数值超过这个范围，请返回  INT_MAX (2<sup>31</sup> − 1) 或 INT_MIN (−2<sup>31</sup>) 。</li>
</ul>
<p><strong>示例 1:</strong></p>
<blockquote>
<p><strong>输入:</strong> “42”<br><strong>输出:</strong> 42</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p><strong>输入:</strong> “   -42”<br><strong>输出:</strong> -42<br><strong>解释:</strong> 第一个非空白字符为 ‘-‘, 它是一个负号。<br>              我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p><strong>输入:</strong> “4193 with words”<br><strong>输出:</strong> 4193<br><strong>解释:</strong> 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p>
</blockquote>
<p><strong>示例 4:</strong></p>
<blockquote>
<p><strong>输入:</strong> “words and 987”<br><strong>输出:</strong> 0<br><strong>解释:</strong> 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>            因此无法执行有效的转换。</p>
</blockquote>
<p><strong>示例 5:</strong></p>
<blockquote>
<p><strong>输入:</strong> “-91283472332”<br><strong>输出:</strong> -2147483648<br><strong>解释:</strong> 数字 “-91283472332” 超过 32 位有符号整数范围。<br>             因此返回 INT_MIN (−2<sup>31</sup>) 。</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>逐位处理字符串，根据每位字符确定一个覆盖所有情况的有限状态机，如下图所示（<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/">图源</a>）：</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200804155943.png"></p>
<p>得到以下的状态转移表：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">space</th>
<th align="center">+ / -</th>
<th align="center">number</th>
<th align="center">other</th>
</tr>
</thead>
<tbody><tr>
<td align="center">start</td>
<td align="center">start</td>
<td align="center">signed</td>
<td align="center">in_number</td>
<td align="center">end</td>
</tr>
<tr>
<td align="center">signed</td>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">in_number</td>
<td align="center">end</td>
</tr>
<tr>
<td align="center">in_number</td>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">in_number</td>
<td align="center">end</td>
</tr>
<tr>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">end</td>
</tr>
</tbody></table>
<p>根据上表即可编写代码即可</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FSM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;String, String[]&gt; table = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FSM</span><span class="params">()</span> &#123;</span><br><span class="line">        table.put(<span class="string">&quot;start&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        table.put(<span class="string">&quot;signed&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        table.put(<span class="string">&quot;in_number&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        table.put(<span class="string">&quot;end&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getColumn</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        status = table.get(status)[getColumn(ch)];</span><br><span class="line">        <span class="keyword">if</span> (status.equals(<span class="string">&quot;in_number&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curInt</span> <span class="operator">=</span> Character.getNumericValue(ch);</span><br><span class="line">            ans = ans * <span class="number">10</span> + curInt;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">int</span>) ans != ans) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sign == <span class="number">1</span>) ans = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span> (sign == -<span class="number">1</span>) ans = Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status.equals(<span class="string">&quot;signed&quot;</span>)) &#123;</span><br><span class="line">            sign = ch == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">FSM</span> <span class="variable">fsm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FSM</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : str.toCharArray()) &#123;</span><br><span class="line">            fsm.get(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fsm.sign * (<span class="type">int</span>) fsm.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FSM</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.state = <span class="string">&#x27;start&#x27;</span></span><br><span class="line">        self.sign = <span class="number">1</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.table = &#123;</span><br><span class="line">            <span class="string">&#x27;start&#x27;</span>: [<span class="string">&#x27;start&#x27;</span>, <span class="string">&#x27;signed&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;signed&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;in_number&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;end&#x27;</span>: [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_column</span>(<span class="params">self, c: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> c.isspace():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, c: <span class="built_in">str</span></span>):</span><br><span class="line">        self.state = self.table[self.state][self.get_column(c)]</span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="string">&#x27;in_number&#x27;</span>:</span><br><span class="line">            self.ans = self.ans * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">            self.ans = <span class="built_in">min</span>(self.ans, INT_MAX) <span class="keyword">if</span> self.sign == <span class="number">1</span> <span class="keyword">else</span> <span class="built_in">min</span>(self.ans, -INT_MIN)</span><br><span class="line">        <span class="keyword">elif</span> self.state == <span class="string">&#x27;signed&#x27;</span>:</span><br><span class="line">            self.sign = <span class="number">1</span> <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myAtoi</span>(<span class="params">self, <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        fsm = FSM()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">            fsm.get(c)</span><br><span class="line">        <span class="keyword">return</span> fsm.sign * fsm.ans</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>打印字符串的子序列</title>
    <url>/2020/06/28/Subsequence/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>打印一个字符串的全部子序列, 包括空字符串</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>迭代过程中, 要么当前字符保留, 要么略过</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200628200644.png"></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subsequence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printAllSub</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chs = str.toCharArray();</span><br><span class="line">        process(chs, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] chs, <span class="type">int</span> i, String pre)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == chs.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pre.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(pre);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        process(chs, i + <span class="number">1</span>, pre + String.valueOf(chs[i]));</span><br><span class="line">        process(chs, i + <span class="number">1</span>, pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        printAllSub(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">ab</span><br><span class="line">ac</span><br><span class="line">a</span><br><span class="line">bc</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_subsequence</span>(<span class="params">string</span>):</span><br><span class="line">    str_arr = [i <span class="keyword">for</span> i <span class="keyword">in</span> string]</span><br><span class="line">    process(str_arr, <span class="number">0</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">str_arr, i, pre</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(str_arr):</span><br><span class="line">        <span class="keyword">if</span> pre != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(pre)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    process(str_arr, i + <span class="number">1</span>, pre + str_arr[i])</span><br><span class="line">    process(str_arr, i + <span class="number">1</span>, pre)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>串联所有单词的子串</title>
    <url>/2020/08/18/SubstringWithConcatenationOfAllWords/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-30"><a href="#题目-LeetCode-30" class="headerlink" title="题目(LeetCode #30)"></a>题目(<a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">LeetCode #30</a>)</h2><p>给定一个字符串 <strong>s</strong> 和一些长度相同的单词 <strong>words</strong>。找出 <strong>s</strong> 中恰好可以由 <strong>words</strong> 中所有单词串联形成的子串的起始位置。</p>
<p>注意子串要与 <strong>words</strong> 中的单词完全匹配，中间不能有其他字符，但不需要考虑 <strong>words</strong> 中单词串联的顺序。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong><br>&emsp;&emsp;s = “barfoothefoobarman”,<br>&emsp;&emsp;words = [“foo”,”bar”]<br><strong>输出：</strong>[0,9]<br>解释：从索引 0 和 9 开始的子串分别是 “barfoo” 和 “foobar” 。输出的顺序不重要, [9,0] 也是有效答案。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong><br>&emsp;&emsp;s = “wordgoodgoodgoodbestword”,<br>&emsp;&emsp;words = [“word”,”good”,”best”,”word”]<br><strong>输出：</strong>[]</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-6/">参考题解</a></p>
<p>创建两个 <code>Map</code> ，存储每个单词与单词出现次数的对应关系，<code>wordMap</code> 中保存输入数组 <code>words</code> 的词频信息；<code>curMap</code> 中保存逐位遍历输入字符串 <code>s</code> 的过程中产生的 <code>wordMap</code> 中含有的单词的词频。整体流程如下：</p>
<ul>
<li>  创建 <code>wordMap</code> ，保存输入数组 <code>words</code> 中单词和对应的词频</li>
<li>逐位遍历输入字符串 <code>s</code> ，记起始位为 <code>start</code> ，单词长度为 <code>wordLen</code> ，判断每次迭代 <code>s[start, start + wordLen]</code> 位置的单词是否在 <code>wordMap</code> 中<ul>
<li>  若不存在，跳出当前循环</li>
<li>若存在，则判断该词在 <code>curMap</code> 中出现次数是否超过其在 <code>wordMap</code> 中的词频<ul>
<li>  若超过，则跳出当前循环</li>
<li>  若不超过，则增加 <code>curMap</code> 中该词的词频</li>
</ul>
</li>
</ul>
</li>
<li>  若从某位置 <code>i</code> 开始，遍历过程中所有的词都符合条件，则将 <code>i</code> 放入结果集中。</li>
</ul>
<p>时间复杂度：假设 <code>s</code> 的长度是 <code>n</code> ，<code>words</code> 里有 <code>m</code> 个单词，那么时间复杂度为 <code>O(n * m)</code> 。</p>
<p>空间复杂度：两个 <code>HashMap</code>，假设 <code>words</code> 里有 <code>m</code> 个单词，就是 <code>O(m)</code> 。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">strLen</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrLen</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="keyword">if</span> (strLen == <span class="number">0</span> || arrLen == <span class="number">0</span>) <span class="keyword">return</span> results;</span><br><span class="line">        <span class="type">int</span> <span class="variable">wordLen</span> <span class="operator">=</span> words[<span class="number">0</span>].length();</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Integer&gt; wordMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> wordMap.getOrDefault(word, <span class="number">0</span>);</span><br><span class="line">            wordMap.put(word, value + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Integer&gt; curMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strLen - arrLen * wordLen + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; arrLen) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">curWord</span> <span class="operator">=</span> s.substring(i + count * wordLen, i + (count + <span class="number">1</span>) * wordLen);</span><br><span class="line">                <span class="keyword">if</span> (wordMap.containsKey(curWord)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> curMap.getOrDefault(curWord, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (value + <span class="number">1</span> &gt; wordMap.get(curWord)) <span class="keyword">break</span>;</span><br><span class="line">                    curMap.put(curWord, value + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">           	<span class="comment">// 所有单词均符合条件</span></span><br><span class="line">            <span class="keyword">if</span> (count == arrLen) results.add(i);</span><br><span class="line">            curMap.clear();</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        results = []</span><br><span class="line">        s_len = <span class="built_in">len</span>(s)</span><br><span class="line">        arr_len = <span class="built_in">len</span>(words)</span><br><span class="line">        <span class="keyword">if</span> s_len == <span class="number">0</span> <span class="keyword">or</span> arr_len == <span class="number">0</span>: <span class="keyword">return</span> results</span><br><span class="line">        word_len = <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        word_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            value = word_map.get(word)</span><br><span class="line">            word_map[word] = value + <span class="number">1</span> <span class="keyword">if</span> value <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s_len - word_len * arr_len + <span class="number">1</span>):</span><br><span class="line">            cur_map = &#123;&#125;</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; arr_len:</span><br><span class="line">                cur_word = s[i + count * word_len: i + (count + <span class="number">1</span>) * word_len]</span><br><span class="line">                <span class="keyword">if</span> cur_word <span class="keyword">in</span> word_map.keys():</span><br><span class="line">                    value = cur_map.get(cur_word)</span><br><span class="line">                    <span class="keyword">if</span> value <span class="keyword">and</span> value + <span class="number">1</span> &gt; word_map.get(cur_word): <span class="keyword">break</span></span><br><span class="line">                    cur_map[cur_word] = value + <span class="number">1</span> <span class="keyword">if</span> value <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == arr_len: results.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubstring</span><span class="params">(s <span class="type">string</span>, words []<span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> results []<span class="type">int</span></span><br><span class="line">    sLen := <span class="built_in">len</span>(s)</span><br><span class="line">    arrLen := <span class="built_in">len</span>(words)</span><br><span class="line">    <span class="keyword">if</span> sLen == <span class="number">0</span> || arrLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    &#125;</span><br><span class="line">    wordLen := <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    wordMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, key := <span class="keyword">range</span> words &#123;</span><br><span class="line">        wordMap[key] = wordMap[key] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; sLen - wordLen * arrLen + <span class="number">1</span>; i++ &#123;</span><br><span class="line">        curMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">        count := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> count &lt; arrLen &#123;</span><br><span class="line">            curWord := s[i + wordLen * count: i + wordLen * (count + <span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">if</span> wordMap[curWord] != <span class="number">0</span> &#123;</span><br><span class="line">                curMap[curWord]++</span><br><span class="line">                <span class="keyword">if</span> curMap[curWord] &gt; wordMap[curWord] &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> count == arrLen &#123;</span><br><span class="line">            results = <span class="built_in">append</span>(results, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h3><p><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/javashi-xian-cong-bao-li-fa-dao-hua-dong-chuang-ko/">参考题解</a></p>
<p>使用滑动窗口来优化遍历过程，假定输入为字符串 <code>s</code> 和字符串数组 <code>words</code> 。取满足条件时的字符串长度为滑动窗口大小，即 <code>windowSize = len(words) * len(words[0])</code> ，分别从 <code>i=0,1,2</code> 开始移动窗口，每次移动 <code>len(words[0])</code> 的长度即可覆盖全部情况。跳过移动过程中的重复校验可降低时间复杂度，有以下三种重复情况：</p>
<ol>
<li><p>匹配成功，窗口后移出现重复匹配</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;barfoofoofoobarman&#x27;</span></span><br><span class="line">words = [<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p> <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200818210418.png"></p>
<p> 上图中 <code>s[3:9]</code> 已在 <code>i=0</code> 为开头的窗口中校验过，确认存在于 <code>words</code> 数组中，且词频未越界，故无需重复判断，直接校验 <code>i=9</code> 之后的字符即可。</p>
</li>
<li><p>匹配失败，有 <code>words</code> 中不包含的单词</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;barfoofoothefoobarman&#x27;</span></span><br><span class="line">words = [<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p> <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200819102313.png"></p>
<p> 滑窗以 <code>i=0</code> 起始时，其中包含 <code>words</code> 数组中没有的 <code>the</code> ，匹配失败。而滑窗移动到 <code>i=3</code> 和 <code>i=6</code> 时又对 <code>the</code> 进行了重复校验，可直接将窗口移动到 <code>i=9</code> 位置跳过重复操作。</p>
</li>
<li><p>匹配失败，单词均在 <code>words</code> 中，但词频超出要求</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;foobarbarfoobarman&#x27;</span></span><br><span class="line">words = [<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p> <img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200819103158.png"></p>
<p> <code>i=0</code> 起始的窗口和 <code>i=3</code> 起始的窗口中均有两个 <code>bar</code> ，但 <code>words</code> 数组中仅有一个，可从 <code>i=6</code> 开始继续校验。</p>
</li>
</ol>
<p>实际实现过程中，对窗口中的字符串进一步划分，每次只取 <code>len(word[0])</code> 长度的子串，若该子串在 <code>words</code> 中且词频未越界，则增加该词在 <code>curMap</code> 中的词频。检验窗口中字符串的子串的过程中记录满足条件的单词数量 ，若当前窗口遍历完成后该数与 <code>words</code> 数组长度相等，则说明全部符合条件。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), arrLen = words.length;</span><br><span class="line">        <span class="keyword">if</span> (sLen == <span class="number">0</span> || arrLen == <span class="number">0</span>) <span class="keyword">return</span> results;</span><br><span class="line">        <span class="type">int</span> <span class="variable">wordLen</span> <span class="operator">=</span> words[<span class="number">0</span>].length();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; wordMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words)</span><br><span class="line">            wordMap.put(word, wordMap.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; curMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">windowSize</span> <span class="operator">=</span> wordLen * arrLen;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wordLen; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (start + windowSize &lt;= sLen) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(start, start + windowSize);</span><br><span class="line">                curMap.clear();</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arrLen;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">curWord</span> <span class="operator">=</span> str.substring((j - <span class="number">1</span>) * wordLen, j * wordLen);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> curMap.getOrDefault(curWord, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count &gt; wordMap.getOrDefault(curWord, <span class="number">0</span>)) <span class="keyword">break</span>;</span><br><span class="line">                    curMap.put(curWord, count);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) results.add(start);</span><br><span class="line">                start += wordLen * Math.max(j, <span class="number">1</span>); <span class="comment">// 若 j != 0 则说明匹配失败，窗口右移 j * wordLen，跳过已校验位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        results = []</span><br><span class="line">        s_len, arr_len = <span class="built_in">len</span>(s), <span class="built_in">len</span>(words)</span><br><span class="line">        <span class="keyword">if</span> s_len == <span class="number">0</span> <span class="keyword">or</span> arr_len == <span class="number">0</span>: <span class="keyword">return</span> results</span><br><span class="line">        word_len = <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        word_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            word_map[word] = word_map.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        cur_map = &#123;&#125;</span><br><span class="line">        window_size = word_len * arr_len</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(word_len):</span><br><span class="line">            start = i</span><br><span class="line">            <span class="keyword">while</span> start + window_size &lt;= s_len:</span><br><span class="line">                cur_str = s[start: start + window_size]</span><br><span class="line">                cur_map.clear()</span><br><span class="line">                j = arr_len</span><br><span class="line">                <span class="keyword">while</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    word = cur_str[(j - <span class="number">1</span>) * word_len: j * word_len]</span><br><span class="line">                    count = cur_map.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> count &gt; word_map.get(word, <span class="number">0</span>): <span class="keyword">break</span></span><br><span class="line">                    cur_map[word] = count</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>: results.append(start)</span><br><span class="line">                start += word_len * <span class="built_in">max</span>(j, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>

<h4 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubstring</span><span class="params">(s <span class="type">string</span>, words []<span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> results []<span class="type">int</span></span><br><span class="line">    sLen, arrLen := <span class="built_in">len</span>(s), <span class="built_in">len</span>(words)</span><br><span class="line">    <span class="keyword">if</span> sLen == <span class="number">0</span> || arrLen == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    &#125;</span><br><span class="line">    wordLen := <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    wordMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        wordMap[word]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    windowSize := wordLen * arrLen;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; wordLen; i++ &#123;</span><br><span class="line">        start := i</span><br><span class="line">        <span class="keyword">for</span> start + windowSize &lt;= sLen &#123;</span><br><span class="line">            curStr := s[start: start + windowSize]</span><br><span class="line">            curMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">            j := arrLen</span><br><span class="line">            <span class="keyword">for</span> j &gt; <span class="number">0</span> &#123;</span><br><span class="line">                curWord := curStr[(j<span class="number">-1</span>) * wordLen: j * wordLen]</span><br><span class="line">                count := curMap[curWord] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count &gt; wordMap[curWord] &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                curMap[curWord] = count</span><br><span class="line">                j--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">                results = <span class="built_in">append</span>(results, start)</span><br><span class="line">            &#125;</span><br><span class="line">            start += wordLen * max(j, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
        <tag>滑动窗口法</tag>
      </tags>
  </entry>
  <entry>
    <title>判断子树结构是否相同</title>
    <url>/2020/07/19/SubtreeOfAnotherTree/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-572"><a href="#题目-LeetCode-572" class="headerlink" title="题目(LeetCode #572)"></a>题目(<a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">LeetCode #572</a>)</h2><p>给定两个非空二叉树 <code>s</code> 和 <code>t</code>，检验 <code>s</code> 中是否包含和 <code>t</code> 具有相同结构和节点值的子树。<code>s</code> 的一个子树包括 <code>s</code> 的一个节点和这个节点的所有子孙。<code>s</code> 也可以看做它自身的一棵子树。</p>
<p>示例 1:</p>
<p>给定的树 s:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>给定的树 t：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="number">4</span> </span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>返回 <strong>true</strong>，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>
<p>示例 2:</p>
<p>给定的树 s：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span></span><br><span class="line">   /</span><br><span class="line">  <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>给定的树 t：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="number">4</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>返回 <strong>false</strong>。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>仅作为KMP的练习，非最优解</strong></p>
<p>先将两棵树序列化（这里采用先序遍历），再利用 KMP 判断 <code>t</code> 是否为 <code>s</code> 的子串。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code_45_SubtreeOfAnotherTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPreorderString</span><span class="params">(TreeNode treeNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (treeNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">tmpResult</span> <span class="operator">=</span> <span class="string">&quot;_&quot;</span> + treeNode.val + <span class="string">&quot;_&quot;</span> + getPreorderString(treeNode.left);</span><br><span class="line">        tmpResult += <span class="string">&quot;_&quot;</span> + getPreorderString(treeNode.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmpResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getNextTable(String pattern) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lp</span> <span class="operator">=</span> -<span class="number">1</span>, rp = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] nextTable = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        nextTable[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rp &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lp == -<span class="number">1</span> || pattern.charAt(lp) == pattern.charAt(rp)) &#123;</span><br><span class="line">                nextTable[++rp] = ++lp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lp = nextTable[lp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nextTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KMP</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serializedS</span> <span class="operator">=</span> getPreorderString(s);</span><br><span class="line">        <span class="type">String</span> <span class="variable">serializedT</span> <span class="operator">=</span> getPreorderString(t);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sCur</span> <span class="operator">=</span> <span class="number">0</span>, tCur = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> serializedS.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">tLen</span> <span class="operator">=</span> serializedT.length();</span><br><span class="line">        <span class="type">int</span>[] nextTable = getNextTable(serializedT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sCur &lt; sLen &amp;&amp; tCur &lt; tLen) &#123;</span><br><span class="line">            <span class="keyword">if</span> (serializedS.charAt(sCur) == serializedT.charAt(tCur)) &#123;</span><br><span class="line">                sCur++;</span><br><span class="line">                tCur++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (tCur == <span class="number">0</span>) sCur++;</span><br><span class="line">                <span class="keyword">else</span> tCur = nextTable[tCur];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tCur == tLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTreeOfAnotherTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_preorder_string</span>(<span class="params">self, tree_node: TreeNode</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tree_node: <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span></span><br><span class="line"></span><br><span class="line">        tmp_str = <span class="string">&#x27;_&#x27;</span> + <span class="built_in">str</span>(tree_node.val) + <span class="string">&#x27;_&#x27;</span> + self.get_preorder_string(tree_node.left)</span><br><span class="line">        tmp_str += <span class="string">&#x27;_&#x27;</span> + self.get_preorder_string(tree_node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmp_str</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_next_table</span>(<span class="params">self, pattern: <span class="built_in">str</span></span>):</span><br><span class="line">        lp, rp = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        length = <span class="built_in">len</span>(pattern)</span><br><span class="line">        next_table = [<span class="number">0</span>] * length</span><br><span class="line">        next_table[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> rp &lt; length - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> pattern[lp] == pattern[rp] <span class="keyword">or</span> lp == -<span class="number">1</span>:</span><br><span class="line">                lp += <span class="number">1</span></span><br><span class="line">                rp += <span class="number">1</span></span><br><span class="line">                next_table[rp] = lp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lp = next_table[lp]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next_table</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubtree</span>(<span class="params">self, s: TreeNode, t: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        serialized_s = self.get_preorder_string(s)</span><br><span class="line">        serialized_t = self.get_preorder_string(t)</span><br><span class="line">        s_len = <span class="built_in">len</span>(serialized_s)</span><br><span class="line">        t_len = <span class="built_in">len</span>(serialized_t)</span><br><span class="line"></span><br><span class="line">        s_cur, t_cur = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        next_table = self.get_next_table(serialized_t)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> s_cur &lt; s_len <span class="keyword">and</span> t_cur &lt; t_len:</span><br><span class="line">            <span class="keyword">if</span> serialized_s[s_cur] == serialized_t[t_cur]:</span><br><span class="line">                s_cur += <span class="number">1</span></span><br><span class="line">                t_cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> t_cur == <span class="number">0</span>:</span><br><span class="line">                    s_cur += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    t_cur = next_table[t_cur]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t_cur == t_len</span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val   <span class="type">int</span></span><br><span class="line">	Left  *TreeNode</span><br><span class="line">	Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPreorderString</span><span class="params">(treeNode *TreeNode)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> treeNode == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;#&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tmpStr := <span class="string">&quot;_&quot;</span> + strconv.Itoa(treeNode.Val) + <span class="string">&quot;_&quot;</span> + getPreorderString(treeNode.Left)</span><br><span class="line">	tmpStr += <span class="string">&quot;_&quot;</span> + getPreorderString(treeNode.Right)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tmpStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNextTable</span><span class="params">(pattern <span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	lp, rp := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">	length := <span class="built_in">len</span>(pattern)</span><br><span class="line">	nextTable := <span class="built_in">make</span>([]<span class="type">int</span>, length)</span><br><span class="line">	nextTable[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> rp &lt; length<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> lp == <span class="number">-1</span> || pattern[lp] == pattern[rp] &#123;</span><br><span class="line">			lp++</span><br><span class="line">			rp++</span><br><span class="line">			nextTable[rp] = lp</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			lp = nextTable[lp]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nextTable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(s *TreeNode, t *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	serializedS := getPreorderString(s)</span><br><span class="line">	serializedT := getPreorderString(t)</span><br><span class="line">	sCur, tCur := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	sLen := <span class="built_in">len</span>(serializedS)</span><br><span class="line">	tLen := <span class="built_in">len</span>(serializedT)</span><br><span class="line">	nextTable := getNextTable(serializedT)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> sCur &lt; sLen &amp;&amp; tCur &lt; tLen &#123;</span><br><span class="line">		<span class="keyword">if</span> serializedS[sCur] == serializedT[tCur] &#123;</span><br><span class="line">			sCur++</span><br><span class="line">			tCur++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> tCur == <span class="number">0</span> &#123;</span><br><span class="line">				sCur++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tCur = nextTable[tCur]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tCur == tLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="奇淫巧技"><a href="#奇淫巧技" class="headerlink" title="奇淫巧技"></a>奇淫巧技</h3><blockquote>
<p><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/comments/384272">LeetCode @洪世贤</a>：<br>  没有什么是 Python 一行解决不了的</p>
</blockquote>
<p>Python 的诱惑？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubtree</span>(<span class="params">self, s: TreeNode, t: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(s).find(<span class="built_in">str</span>(t)) != -<span class="number">1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>数组累加得到目标值</title>
    <url>/2020/06/24/SumToTarget/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个<strong>正整数</strong>数组 <code>arr</code> 和一个整数 <code>target</code> , 如果可以任意选择 <code>arr</code> 中的数字, 求能否累加得到 <code>target</code> .</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><p>穷举所有可能的和, 判断是否含有 <code>target</code> , 穷举过程如下, 其中中间变量格式为 <code>(i, sum)</code> , <code>i</code> 为索引, <code>sum</code> 为当前的累加和, 左支表示累加 <code>arr[i]</code> , 右支表示跳过该值.</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200624204631.png"></p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumToTarget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSum</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> sum, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == arr.length)</span><br><span class="line">            <span class="keyword">return</span> sum == target;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左分支 || 右分支</span></span><br><span class="line">        <span class="keyword">return</span> isSum(arr, i + <span class="number">1</span>, sum + arr[i], target) || isSum(arr, i + <span class="number">1</span>, sum, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(isSum(arr, <span class="number">0</span>, <span class="number">0</span>, target));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_to_target</span>(<span class="params">arr, i, cur_sum, target</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(arr):</span><br><span class="line">        <span class="keyword">return</span> cur_sum == target</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum_to_target(arr, i + <span class="number">1</span>, cur_sum + arr[i], target) <span class="keyword">or</span> \</span><br><span class="line">		   sum_to_target(arr, i + <span class="number">1</span>, cur_sum, target)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>]</span><br><span class="line">    target = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(sum_to_target(arr, <span class="number">0</span>, <span class="number">0</span>, target))</span><br></pre></td></tr></table></figure>

<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>将暴力递归改进为动态规划时, 无需考虑原题目的含义, 只需找到迭代时各变量之间的依赖关系即可. 递归到动态规划的转化方法:</p>
<ol>
<li> 递归函数有 <code>n</code> 个参数, 就定义一个 <code>n</code> 维的数组</li>
<li> 数组的下标是递归函数参数的取值范围</li>
<li> 数组元素的值是递归函数的返回值, 这样就可以从边界值开始， 逐步填充数组，相当于计算递归函数值的逆过程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> isSum(arr, i + <span class="number">1</span>, sum + arr[i], target) || isSum(arr, i + <span class="number">1</span>, sum, target);</span><br></pre></td></tr></table></figure>

<p>由上述代码知递归函数第 <code>i</code> 次递归的结果只依赖于 <code>i+1</code> 和 <code>sum</code> , 故需定义一个 <code>i+1</code> 和 <code>sum</code> 状态关系的数组. 递归函数参数 <code>i</code> 的取值范围为 <code>0~arr.length</code> , <code>sum</code> 的范围为全部元素都不取到全部元素的和, 以 <code>[3, 2, 7]</code> 为例即为 <code>0~12</code> . 构成的数组如下:</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200625180738.png"></p>
<p>任意一格 <code>(i, sum)</code> 的值仅由 <code>(i+1, sum)</code> 和 <code>(i+1, sum+arr[i])</code> 决定. 如上表所示, <code>(1, 3)</code> 的值取决于 <code>(1+1, 3)</code> 和 <code>(1+1, 3+arr[1])</code> , 其中 <code>arr[1]</code> 为 2, 故 <code>(1, 3)</code> 的真值取决于 <code>(2, 3)</code> 和 <code>(2, 5)</code> 的真值.</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200625181137.png"></p>
<p>最终结果返回表中 <code>(0, 0)</code> 位置即可.</p>
<h5 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumToTarget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSum</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 本题只要有一列达到 target 即可, 故 target + 1 列即可</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[arr.length + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// target 列必为 True</span></span><br><span class="line">        dp[i][target] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j + arr[i] &lt;= target) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i + <span class="number">1</span>][j + arr[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_to_target</span>(<span class="params">arr, target</span>):</span><br><span class="line">    row = <span class="built_in">len</span>(arr)</span><br><span class="line">    dp = [[<span class="literal">False</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    dp[row][target] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j + arr[i] &lt;= target:</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j] <span class="keyword">or</span> dp[i + <span class="number">1</span>][j + arr[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2020/08/09/ThreeSum/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-15"><a href="#题目-LeetCode-15" class="headerlink" title="题目(LeetCode #15)"></a>题目(<a href="https://leetcode-cn.com/problems/3sum/">LeetCode #15</a>)</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br>&emsp;[-1, 0, 1],<br>&emsp;[-1, -1, 2]<br>]</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>若要找出所有满足条件的解，需三个变量 <code>a</code> , <code>b</code> , <code>c</code> 的所有情况且不能重复，若直接遍历时间复杂度为 <code>O(N³)</code> ，本题的关键在于如何降低时间复杂度和去除重复解。</p>
<p>可采用双指针法来实现遍历的不重不漏，首先将数组进行排序，再使<code>L</code> 指向 <code>i+1</code> ，<code>R</code> 指向末尾元素，两指针向中间移动直至相遇为止。在遍历过程中</p>
<ul>
<li>  若 <code>nums[i]</code> 与 <code>nums[i-1]</code> 、<code>nums[L]</code> 与 <code>nums[L+1]</code> 、<code>nums[R]</code> 与 <code>nums[R-1]</code> 相等即说明遇到了重复元素，跳过即可；</li>
<li>  若 <code>nums[i] + nums[L] + nums[R] == target</code> ，即为一组解，<code>L</code> 和 <code>R</code> 同时移动；</li>
<li>  若 <code>nums[i] + nums[L] + nums[R] &gt; target</code> ，<code>R</code> 应向左移动以减小三数之和；</li>
<li>  若 <code>nums[i] + nums[L] + nums[R] &lt; target</code> ，<code>L</code> 应向右移动以增大三数之和。 </li>
</ul>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200809203120.png"></p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>  时间复杂度：<code>O(N²)</code> ，数组排序 <code>O(NlogN)</code> ，遍历数组 <code>O(N)</code> ，双指针遍历 <code>O(N)</code> ，总体为 <code>O(NlogN) + O(N) * O(N)</code> ，<code>O(N²)</code></li>
<li>  空间复杂度：<code>O(1)</code></li>
</ul>
<p>参考题解：<a href="https://leetcode-cn.com/problems/3sum/solution/pai-xu-shuang-zhi-zhen-zhu-xing-jie-shi-python3-by/">LeetCode</a></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">listLen</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (listLen &lt; <span class="number">3</span>) <span class="keyword">return</span> results;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> L, R;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; listLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> results;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            L = i + <span class="number">1</span>;</span><br><span class="line">            R = listLen - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[L] + nums[R] == <span class="number">0</span>) &#123;</span><br><span class="line">                    results.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i], nums[L], nums[R])));</span><br><span class="line">                    <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] == nums[L + <span class="number">1</span>]) L++;</span><br><span class="line">                    <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] == nums[R - <span class="number">1</span>]) R--;</span><br><span class="line">                    L++; R--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[L] + nums[R] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    L++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        list_len = <span class="built_in">len</span>(nums)</span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> list_len &lt; <span class="number">3</span>: <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(list_len):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">return</span> results</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]): <span class="keyword">continue</span></span><br><span class="line">            L = i + <span class="number">1</span></span><br><span class="line">            R = list_len - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[L] + nums[R] == <span class="number">0</span>:</span><br><span class="line">                    results.append([nums[i], nums[L], nums[R]])</span><br><span class="line">                    <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[L] == nums[L + <span class="number">1</span>]: L += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> nums[R] == nums[R - <span class="number">1</span>]: R -= <span class="number">1</span></span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[L] + nums[R] &gt; <span class="number">0</span>:</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    arrLen := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">var</span> results [][]<span class="type">int</span></span><br><span class="line">	<span class="keyword">if</span> nums == <span class="literal">nil</span> || arrLen &lt; <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> results</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sort.Ints(nums)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; arrLen; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> results</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		L, R := i+<span class="number">1</span>, arrLen<span class="number">-1</span></span><br><span class="line">		<span class="keyword">for</span> L &lt; R &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i]+nums[L]+nums[R] == <span class="number">0</span> &#123;</span><br><span class="line">				results = <span class="built_in">append</span>(results, []<span class="type">int</span>&#123;nums[i], nums[L], nums[R]&#125;)</span><br><span class="line">				<span class="keyword">for</span> L &lt; R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>] &#123;</span><br><span class="line">					L++</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> L &lt; R &amp;&amp; nums[R] == nums[R<span class="number">-1</span>] &#123;</span><br><span class="line">					R--</span><br><span class="line">				&#125;</span><br><span class="line">				L++</span><br><span class="line">				R--</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[L]+nums[R] &gt; <span class="number">0</span> &#123;</span><br><span class="line">				R--</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				L++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>最接近的三数之和</title>
    <url>/2020/08/10/ThreeSumClosest/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-16"><a href="#题目-LeetCode-16" class="headerlink" title="题目(LeetCode #16)"></a>题目(<a href="https://leetcode-cn.com/problems/3sum-closest/">LeetCode #16</a>)</h2><p>给定一个包括 <code>n</code> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code> 。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p><strong>输入：</strong> nums = [-1,2,1,-4], target = 1</p>
<p><strong>输出：</strong> 2</p>
<p><strong>解释：</strong> 与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>  3 &lt;= nums.length &lt;= 10³</li>
<li>  -10³ &lt;= nums[i] &lt;= 10³</li>
<li>  -10<sup>4</sup>&gt; &lt;= target &lt;= 10<sup>4</sup></li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题与<a href="https://zcybupt.github.io/post/ThreeSum/">三数之和</a>类似 ，可采用双指针法，差别在于本题可以有重复元素。</p>
<p>由于处理过程中数组已经过排序，故在遍历数组元素的过程中，若 <code>nums[i] + nums[L] + nums[R] &gt; target</code> ，需将 <code>R</code> 左移，以减小三数和，进而减小其与 <code>target</code> 的差值；若 <code>nums[i] + nums[L] + nums[R] &lt; target</code> ，需将 <code>L</code> 右移，增大三数和来达到相同目的。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrLen</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (arrLen &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> L, R;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minDiff</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> curDiff, curSum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">            L = i + <span class="number">1</span>;</span><br><span class="line">            R = arrLen - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">                curSum = nums[i] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span> (curSum == target) <span class="keyword">return</span> curSum;</span><br><span class="line">                curDiff = Math.abs(curSum - target);</span><br><span class="line">                <span class="keyword">if</span> (curDiff &lt; minDiff) &#123;</span><br><span class="line">                    result = curSum;</span><br><span class="line">                    minDiff = curDiff;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curSum &gt; target) R--;</span><br><span class="line">                <span class="keyword">else</span> L++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="built_in">list</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        list_len = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> list_len &lt; <span class="number">3</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br><span class="line">        min_diff = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(list_len):</span><br><span class="line">            l = i + <span class="number">1</span></span><br><span class="line">            r = list_len - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                cur_sum = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> cur_sum == target: <span class="keyword">return</span> cur_sum</span><br><span class="line">                cur_diff = <span class="built_in">abs</span>(cur_sum - target)</span><br><span class="line">                <span class="keyword">if</span> cur_diff &lt; min_diff:</span><br><span class="line">                    result = cur_sum</span><br><span class="line">                    min_diff = cur_diff</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur_sum &gt; target: r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: l += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSumClosest</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    arrLen := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> nums == <span class="literal">nil</span> || arrLen &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    result, curSum, curDiff := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    minDiff := math.MaxInt32</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        L, R := i+<span class="number">1</span>, arrLen<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> L &lt; R &#123;</span><br><span class="line">            curSum = v + nums[L] + nums[R]</span><br><span class="line">            <span class="keyword">if</span> curSum == target &#123;</span><br><span class="line">                <span class="keyword">return</span> curSum</span><br><span class="line">            &#125;</span><br><span class="line">            curDiff = <span class="type">int</span>(math.Abs(<span class="type">float64</span>(curSum - target)))</span><br><span class="line">            <span class="keyword">if</span> curDiff &lt; minDiff &#123;</span><br><span class="line">                result = curSum</span><br><span class="line">                minDiff = curDiff</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> curSum &gt; target &#123;</span><br><span class="line">                R--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                L++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序算法</title>
    <url>/2020/06/21/TopologySort/</url>
    <content><![CDATA[<p>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，才能称为该图的一个<a href="https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F">拓扑排序</a>（Topological sorting）：</p>
<ol>
<li>序列中包含每个顶点，且每个顶点只出现一次；</li>
<li>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</li>
</ol>
<p>适用范围:</p>
<ul>
<li>  有向图</li>
<li>  有入度为 0 的节点</li>
<li>  图中没有环</li>
</ul>
<p>拓扑排序常应用于有依赖关系的一组事务之间的排序. 例如有依赖关系的多个模块的编译次序问题等. 假定头图中的 <code>A</code> , <code>B</code> , <code>C</code> , <code>D</code> , <code>K</code> 为待编译的几个模块, 箭头表示依赖关系(如 <code>B</code> , <code>D</code> 依赖于 <code>K</code> ), 经拓扑排序后应输出模块编译顺序, 即 <code>K</code> -&gt; <code>C</code> -&gt; <code>B</code> -&gt; <code>D</code> -&gt; <code>A</code> 或 <code>C</code> -&gt; <code>K</code> -&gt; <code>B</code> -&gt; <code>D</code> -&gt; <code>A</code> ( <code>K</code> 和 <code>C</code> , <code>B</code> 和 <code>D</code> 顺序可互换)</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先找到所有入度为 0 的节点并输出, 删除这些节点. 在下一次迭代中, 找到剩余节点中入度为 0 的节点并输出, 直到图中节点全部输出为止.</p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><p>图的结构定义及实现见<a href="https://zcybupt.github.io/post/Graph/">另一篇博客</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopologySort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;GraphNode&gt; <span class="title function_">topologySort</span><span class="params">(Graph graph)</span> &#123;</span><br><span class="line">        HashMap&lt;GraphNode, Integer&gt; inMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;GraphNode&gt; zeroInQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 取出所有节</span></span><br><span class="line">        <span class="keyword">for</span> (GraphNode node : graph.nodes.values()) &#123;</span><br><span class="line">            inMap.put(node, node.in);   <span class="comment">// 建立节点和其入度的对应关系</span></span><br><span class="line">            <span class="keyword">if</span> (node.in == <span class="number">0</span>)</span><br><span class="line">                zeroInQueue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;GraphNode&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!zeroInQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">GraphNode</span> <span class="variable">cur</span> <span class="operator">=</span> zeroInQueue.poll();</span><br><span class="line">            result.add(cur);</span><br><span class="line">            <span class="comment">// 将入度为 0 的节点的下一层节点的入度减一, 若为 0 则放入 zeroInQueue 中</span></span><br><span class="line">            <span class="keyword">for</span> (GraphNode next : cur.nexts) &#123;</span><br><span class="line">                inMap.put(next, inMap.get(next) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inMap.get(next) == <span class="number">0</span>) &#123;</span><br><span class="line">                    zeroInQueue.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">topology_sort</span>(<span class="params">graph</span>):</span><br><span class="line">    in_dict = <span class="built_in">dict</span>()</span><br><span class="line">    zero_in_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph.nodes.values():</span><br><span class="line">        in_dict[node] = node.in_degree</span><br><span class="line">        <span class="keyword">if</span> node.in_degree == <span class="number">0</span>:</span><br><span class="line">            zero_in_list.append(node)</span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> zero_in_list:</span><br><span class="line">        cur = zero_in_list.pop()</span><br><span class="line">        result.append(cur)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> cur.nexts:</span><br><span class="line">            in_dict[<span class="built_in">next</span>] = in_dict[<span class="built_in">next</span>] - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> in_dict[<span class="built_in">next</span>] == <span class="number">0</span>:</span><br><span class="line">                zero_in_list.append(<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>接雨水问题</title>
    <url>/2020/07/10/TrappingRainWater/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-42"><a href="#题目-LeetCode-42" class="headerlink" title="题目(LeetCode #42)"></a>题目(<a href="https://leetcode-cn.com/problems/trapping-rain-water/">LeetCode #42</a>)</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题可转化为求每根柱子上可接到的水量的和, 而每根柱子上可留住的水量又取决于其左右两侧最高的柱子的高度, 假设一根柱子高度为 1, 其左右两侧最高的柱子高度为 3 和 5, 则这根柱子上方可留住的水量为 3 - 1 = 2.</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200710111108.png"></p>
<h3 id="预处理数组法"><a href="#预处理数组法" class="headerlink" title="预处理数组法"></a>预处理数组法</h3><p>若每次迭代均遍历查找左右两侧的最大值将增加时间复杂度. 故可采用预处理数组的方式, 将数组中每个元素左右两侧的最大值保存起来. 本例中使用两个辅助数组, 分别保存每个位置上的左侧最大值和右侧最大值. 如下例所示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>] <span class="comment"># 原数组</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>] <span class="comment"># 每个元素左侧最大值构成的辅助数组</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>] <span class="comment"># 每个元素右侧最大值构成的辅助数组</span></span><br></pre></td></tr></table></figure>

<p>该种解法的时间复杂度和空间复杂度均为为 <code>O(n)</code></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrapRainWater</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] heightArr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (heightArr == <span class="literal">null</span> || heightArr.length &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrLen</span> <span class="operator">=</span> heightArr.length;</span><br><span class="line">        <span class="type">int</span>[] help1 = <span class="keyword">new</span> <span class="title class_">int</span>[arrLen];</span><br><span class="line">        <span class="type">int</span>[] help2 = <span class="keyword">new</span> <span class="title class_">int</span>[arrLen];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        help1[<span class="number">0</span>] = heightArr[<span class="number">0</span>];</span><br><span class="line">        help2[arrLen - <span class="number">1</span>] = heightArr[arrLen - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">            help1[i] = Math.max(help1[i - <span class="number">1</span>], heightArr[i]);</span><br><span class="line">            help2[arrLen - i - <span class="number">1</span>] = Math.max(help2[arrLen - i], heightArr[arrLen - i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arrLen - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> Math.min(help1[i - <span class="number">1</span>], help2[i + <span class="number">1</span>]) - heightArr[i];</span><br><span class="line">            result += Math.max(tmp, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] heightArr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(trap(heightArr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrapRainWater</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height_arr</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height_arr <span class="keyword">or</span> <span class="built_in">len</span>(height_arr) &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        arr_len = <span class="built_in">len</span>(height_arr)</span><br><span class="line">        help1 = [<span class="number">0</span>] * arr_len</span><br><span class="line">        help2 = [<span class="number">0</span>] * arr_len</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        help1[<span class="number">0</span>] = height_arr[<span class="number">0</span>]</span><br><span class="line">        help2[arr_len - <span class="number">1</span>] = height_arr[arr_len - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, arr_len):</span><br><span class="line">            help1[i] = <span class="built_in">max</span>(help1[i - <span class="number">1</span>], height_arr[i])</span><br><span class="line">            help2[arr_len - i - <span class="number">1</span>] = <span class="built_in">max</span>(help2[arr_len - i], height_arr[arr_len - i - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, arr_len - <span class="number">1</span>):</span><br><span class="line">            tmp = <span class="built_in">min</span>(help1[i - <span class="number">1</span>], help2[i + <span class="number">1</span>]) - height_arr[i]</span><br><span class="line">            result += <span class="built_in">max</span>(<span class="number">0</span>, tmp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(heightArr []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> heightArr == <span class="literal">nil</span> || <span class="built_in">len</span>(heightArr) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arrLen := <span class="built_in">len</span>(heightArr)</span><br><span class="line">	help1 := <span class="built_in">make</span>([]<span class="type">int</span>, arrLen)</span><br><span class="line">	help2 := <span class="built_in">make</span>([]<span class="type">int</span>, arrLen)</span><br><span class="line">	result := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	help1[<span class="number">0</span>] = heightArr[<span class="number">0</span>]</span><br><span class="line">	help2[arrLen<span class="number">-1</span>] = heightArr[arrLen<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; arrLen; i++ &#123;</span><br><span class="line">		help1[i] = max(help1[i<span class="number">-1</span>], heightArr[i])</span><br><span class="line">		help2[arrLen-i<span class="number">-1</span>] = max(help2[arrLen-i], heightArr[arrLen-i<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; arrLen<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		tmp := min(help1[i<span class="number">-1</span>], help2[i+<span class="number">1</span>])</span><br><span class="line">		result += max(<span class="number">0</span>, tmp-heightArr[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>本方法时间复杂度为 <code>O(N)</code> 空间复杂度为 <code>O(1)</code></p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrapRainWater</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] heightArr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (heightArr == <span class="literal">null</span> || heightArr.length &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrLen</span> <span class="operator">=</span> heightArr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> heightArr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> heightArr[arrLen - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arrLen - <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt;= rightMax) &#123;</span><br><span class="line">                result += Math.max(<span class="number">0</span>, leftMax - heightArr[L]);</span><br><span class="line">                leftMax = Math.max(leftMax, heightArr[L++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result += Math.max(<span class="number">0</span>, rightMax - heightArr[R]);</span><br><span class="line">                rightMax = Math.max(rightMax, heightArr[R--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrapRainWater</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height_arr</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height_arr <span class="keyword">or</span> <span class="built_in">len</span>(height_arr) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        arr_len = <span class="built_in">len</span>(height_arr)</span><br><span class="line">        left_max = height_arr[<span class="number">0</span>]</span><br><span class="line">        right_max = height_arr[arr_len - <span class="number">1</span>]</span><br><span class="line">        l = <span class="number">1</span></span><br><span class="line">        r = arr_len - <span class="number">2</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> left_max &lt;= right_max:</span><br><span class="line">                result += <span class="built_in">max</span>(<span class="number">0</span>, left_max - height_arr[l])</span><br><span class="line">                left_max = <span class="built_in">max</span>(left_max, height_arr[l])</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += <span class="built_in">max</span>(<span class="number">0</span>, right_max - height_arr[r])</span><br><span class="line">                right_max = <span class="built_in">max</span>(right_max, height_arr[r])</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(heightArr []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> heightArr == <span class="literal">nil</span> || <span class="built_in">len</span>(heightArr) &lt; <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arrLen := <span class="built_in">len</span>(heightArr)</span><br><span class="line">	leftMax := heightArr[<span class="number">0</span>]</span><br><span class="line">	rightMax := heightArr[arrLen<span class="number">-1</span>]</span><br><span class="line">	L := <span class="number">1</span></span><br><span class="line">	R := arrLen - <span class="number">2</span></span><br><span class="line">	result := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> L &lt;= R &#123;</span><br><span class="line">		<span class="keyword">if</span> leftMax &lt;= rightMax &#123;</span><br><span class="line">			result += max(<span class="number">0</span>, leftMax-heightArr[L])</span><br><span class="line">			leftMax = max(leftMax, heightArr[L])</span><br><span class="line">			L++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			result += max(<span class="number">0</span>, rightMax-heightArr[R])</span><br><span class="line">			rightMax = max(rightMax, heightArr[R])</span><br><span class="line">			R--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀树 🌲</title>
    <url>/2020/06/18/Trie/</url>
    <content><![CDATA[<p><strong>前缀树</strong> 又称 <strong>字典树</strong>, 是一种有序多叉树结构. 常用于做词频统计和前缀匹配. 与二叉树结构不同, 数据不保存在节点中, 而是由路径来表示. 节点中存储标记信息 ( 如经过前一路径的次数, 以前一路径所表示的字母结尾的单词的数量等 ). 如图中所示, 表示了关键字集合 {“A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”}, 结点数字表示经过该路径且在此终结的字符串的数量, 即词频.</p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><p>以下假定输入的数据由 26 个小写字母构成, 不含其它字符. 故可用 <code>0~25</code> 的索引来代表 <code>a~z</code> , 可通过计算单个字母的 ASCII 与字符 <code>a</code> 的差算得索引. 若要存储其它类型数据, 将 TreeNode 中存储下个节点的变量改用 Map 即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> passNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> endNum;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">        passNum = <span class="number">0</span>;</span><br><span class="line">        endNum = <span class="number">0</span>;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] chars = word.toCharArray();</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> tmpChar : chars) &#123;</span><br><span class="line">            index = tmpChar - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.map[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.map[index] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.map[index];	<span class="comment">// node 指向下一个节点</span></span><br><span class="line">            node.passNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        node.endNum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] chars = word.toCharArray();</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> tmpChar : chars) &#123;</span><br><span class="line">            index = tmpChar - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.map[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.map[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.endNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (search(word) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span>[] chars = word.toCharArray();</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> tmpChar : chars) &#123;</span><br><span class="line">                index = tmpChar - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="comment">// 若某路径的 passNum 为 1, 说明只有目标单词经过, 可直接将后续置空</span></span><br><span class="line">                <span class="keyword">if</span> (node.map[index].passNum-- == <span class="number">1</span>) &#123;</span><br><span class="line">                    node.map[index] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.map[index];</span><br><span class="line">            &#125;</span><br><span class="line">            node.endNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">prefixNum</span><span class="params">(String pre)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = pre.toCharArray();</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> tmpChar : chars) &#123;</span><br><span class="line">            index = tmpChar - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.map[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.map[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.passNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.pass_num = <span class="number">0</span></span><br><span class="line">        self.end_num = <span class="number">0</span></span><br><span class="line">        self.<span class="built_in">map</span> = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.<span class="built_in">map</span>.get(ch):</span><br><span class="line">                node.<span class="built_in">map</span>[ch] = TrieNode()</span><br><span class="line">            node = node.<span class="built_in">map</span>[ch]</span><br><span class="line">            node.pass_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        node.end_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.<span class="built_in">map</span>.get(ch):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            node = node.<span class="built_in">map</span>[ch]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.end_num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, word</span>):</span><br><span class="line">        <span class="keyword">if</span> self.search(word):</span><br><span class="line">            node = self.root</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> word:</span><br><span class="line">                node.<span class="built_in">map</span>[ch].pass_num -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> node.<span class="built_in">map</span>.get(ch).pass_num == <span class="number">0</span>:</span><br><span class="line">                    node.<span class="built_in">map</span>[ch] = <span class="literal">None</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                node = node.<span class="built_in">map</span>[ch]</span><br><span class="line">            node.end_num -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prefix_num</span>(<span class="params">self, pre</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> pre:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.<span class="built_in">map</span>.get(ch): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            node = node.<span class="built_in">map</span>[ch]</span><br><span class="line">        <span class="keyword">return</span> node.pass_num</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>前缀树</tag>
      </tags>
  </entry>
  <entry>
    <title>华硕 USB-AC57 / RTL8812BU Ubuntu 20 驱动安装</title>
    <url>/2021/07/26/USB-AC57/</url>
    <content><![CDATA[<h2 id="0-系统环境"><a href="#0-系统环境" class="headerlink" title="0. 系统环境"></a>0. 系统环境</h2><p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20210726115851.png"></p>
<h2 id="1-驱动安装"><a href="#1-驱动安装" class="headerlink" title="1. 驱动安装"></a>1. 驱动安装</h2><p>安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install -y dkms git build-essential</span><br></pre></td></tr></table></figure>

<p>下载驱动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/morrownr/88x2bu.git</span><br></pre></td></tr></table></figure>

<p>编译安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 88x2bu</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./install-driver.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

<p>重启后通过 <code>iwconfig</code> 命令查看驱动状态，图中 wlx3c7c3faee542 即为 USB-AC57</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20210726115910.png"></p>
<p>启用网卡</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ifconfig wlx3c7c3faee542 up</span><br></pre></td></tr></table></figure>

<h2 id="2-连接-WiFi"><a href="#2-连接-WiFi" class="headerlink" title="2. 连接 WiFi"></a>2. 连接 WiFi</h2><p>安装 wpasupplicant</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install wpasupplicant</span><br></pre></td></tr></table></figure>

<p>创建 wpasupplicant 配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure>

<p>在其中写入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">network=&#123;</span><br><span class="line">    ssid=<span class="string">&quot;WiFi名称&quot;</span></span><br><span class="line">    psk=<span class="string">&quot;密码&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo wpa_supplicant -i wlx3c7c3faee542 -c /etc/wpa_supplicant/wpa_supplicant.conf -B</span><br></pre></td></tr></table></figure>

<p>使用 DHCP 获取 ip</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dhclient wlx3c7c3faee542</span><br></pre></td></tr></table></figure>

<p>此时即可通过 USB-AC57 连接网络</p>
<h2 id="3-开机自动连接"><a href="#3-开机自动连接" class="headerlink" title="3. 开机自动连接"></a>3. 开机自动连接</h2><p>编写脚本 <code>conn_wifi.sh</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">WIFINAME=&#x27;wlx3c7c3faee542&#x27;</span><br><span class="line"></span><br><span class="line">ifconfig $WIFINAME up &amp;&amp;</span><br><span class="line">wpa_supplicant -i $WIFINAME -c /etc/wpa_supplicant/wpa_supplicant.conf -B &amp;&amp;</span><br><span class="line">dhclient $WIFINAME</span><br></pre></td></tr></table></figure>

<p>开机时执行该脚本，编辑 <code>/etc/rc.local</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">/bin/sh /home/chunyu/scripts/conn_wifi.sh</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<p>若主机有多个网络连接，需要通过设置默认网关来通过 WiFi 连接网络，脚本改为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">WIFINAME=&#x27;wlx3c7c3faee542&#x27;</span><br><span class="line"></span><br><span class="line">ifconfig $WIFINAME up &amp;&amp;</span><br><span class="line">wpa_supplicant -i $WIFINAME -c /etc/wpa_supplicant/wpa_supplicant.conf -B &amp;&amp;</span><br><span class="line">dhclient $WIFINAME &amp;&amp;</span><br><span class="line">route del default gw 192.168.3.1 &amp;&amp;</span><br><span class="line">route add default gw 192.168.0.1</span><br></pre></td></tr></table></figure>

<p>其中后两行删除了默认的有线网关，添加了 WiFi 网关，地址需根据本机网络配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo route -n</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20210726115925.png"></p>
<p>如网卡 wlx3c7c3faee542 的 Destination 为 192.168.0.0，则网关地址即为 192.168.0.1</p>
]]></content>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2020/06/17/UnionFind/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure"><strong>并查集</strong></a>是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个<strong>联合-查找算法</strong>（<strong>union-find algorithm</strong>）定义了两个用于此数据结构的操作：</p>
<ul>
<li>  <code>Union</code>：将两个子集合并成同一个集合</li>
<li>  <code>isSameSet</code>：判断两元素是否属于同一集合</li>
</ul>
<p>并查集中的元素类似单链表中的结点, 其指针指向该节点的父结点, 集合的代表结点的指针指向它本身.</p>
<p>在合并两个两个集合的过程中, 一般将小的集合挂载大集合的代表结点之后. 如头图中的两个集合合并, <code>4</code> 将挂在 <code>2</code> 下, 新集合的代表结点即为 <code>2</code>.</p>
<p>在查询 (执行 <code>isSameSet</code> 方法) 的过程中, 只需判断两结点所在集合的代表结点是否相同即可判断是否为同一集合. </p>
<p>查询或合并集合时, 若集合未经整理, 即包含多层结点 ( 如<code>3-&gt;1-&gt;5-&gt;2</code> ), 需整理为如图中的仅有两层的形式, 以减少下次查询的操作数.</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><p>使用 HashMap 来表示结点之间的关系, (key, value) 即表示 key 的父节点是 value. 用另一个 HashMap 来存各储代表结点和集合大小, 若某结点不是代表结点, 则该节点的 size 信息无效.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义数据类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFindSet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Data, Data&gt; parentMap;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Data, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFindSet</span><span class="params">(List&lt;Data&gt; nodes)</span> &#123;</span><br><span class="line">        parentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        sizeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化并查集, 此时每个结点自成一个集合, 指针指向它本身</span></span><br><span class="line">        <span class="keyword">for</span> (Data node : nodes) &#123;</span><br><span class="line">            parentMap.put(node, node);</span><br><span class="line">            sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到代表结点并整理结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代表结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Data <span class="title function_">findHead</span><span class="params">(Data node)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">parent</span> <span class="operator">=</span> parentMap.get(node);</span><br><span class="line">        <span class="keyword">if</span> (parent != node) &#123;</span><br><span class="line">            parent = findHead(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parentMap.put(node, parent);    <span class="comment">// 整理结点</span></span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(Data node1, Data node2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findHead(node1) == findHead(node2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(Data a, Data b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">aHead</span> <span class="operator">=</span> findHead(a);</span><br><span class="line">        <span class="type">Data</span> <span class="variable">bHead</span> <span class="operator">=</span> findHead(b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aHead == bHead)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">aSetSize</span> <span class="operator">=</span> sizeMap.get(aHead);</span><br><span class="line">        <span class="type">int</span> <span class="variable">bSetSize</span> <span class="operator">=</span> sizeMap.get(bHead);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aSetSize &lt;= bSetSize) &#123;</span><br><span class="line">            parentMap.put(bHead, aHead);</span><br><span class="line">            sizeMap.put(bHead, aSetSize + bSetSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parentMap.put(aHead, bHead);</span><br><span class="line">            sizeMap.put(aHead, aSetSize + bSetSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFindSet</span>:</span><br><span class="line">    parent_dict = <span class="built_in">dict</span>()</span><br><span class="line">    size_dict = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nodes</span>):</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            self.parent_dict[node] = node</span><br><span class="line">            self.size_dict[node] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_head</span>(<span class="params">self, node</span>):</span><br><span class="line">        parent = self.parent_dict.get(node)</span><br><span class="line">        <span class="keyword">if</span> parent != node:</span><br><span class="line">            self.find_head(parent)</span><br><span class="line"></span><br><span class="line">        self.parent_dict[node] = parent</span><br><span class="line">        <span class="keyword">return</span> parent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_same_set</span>(<span class="params">self, node1, node2</span>):</span><br><span class="line">        <span class="keyword">return</span> self.find_head(node1) == self.find_head(node2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, node1, node2</span>):</span><br><span class="line">        <span class="keyword">if</span> node1 <span class="keyword">and</span> node2:</span><br><span class="line">            head1 = self.find_head(node1)</span><br><span class="line">            head2 = self.find_head(node2)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> head1 == head2:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            size1 = self.size_dict.get(head1)</span><br><span class="line">            size2 = self.size_dict.get(head2)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> size1 &lt;= size2:</span><br><span class="line">                self.parent_dict[head1] = head2</span><br><span class="line">                self.size_dict[head2] = size1 + size2</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.parent_dict[head2] = head1</span><br><span class="line">                self.size_dict[head1] = size1 + size2</span><br></pre></td></tr></table></figure>

<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>当查询次数和合并次数达到 <code>O(N)</code> 或以上时, 单次查询和单次合并的时间复杂度平均为 <code>O(1)</code> </p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的数独</title>
    <url>/2020/08/21/ValidSudoku/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-36"><a href="#题目-LeetCode-36" class="headerlink" title="题目(LeetCode #36)"></a>题目(<a href="https://leetcode-cn.com/problems/valid-sudoku/submissions/">LeetCode #36</a>)</h2><p>判断一个 9x9 的数独是否有效。只需要<strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p>
<ul>
<li>  数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>  数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>  数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ul>
<p>下图是一个部分填充的有效的数独。</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200821184649.png"></p>
<p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p>
<p><strong>示例1：</strong></p>
<p><strong>输入：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="string">&quot;5&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;.&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;3&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;4&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;1&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;7&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;5&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;9&quot;</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<p><strong>输入：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="string">&quot;5&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;.&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;3&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;4&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;1&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;7&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;5&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;9&quot;</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong> 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 </p>
<p><strong>说明：</strong></p>
<ul>
<li>  一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>  只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>  给定数独序列只包含数字 1-9 和字符 ‘.’ 。</li>
<li>  给定数独永远是 9x9 形式的。</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><a href="https://leetcode-cn.com/problems/valid-sudoku/solution/you-xiao-de-shu-du-by-leetcode/">参考题解</a></p>
<p>遍历 <code>9 x 9</code> 的数独，确保其满足：</p>
<ul>
<li>同一行中无重复数字</li>
<li>同一列中无重复数字</li>
<li>每个 <code>3 x 3</code> 的子数独中无重复数字</li>
</ul>
<p>这三个条件可在一次迭代中完成，难点在于如何枚举子数独。</p>
<img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200821185645.png" style="zoom:50%;" />

<p>子数独的索引可通过 <code>(row / 3) * 3 + column / 3</code> 算得，其中 <code>/</code> 为整除（我也不知道别人是怎么想到的🙃）。</p>
<p>而判断是否有重复项可通过 <code>Map</code> 来判断，其中 <code>key</code> 为数字，<code>value</code> 为出现次数，在此使用二维数组来存储对应关系。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>由于单元格数量确定，始终为 <code>81</code> 个，故时间复杂度和空间复杂度均为 <code>O(1)</code> 。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] rows = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="type">int</span>[][] columns = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="type">int</span>[][] boxes = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">num</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">box_index</span> <span class="operator">=</span> (i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                rows[i][n] = rows[i][n] + <span class="number">1</span>;</span><br><span class="line">                columns[j][n] = columns[j][n] + <span class="number">1</span>;</span><br><span class="line">                boxes[box_index][n] = boxes[box_index][n] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rows[i][n] &gt; <span class="number">1</span> || columns[j][n] &gt; <span class="number">1</span> || boxes[box_index][n] &gt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">self, board: <span class="built_in">list</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        rows = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        columns = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        boxes = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                num = board[i][j]</span><br><span class="line">                <span class="keyword">if</span> num == <span class="string">&#x27;.&#x27;</span>: <span class="keyword">continue</span></span><br><span class="line">                num = <span class="built_in">int</span>(num) - <span class="number">1</span></span><br><span class="line">                box_index = (i // <span class="number">3</span>) * <span class="number">3</span> + j // <span class="number">3</span></span><br><span class="line"></span><br><span class="line">                rows[i][num] += <span class="number">1</span></span><br><span class="line">                columns[j][num] += <span class="number">1</span></span><br><span class="line">                boxes[box_index][num] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> rows[i][num] &gt; <span class="number">1</span> <span class="keyword">or</span> columns[j][num] &gt; <span class="number">1</span> <span class="keyword">or</span> boxes[box_index][num] &gt; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidSudoku</span><span class="params">(board [][]<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    rows := [<span class="number">9</span>][<span class="number">9</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    columns := [<span class="number">9</span>][<span class="number">9</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    boxes := [<span class="number">9</span>][<span class="number">9</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">9</span>; j++ &#123;</span><br><span class="line">            num := board[i][j]</span><br><span class="line">            <span class="keyword">if</span> num == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            boxIndex := (i/<span class="number">3</span>)*<span class="number">3</span> + j/<span class="number">3</span></span><br><span class="line">            num = num - <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            rows[i][num]++</span><br><span class="line">            columns[j][num]++</span><br><span class="line">            boxes[boxIndex][num]++</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> rows[i][num] &gt; <span class="number">1</span> || columns[j][num] &gt; <span class="number">1</span> || boxes[boxIndex][num] &gt; <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLO v3 环境搭建及训练入门指南</title>
    <url>/2019/11/22/YoloDeployment/</url>
    <content><![CDATA[<h2 id="Darknet"><a href="#Darknet" class="headerlink" title="Darknet"></a>Darknet</h2><p>Darknet is an open source neural network framework written in C and CUDA. It is fast, easy to install, and supports CPU and GPU computation.</p>
<p>For more information see the <a href="http://pjreddie.com/darknet">Darknet project website</a>.</p>
<h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><h3 id="服务器环境信息"><a href="#服务器环境信息" class="headerlink" title="服务器环境信息"></a>服务器环境信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OS: Ubuntu 16.04</span><br><span class="line">Kernel: x86_64 Linux 4.13.0-38-generic</span><br><span class="line">CPU: Intel Xeon CPU E5-2620 v3 @ 3.2GHz</span><br><span class="line">GPU: 双路 GeForce GTX 1080</span><br><span class="line">RAM: 32 GB</span><br><span class="line">CUDA: 8.0.61</span><br><span class="line">cuDNN: 7.0.5</span><br><span class="line">GCC: 4.9.4</span><br><span class="line">Python: 3.5</span><br></pre></td></tr></table></figure>

<h3 id="CUDA-及-cuDNN-环境配置"><a href="#CUDA-及-cuDNN-环境配置" class="headerlink" title="CUDA 及 cuDNN 环境配置"></a>CUDA 及 cuDNN 环境配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi ~/.bashrc</span><br></pre></td></tr></table></figure>


<p>追加以下内容:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/local/cuda-8.0/bin:$PATH</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务器环境 cuDNN 配置可能存在问题, 故自行配置如下路径</span></span><br><span class="line">export LD_LIBRARY_PATH=/path/to/your/cudnn-lib-files:$LD_LIBRARY_PATH</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例: <span class="built_in">export</span> LD_LIBRARY_PATH=/server_space/zhaoym/cuda/tmp:<span class="variable">$LD_LIBRARY_PATH</span></span></span><br></pre></td></tr></table></figure>

<p>使配置生效:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>克隆官方代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/pjreddie/darknet</span><br></pre></td></tr></table></figure>

<p>切换到 darknet 目录, 修改 Makefile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd darknet</span><br><span class="line">vi Makefile</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GPU=1  </span><br><span class="line">CUDNN=1  </span><br><span class="line">OPENCV=0 # 若需检测视频等, 则修改为 1, OpenCV 配置方法略</span><br><span class="line">. . . . . . .</span><br><span class="line">COMMON+= -DGPU -I/usr/local/cuda/include/ # 需根据服务器 CUDA 安装路径修改  </span><br><span class="line">CFLAGS+= -DGPU  </span><br><span class="line">LDFLAGS+= -L/usr/local/cuda/lib64 -lcuda -lcudart -lcublas -lcurand   # 需根据 cuDNN 路径修改</span><br><span class="line"></span><br><span class="line">例:   </span><br><span class="line">COMMON+= -DGPU -I/usr/local/cuda-8.0/include/  </span><br><span class="line">LDFLAGS+= -L/server_space/zhaoym/cuda/tmp -lcuda -lcudart -lcublas -lcurand</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make    # 编译</span><br></pre></td></tr></table></figure>

<p>若编译失败需执行 make clean, 修改后重新 make 即可</p>
<h3 id="验证是否配置成功"><a href="#验证是否配置成功" class="headerlink" title="验证是否配置成功"></a>验证是否配置成功</h3><p>下载官方预训练权重</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://pjreddie.com/media/files/yolov3.weights</span><br></pre></td></tr></table></figure>

<p>修改配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi cfg/yolov3.cfg</span><br></pre></td></tr></table></figure>

<p>进行如下修改后保存退出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[net]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Testing</span></span><br><span class="line">batch=1             # 取消注释</span><br><span class="line">subdivisions=1      # 取消注释</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Training</span>      </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">batch=64          <span class="comment"># 注释掉</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">subdivisions=16   <span class="comment"># 注释掉</span></span></span><br></pre></td></tr></table></figure>

<p>检测测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./darknet detect cfg/yolov3.cfg yolov3.weights data/dog.jpg</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">layer     filters    size              input                output</span><br><span class="line">    0 conv     32  3 x 3 / 1   416 x 416 x   3   -&gt;   416 x 416 x  32  0.299 BFLOPs</span><br><span class="line">    1 conv     64  3 x 3 / 2   416 x 416 x  32   -&gt;   208 x 208 x  64  1.595 BFLOPs</span><br><span class="line">    .......</span><br><span class="line">  105 conv    255  1 x 1 / 1    52 x  52 x 256   -&gt;    52 x  52 x 255  0.353 BFLOPs</span><br><span class="line">  106 detection</span><br><span class="line">truth_thresh: Using default &#x27;1.000000&#x27;</span><br><span class="line">Loading weights from yolov3.weights...Done!</span><br><span class="line">data/dog.jpg: Predicted in 0.029329 seconds.</span><br><span class="line">dog: 99%</span><br><span class="line">truck: 93%</span><br><span class="line">bicycle: 99%</span><br></pre></td></tr></table></figure>

<p>标注图片在项目根目录下, 名为 <code>predictions.png</code></p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/001.png"></p>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>下面以在<a href="http://jiong.tea.ac.cn/people/JunweiHan/NWPUVHR10dataset.html">西工大遥感数据集</a>上训练模型为例演示如何训练自己的数据</p>
<h3 id="数据集标注转换"><a href="#数据集标注转换" class="headerlink" title="数据集标注转换"></a>数据集标注转换</h3><p>下载数据集并放到 darknet 目录下, 解压并将文件夹中的空格替换</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unrar x NWPU\ VHR-10\ dataset.rar</span><br><span class="line">mv NWPU\ VHR-10\ dataset NWPU_VHR-10_dataset</span><br><span class="line">cd NWPU_VHR-10_dataset</span><br><span class="line">mv ground\ truth ground_truth</span><br><span class="line">mv positive\ image\ set positive_image_set</span><br></pre></td></tr></table></figure>

<p>转换标注, 代码见 <a href="https://github.com/zcybupt/rawfiles/blob/master/codes/nwpu_vhr_label.py">Github</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install numpy opencv-python scikit-image pillow    # 安装所需 Python 库</span><br><span class="line">mkdir labels</span><br><span class="line">python nwpu_vhr_label.py</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">492     # 训练集数量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">158     # 测试集数量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">650     # 图片总数</span><br></pre></td></tr></table></figure>

<p>输出文件有 <code>tran.txt</code>, <code>val.txt</code> 以及 <code>labels</code> 文件夹下的 650 个转换后的标注</p>
<p>darknet 默认标注文件与图片在同一目录, 故需将 <code>labels</code>文件夹下的 txt 复制到 <code>positive_image_set</code> 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp labels/*.txt positive_image_set</span><br></pre></td></tr></table></figure>

<h3 id="准备训练配置文件"><a href="#准备训练配置文件" class="headerlink" title="准备训练配置文件"></a>准备训练配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">mkdir 0913_NWPU_v3</span><br><span class="line">cd 0913_NWPU_v3</span><br><span class="line">mkdir backup</span><br><span class="line">cp ../cfg/yolov3-voc.cfg ./</span><br><span class="line">cp ../NWPU_VHR-10_dataset/*.txt ./</span><br></pre></td></tr></table></figure>

<p>创建 <code>NWPU.data</code> 文件并写入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classes= 10</span><br><span class="line">train  = 0913_NWPU_v3/train.txt</span><br><span class="line">valid  = 0913_NWPU_v3/val.txt</span><br><span class="line">names  = 0913_NWPU_v3/NWPU.names</span><br><span class="line">backup = 0913_NWPU_v3/backup/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>classes                类别数量<br>train                    训练集文件列表<br>valid                    验证集文件列表<br>names                类别名称文件<br>backup               权重存放目录</p>
</blockquote>
<p>创建 <code>NWPU.names</code> 文件并写入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aeroplane</span><br><span class="line">ship</span><br><span class="line">storage_tank</span><br><span class="line">baseball_diamond</span><br><span class="line">tennis_court</span><br><span class="line">basketball_court</span><br><span class="line">ground_track_field</span><br><span class="line">harbor</span><br><span class="line">bridge</span><br><span class="line">vehicle</span><br></pre></td></tr></table></figure>

<p>修改 <code>yolov3-voc.cfg</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[net]</span><br><span class="line"># Testing</span><br><span class="line"># batch=1           # 注释掉</span><br><span class="line"># subdivisions=1    # 注释掉</span><br><span class="line">#Training</span><br><span class="line">batch=64            # 取消注释</span><br><span class="line">subdivisions=16     # 取消注释</span><br><span class="line">......</span><br><span class="line"># 605, 689, 773 行的 filters</span><br><span class="line">filters=45          # (4个位置 + 1个objectness + C个类别) * 3, 只改 [yolo] 层上一层中的filters</span><br><span class="line"># 611, 695, 779 行的 classes</span><br><span class="line">classes=10          # 类别数</span><br></pre></td></tr></table></figure>

<h3 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h3><p>下载预训练文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">wget https://pjreddie.com/media/files/darknet53.conv.74</span><br></pre></td></tr></table></figure>

<p>开始训练</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./darknet detector train 0913_NWPU_v3/voc.data 0913_NWPU_v3/yolov3-voc.cfg darknet53.conv.74 -gpus 0,1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-gpus 指定训练使用的 GPU, 这里使用了第 0 块和第 1 块显卡</p>
</blockquote>
<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">layer     filters    size              input                output</span><br><span class="line">    0 conv     32  3 x 3 / 1   416 x 416 x   3   -&gt;   416 x 416 x  32  0.299 BFLOPs</span><br><span class="line">    1 conv     64  3 x 3 / 2   416 x 416 x  32   -&gt;   208 x 208 x  64  1.595 BFLOPs</span><br><span class="line">    2 conv     32  1 x 1 / 1   208 x 208 x  64   -&gt;   208 x 208 x  32  0.177 BFLOPs</span><br><span class="line">    ......</span><br><span class="line">  105 conv     45  1 x 1 / 1    52 x  52 x 256   -&gt;    52 x  52 x  45  0.062 BFLOPs</span><br><span class="line">  106 yolo</span><br><span class="line">Loading weights from darknet53.conv.74...Done!</span><br><span class="line">Learning Rate: 0.001, Momentum: 0.9, Decay: 0.0005</span><br><span class="line">Resizing</span><br><span class="line">320</span><br><span class="line">Loaded: 0.000029 seconds</span><br><span class="line">Region 82 Avg IOU: -nan, Class: -nan, Obj: -nan, No Obj: 0.539972, .5R: -nan, .75R: -nan,  count: 0</span><br><span class="line">Region 94 Avg IOU: 0.527418, Class: 0.748367, Obj: 0.665674, No Obj: 0.590720, .5R: 1.000000, .75R: 0.000000,  count: 1</span><br><span class="line">Region 106 Avg IOU: 0.204739, Class: 0.530762, Obj: 0.475587, No Obj: 0.427459, .5R: 0.142857, .75R: 0.000000,  count: 42</span><br><span class="line">Region 82 Avg IOU: 0.334140, Class: 0.682158, Obj: 0.326366, No Obj: 0.540248, .5R: 0.000000, .75R: 0.000000,  count: 1</span><br><span class="line">Region 94 Avg IOU: 0.279358, Class: 0.548496, Obj: 0.595618, No Obj: 0.589648, .5R: 0.333333, .75R: 0.166667,  count: 6</span><br><span class="line">Region 106 Avg IOU: 0.175368, Class: 0.478585, Obj: 0.391913, No Obj: 0.430448, .5R: 0.000000, .75R: 0.000000,  count: 9</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><strong>注:</strong></p>
<ol>
<li><p><code>yolov3-voc.cfg</code> 配置文件中的 <code>batch</code> 和 <code>subdivisions</code> 需根据 GPU 显存大小修改, 若显存较小, 应相应地减小 <code>batch</code> 增大 <code>subdivisions</code></p>
</li>
<li><p>查看显存占用可用 <code>nvidia-smi</code>, 输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wed Mar 13 15:36:29 2019       </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 384.111                Driver Version: 384.111                   |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  GeForce GTX 1080    Off  | 00000000:02:00.0 Off |                  N/A |</span><br><span class="line">| 59%   83C    P2   104W / 180W |   2729MiB /  8112MiB |     93%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   1  GeForce GTX 1080    Off  | 00000000:03:00.0 Off |                  N/A |</span><br><span class="line">| 54%   81C    P2   133W / 180W |   6861MiB /  8114MiB |     18%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+                                                                            </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                       GPU Memory |</span><br><span class="line">|  GPU       PID   Type   Process name                             Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|    0     28529      C   python                                      2719MiB |</span><br><span class="line">|    1      2040      C   python3                                     6851MiB |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure></li>
<li><p>如果输出中全都是 <code>-nan</code>, <code>count</code> 全为 <code>0</code> 问题很有可能在数据集上</p>
</li>
<li><p>官方代码默认前 <code>1000</code>次, 每 <code>100</code> 次保存一次权重；<code>1000</code> 次之后每 <code>10000</code> 次保存一次权重, 可在 <code>examples/detector.c</code> 的 <code>130</code> 及 <code>138</code> 行自行修改, 重新编译即可生效</p>
</li>
<li><p>若训练中途停止, 将训练命令中的 <code>darknet53.conv.74</code> 改为已得到的最新的权重的路径即可继续训练</p>
</li>
<li><p>训练输出日志含义见<a href="https://blog.csdn.net/gzj2013/article/details/82285511">此文</a></p>
</li>
<li><p>保存训练日志到文件追加 <code>tee</code> 命令, 例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./darknet detector train 0913_NWPU_v3/voc.data 0913_NWPU_v3/yolov3-voc.cfg darknet53.conv.74 -gpus 0,1 | tee -a 0913_train.log</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><h3 id="生成检测结果"><a href="#生成检测结果" class="headerlink" title="生成检测结果"></a>生成检测结果</h3><p>修改 <code>yolov3-voc.cfg</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[net]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Testing</span></span><br><span class="line">batch=1             # 取消注释</span><br><span class="line">subdivisions=1      # 取消注释</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Training</span>      </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">batch=64          <span class="comment"># 注释掉</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">subdivisions=16   <span class="comment"># 注释掉</span></span></span><br></pre></td></tr></table></figure>

<p>使用 valid 命令，将验证集结果批量生成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./darknet detector valid 0913_NWPU_v3/NWPU.data 0913_NWPU_v3/yolov3-voc.cfg 0913_NWPU_v3/backup/yolov3-voc_10500.weights</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">results: Using default &#x27;results&#x27;</span><br><span class="line">layer     filters    size              input                output</span><br><span class="line">    0 conv     32  3 x 3 / 1   416 x 416 x   3   -&gt;   416 x 416 x  32  0.299 BFLOPs</span><br><span class="line">    1 conv     64  3 x 3 / 2   416 x 416 x  32   -&gt;   208 x 208 x  64  1.595 BFLOPs</span><br><span class="line">    2 conv     32  1 x 1 / 1   208 x 208 x  64   -&gt;   208 x 208 x  32  0.177 BFLOPs</span><br><span class="line">    ......</span><br><span class="line">  105 conv     45  1 x 1 / 1    52 x  52 x 256   -&gt;    52 x  52 x  45  0.062 BFLOPs</span><br><span class="line">  106 yolo</span><br><span class="line">Loading weights from 0913_NWPU_v3/backup/yolov3-voc_10500.weights...Done!</span><br><span class="line">Learning Rate: 0.001, Momentum: 0.9, Decay: 0.0005</span><br><span class="line">eval: Using default &#x27;voc&#x27;</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">12</span><br><span class="line">......</span><br><span class="line">160</span><br><span class="line">Total Detection Time: 14.854030 Seconds</span><br></pre></td></tr></table></figure>

<p>输出文件均保存在 <code>results</code> 目录下</p>
<h3 id="计算-mAP"><a href="#计算-mAP" class="headerlink" title="计算 mAP"></a>计算 mAP</h3><p>将西工大数据集转换为 VOC 格式, 代码: <a href="https://github.com/zcybupt/rawfiles/blob/master/codes/nwpu2voc/nwpu2voc.py">nwpu2voc.py</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd NWPU_VHR-10_dataset</span><br><span class="line">python nwpu2voc.py  # 将 nwpu2voc.py 放到 NWPU_VHR-10_dataset 目录下</span><br></pre></td></tr></table></figure>

<p>下载 <a href="https://github.com/zcybupt/rawfiles/blob/master/codes/voc%E8%AF%84%E4%BC%B0/reval_voc.py">reval_voc.py</a> 和 <a href="https://github.com/zcybupt/rawfiles/blob/master/codes/voc%E8%AF%84%E4%BC%B0/voc_eval.py">voc_eval.py</a>, 以下代码需在 <code>Python2</code> 环境下运行并预先装好 <code>numpy</code>, 推荐用 <code>Miniconda</code> 管理 Python 环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">python reval_voc.py --voc_dir NWPU_VHR-10_dataset/VOCdevkit --year 2007 --image_set test --class ./0913_NWPU_v3/NWPU.names ./valid_results</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Evaluating detections</span><br><span class="line">VOC07 metric? Yes</span><br><span class="line">AP for aeroplane = 0.9949</span><br><span class="line">AP for ship = 0.8182</span><br><span class="line">AP for storage_tank = 0.8013</span><br><span class="line">AP for baseball_diamond = 0.9827</span><br><span class="line">AP for tennis_court = 0.8040</span><br><span class="line">AP for basketball_court = 0.8182</span><br><span class="line">AP for ground_track_field = 0.9947</span><br><span class="line">AP for harbor = 0.7442</span><br><span class="line">AP for bridge = 0.8961</span><br><span class="line">AP for vehicle = 0.8689</span><br><span class="line">Mean AP = 0.8723</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">Results computed with the **unofficial** Python eval code.</span><br><span class="line">Results should be very close to the official MATLAB eval code.</span><br><span class="line">-- Thanks, The Management</span><br><span class="line">--------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>更多信息参见 <a href="https://www.jianshu.com/p/7ae10c8f7d77">Darknet 评估训练好的网络的性能</a></p>
<h2 id="其它参考资料"><a href="#其它参考资料" class="headerlink" title="其它参考资料"></a>其它参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/35490655">DarkNet-YOLOv3 训练自己的数据集 Ubuntu16.04+cuda8.0</a></p>
<p><a href="https://blog.csdn.net/mieleizhi0522/article/details/79989754">YOLOv3批量测试图片并保存在自定义文件夹下</a></p>
<p><a href="https://blog.csdn.net/sinat_30071459/article/details/53100791">YOLO(v1)用自己的数据集训练模型</a></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><a href="https://github.com/zcybupt/rawfiles/tree/master/IGARSS_codes">IGARSS 代码及配置文件打包</a></p>
]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>无 root 配置 CUDA 10 运行 Yolo v4</title>
    <url>/2020/07/08/Yolov4Deployment/</url>
    <content><![CDATA[<h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><p>在无 root 的情况下可将 cuda 安装到自己的目录中, 配置好环境变量即可使用.</p>
<p>服务器基础信息:</p>
<blockquote>
<p>  OS: Ubuntu 16.04<br>  Kernel: x86_64 Linux 4.13.0-38-generic<br>  CPU: Intel Xeon CPU E5-2620 v3 @ 3.2GHz<br>  GPU: 双路 GeForce RTX 2080Ti<br>  GPU驱动版本: 430.50<br>  RAM: 128 GB<br>  GCC: 5.4.1</p>
</blockquote>
<h3 id="CUDA-10-安装"><a href="#CUDA-10-安装" class="headerlink" title="CUDA 10 安装"></a>CUDA 10 安装</h3><p>到英伟达官网下载<a href="https://developer.nvidia.com/cuda-downloads">CUDA toolkit</a>的 runfile, 本文以 10.0 版本为例</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200708201529.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://developer.nvidia.com/compute/cuda/10.0/Prod/local_installers/cuda_10.0.130_410.48_linux</span></span><br></pre></td></tr></table></figure>

<p>赋予可执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x ./cuda_10.0.130_410.48_linux</span></span><br></pre></td></tr></table></figure>

<p>执行安装程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./cuda_10.0.130_410.48_linux</span></span><br></pre></td></tr></table></figure>

<p>按空格向下滚动, accept 许可</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200708202500.png"></p>
<p>提示是否安装显卡驱动, 由于已安装驱动, 且无 root 不可覆盖安装, 故输入 n 跳过</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200708202851.png"></p>
<p>按 y 安装 CUDA Toolkit, 在此需输入自己的 CUDA 安装路径, <strong>一定要选择自己有写入权限的目录</strong>, 若文件夹不存在将会自动创建, 在此以 <code>/server_space/zhaoym/cuda-10.0</code> 为例.</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200708203038.png"></p>
<p>软链接无需创建, CUDA Samples 也无需安装</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200708203218.png"></p>
<p>若 Toolkit 为 Installed 即为安装成功.</p>
<h3 id="cuDNN-安装"><a href="#cuDNN-安装" class="headerlink" title="cuDNN 安装"></a>cuDNN 安装</h3><p>首先下载 <a href="https://developer.nvidia.com/cudnn">cuDNN 库压缩文件</a>, 该链接不可直接通过 wget 下载, 可先使用浏览器打开, 再复制浏览器下载时跳转的地址进行下载</p>
<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200708203643.png"></p>
<p>解压压缩文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -zxvf cudnn-10.0-linux-x64-v7.6.5.32.tgz</span></span><br></pre></td></tr></table></figure>

<p>得到名为 cuda 的文件夹, 其目录结构与 CUDA 安装路径的目录结构相同</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cuda</span><br><span class="line">├── NVIDIA_SLA_cuDNN_Support.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── cudnn.h</span><br><span class="line">└── lib64</span><br><span class="line">    ├── libcudnn.so -&gt; libcudnn.so.7</span><br><span class="line">    ├── libcudnn.so.7 -&gt; libcudnn.so.7.6.5</span><br><span class="line">    ├── libcudnn.so.7.6.5</span><br><span class="line">    └── libcudnn_static.a</span><br></pre></td></tr></table></figure>

<p>将该文件夹下的文件分别复制到之前安装 CUDA 10 的<strong>对应</strong>路径中, 本例中即为 <code>/server_space/zhaoym/cuda-10.0</code></p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>打开 <code>~/.bashrc</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi ~/.bashrc</span></span><br></pre></td></tr></table></figure>

<p>在末尾追加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=/server_space/zhaoym/cuda-10.0/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/server_space/zhaoym/cuda-10.0/lib64:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>若之前有配置过其它版本的 CUDA, 需先将其注释掉</p>
<p>退出编辑器, 使环境变量生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> ~/.bashrc</span></span><br></pre></td></tr></table></figure>

<p>至此 CUDA 和 cuDNN 安装结束</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvcc -V</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2018 NVIDIA Corporation</span><br><span class="line">Built on Sat_Aug_25_21:08:01_CDT_2018</span><br><span class="line">Cuda compilation tools, release 10.0, V10.0.130</span><br></pre></td></tr></table></figure>

<h2 id="Yolo-v4-编译"><a href="#Yolo-v4-编译" class="headerlink" title="Yolo v4 编译"></a>Yolo v4 编译</h2><p>项目主页: <a href="https://github.com/AlexeyAB/darknet">https://github.com/AlexeyAB/darknet</a></p>
<p>预训练权重: <a href="https://drive.google.com/open?id=1cewMfusmPjYWbrnuJRuKhPMwRe_b9PaT">yolov4.weights</a></p>
<p>克隆项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/AlexeyAB/darknet.git</span></span><br></pre></td></tr></table></figure>

<p>修改 Makefile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi Makefile</span></span><br></pre></td></tr></table></figure>

<p>将前三行修改为1, RTX 2080 Ti 为图灵架构, 将 CUDNN_HALF 设为 1 可进一步加速计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPU=1</span><br><span class="line">CUDNN=1</span><br><span class="line">CUDNN_HALF=1</span><br></pre></td></tr></table></figure>

<p>服务器默认 GCC/G++ 版本为 4.9.4, 这里改为使用更高的 5.4.1, 修改 60 和 62 行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifeq ($(USE_CPP), 1)</span><br><span class="line">CC=g++-5</span><br><span class="line">else</span><br><span class="line">CC=gcc-5</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>全局查找并替换 <code>/usr/local/cuda</code> 为 <code>/server_space/zhaoym/cuda-10.0</code></p>
<p>按 ESC 进入命令模式, 输入以下内容 , 回车完成替换</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:%s/\/usr\/local\/cuda/\/server_space\/zhaoym\/cuda-10.0/g</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make -j8</span></span><br></pre></td></tr></table></figure>

<p>若编译出错, 修改后需 <code>make clean</code> 再重新 <code>make</code></p>
<p>运行 demo</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./darknet detector <span class="built_in">test</span> ./cfg/coco.data ./cfg/yolov4.cfg ./yolov4.weights</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zcybupt/images/master/PicGo/20200708211444.png"></p>
<p>Yolo v4 的训练配置方式与 v3 相同, 可参考之前的文章: <a href="https://zcybupt.github.io/post/YoloDeployment">YOLO v3 环境搭建及训练入门指南</a></p>
]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>锯齿迭代器</title>
    <url>/2022/01/16/ZigzagIterator/</url>
    <content><![CDATA[<h2 id="题目-LeetCode-281"><a href="#题目-LeetCode-281" class="headerlink" title="题目(LeetCode #281)"></a>题目(LeetCode #281)</h2><p>Given two 1d vectors, implement an iterator to return their elements alternately.</p>
<p>Example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">v1 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">v2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">Explanation: By calling <span class="built_in">next</span> repeatedly until hasNext returns false,</span><br><span class="line">             the order of elements returned by <span class="built_in">next</span> should be: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure>

<p>Follow up: What if you are given k 1d vectors? How well can your code be extended to such cases?</p>
<p>Clarification for the follow up question:</p>
<p>The “Zigzag” order is not clearly defined and is ambiguous for k &gt; 2 cases. If “Zigzag” does not look right to you, replace “Zigzag” with “Cyclic”. For example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">[<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>].</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>k 为 2 的基础情况时，可使用两个索引 <code>i</code> 和 <code>j</code> 分别标记移动位置，<code>hasNext()</code> 判断两索引是否到达列表尾即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZigzagIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; v1;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; v2;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZigzagIterator</span><span class="params">(List&lt;Integer&gt; v1, List&lt;Integer&gt; v2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.v1 = v1;</span><br><span class="line">        <span class="built_in">this</span>.v2 = v2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; j ? v2.get(j++) : v1.get(i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= v1.size()) i = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= v2.size()) j = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> i &lt; v1.size() || j &lt; v2.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Follow up 中 k &gt; 2 时，可使用队列保存各个列表的迭代器。调用 <code>next()</code> 时，依次取出队首迭代器的值，并判断该迭代器是否还有后续元素，若仍有后续元素则将该迭代器重新加入队列中，重复该操作直到队列为空为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZigzagIterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Iterator&lt;Integer&gt;&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZigzagIterator</span><span class="params">(List&lt;Integer&gt; v1, List&lt;Integer&gt; v2)</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!v1.isEmpty()) queue.add(v1.iterator());</span><br><span class="line">        <span class="keyword">if</span> (!v2.isEmpty()) queue.add(v2.iterator());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        Iterator&lt;Integer&gt; cur = queue.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> cur.next();</span><br><span class="line">        <span class="keyword">if</span> (cur.hasNext()) queue.add(cur);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>队列</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
</search>
